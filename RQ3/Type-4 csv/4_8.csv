code1,code2,repo,predictions
"/** Creates new form Locutus */
public Locutus(){
	initComponents();
	/* make tooltips stay a bit longer */
	ToolTipManager.sharedInstance().setDismissDelay(90000);
	statusPoller.start();
}","/** Creates new form Locutus */
public Locutus() 
{
    initComponents();
}   ",4,True
"//GEN-LAST:event_resetLocationsButtonActionPerformed
private void saveSettingsButtonActionPerformed(java.awt.event.ActionEvent evt){//GEN-FIRST:event_saveSettingsButtonActionPerformed
	    try {
		    Database.setSetting(""cache_lifetime"", """" + daemonCacheLifetimeSlider.getValue());
		    Database.setSetting(""album_weight"", """" + weightAlbumSlider.getValue());
		    Database.setSetting(""allow_group_duplicates"", """" + optionAllowGroupDuplicatesCheckBox.isSelected());
		    Database.setSetting(""artist_weight"", """" + weightArtistSlider.getValue());
		    Database.setSetting(""audioscrobbler_artist_tag_url"", audioscrobblerArtistURLTextField.getText());
		    Database.setSetting(""audioscrobbler_query_interval"", """" + daemonAudioscrobblerQueryIntervalSlider.getValue());
		    Database.setSetting(""audioscrobbler_track_tag_url"", audioscrobblerTrackURLTextField.getText());
		    Database.setSetting(""combine_groups"", """" + optionCombineGroupsCheckBox.isSelected());
		    Database.setSetting(""combine_threshold"", """" + ((double) compareCombineThresholdSlider.getValue() / 100.0));
		    Database.setSetting(""compare_relative_score"", """" + ((double) compareCompareRelativeScoreSlider.getValue() / 100.0));
		    Database.setSetting(""dry_run"", """" + optionDryRunCheckBox.isSelected());
		    Database.setSetting(""duplicate_directory"", duplicateDirectoryTextField.getText());
		    Database.setSetting(""duration_limit"", """" + compareDurationLimitSlider.getValue());
		    Database.setSetting(""duration_must_match"", """" + optionDurationMustMatchCheckBox.isSelected());
		    Database.setSetting(""duration_weight"", """" + weightDurationSlider.getValue());
		    Database.setSetting(""filename_format"", filenameFormatTextField.getText());
		    Database.setSetting(""filename_illegal_characters"", filenameIllegalCharactersTextField.getText());
		    Database.setSetting(""input_directory"", inputDirectoryTextField.getText());
		    Database.setSetting(""lookup_genre"", """" + optionLookupGenreCheckBox.isSelected());
		    Database.setSetting(""match_min_score"", """" + ((double) compareMatchMinScoreSlider.getValue() / 100.0));
		    Database.setSetting(""max_diff_best_score"", """" + ((double) compareMaxDiffBestScoreSlider.getValue() / 100.0));
		    Database.setSetting(""max_group_size"", """" + daemonMaxGroupSizeSlider.getValue());
		    Database.setSetting(""lookup_mbid"", """" + optionLookupMBIDCheckBox.isSelected());
		    Database.setSetting(""musicbrainz_search_url"", musicBrainzSearchURLTextField.getText());
		    Database.setSetting(""musicbrainz_query_interval"", """" + daemonMusicBrainzQueryIntervalSlider.getValue());
		    Database.setSetting(""only_save_complete_albums"", """" + optionOnlySaveCompleteAlbumsCheckBox.isSelected());
		    Database.setSetting(""only_save_if_all_match"", """" + optionOnlySaveIfAllMatchCheckBox.isSelected());
		    Database.setSetting(""output_directory"", outputDirectoryTextField.getText());
		    Database.setSetting(""musicbrainz_release_url"", musicBrainzReleaseURLTextField.getText());
		    Database.setSetting(""run_interval"", """" + daemonRunIntervalSlider.getValue());
		    Database.setSetting(""title_weight"", """" + weightTitleSlider.getValue());
		    Database.setSetting(""tracknumber_weight"", """" + weightTracknumberSlider.getValue());

		    DefaultTableModel table = (DefaultTableModel) otherSettingsTable.getModel();
		    for (int r = 0; r < table.getRowCount(); ++r) {
			    String key = (String) table.getValueAt(r, 0);
			    String value = (String) table.getValueAt(r, 1);
			    if (value == null)
				    value = """";
			    try {
				    if (key != null && !key.equals(""""))
					    Database.setSetting(key, value);
			    } catch (SQLException e) {
				    e.printStackTrace();
			    }
		    }
		    updateSettings();
	    } catch (SQLException e) {
		    e.printStackTrace();
	    }
    }","//GEN-LAST:event_resetLocationsButtonActionPerformed
private void saveSettingsButtonActionPerformed(java.awt.event.ActionEvent evt) 
{//GEN-FIRST:event_saveSettingsButtonActionPerformed
    saveSettings();
}   ",6,False
"// </editor-fold>//GEN-END:initComponents
private void connectButtonActionPerformed(java.awt.event.ActionEvent evt){//GEN-FIRST:event_connectButtonActionPerformed
		try {
			setProgress(0.0, ""Not connected"");
			connectFrame.setVisible(false);
			Database.disconnect();
			String db = driverCombo.getSelectedItem().toString();
			db += hostTextField.getText();
			db += ""/"";
			db += databaseTextField.getText();
			Database.connectPostgreSQL(db, usernameTextField.getText(), new String(passwordPasswordField.getPassword()));
			tabPane.setSelectedComponent(matching);
			matching.updateTree();
			statusPoller.checkStatus();
		} catch (ClassNotFoundException e) {
			JOptionPane.showMessageDialog(this, e);
			e.printStackTrace();
		} catch (SQLException e) {
			JOptionPane.showMessageDialog(this, e);
			e.printStackTrace();
		}
	}","// </editor-fold>//GEN-END:initComponents





private void connectButtonActionPerformed(java.awt.event.ActionEvent evt) 
{
    if (connectButton.getText().equals(""Connect""))
    {
        try
        {
            socket = new Socket(serverAddress.getText(), Integer.parseInt(serverPort.getText()));
            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            out = new PrintWriter(socket.getOutputStream(), true);
            connectButton.setText(""Disconnect"");
            appendText(""Connected to server"");
        }
        catch (IOException ex)
        {
            appendText(""Error connecting to server: "" + ex.getMessage());
        }
    }
    else
    {
        try
        {
            socket.close();
            in = null;
            out = null;
            connectButton.setText(""Connect"");
            appendText(""Disconnected from server"");
        }
        catch (IOException ex)
        {
            appendText(""Error disconnecting from server: "" + ex.getMessage());
        }
    }
}   ",7,False
"//GEN-LAST:event_uncomparedTreeKeyPressed
private void uncomparedTreeValueChanged(javax.swing.event.TreeSelectionEvent evt){//GEN-FIRST:event_uncomparedTreeValueChanged
		TreePath[] paths = uncomparedTree.getSelectionPaths();
		if (paths == null) {
			Locutus.clearMetadata();
			return;
		}
		List<Metafile> metafiles = new ArrayList<Metafile>();
		for (TreePath path : paths) {
			DefaultMutableTreeNode node = ((DefaultMutableTreeNode) path.getLastPathComponent());
			Object object = node.getUserObject();
			if (object instanceof Group) {
				Enumeration files = node.children();
				while (files.hasMoreElements()) {
					object = ((DefaultMutableTreeNode) files.nextElement()).getUserObject();
					if (object instanceof Metafile && !metafiles.contains((Metafile) object))
						metafiles.add((Metafile) object);
				}
			} else if (object instanceof Metafile) {
				if (!metafiles.contains((Metafile) object))
					metafiles.add((Metafile) object);
			}
		}
		Locutus.setSelectedMetadatafiles(metafiles);
	}","//GEN-LAST:event_uncomparedTreeKeyPressed
private void uncomparedTreeValueChanged(javax.swing.event.TreeSelectionEvent evt) 
{
    if (evt.getSource() == uncomparedTree)
    {
        uncomparedTreeValueChangedHandler(evt);
    }
}   ",8,False
"/** Creates new form Uncompared */
public Uncompared(){
	initComponents();
	uncomparedTree.setCellRenderer(new UncomparedCellRenderer());
}","/** Creates new form Uncompared */
public Uncompared() 
{
    initComponents();
    this.setTitle(""Uncompared"");
    this.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
    this.setLocationRelativeTo(null);
    this.setResizable(false);
    this.setVisible(true);
}   ",9,True
"//GEN-LAST:event_updateButtonActionPerformed
private void filterTextFieldKeyPressed(java.awt.event.KeyEvent evt){//GEN-FIRST:event_filterTextFieldKeyPressed
		if (evt.getKeyCode() == KeyEvent.VK_ENTER)
			updateButton.doClick();
	}","//GEN-LAST:event_updateButtonActionPerformed
private void filterTextFieldKeyPressed(java.awt.event.KeyEvent evt) 
{
    if (evt.getKeyCode() == KeyEvent.VK_ENTER)
    {
        updateButtonActionPerformed(null);
    }
}   ",10,True
"//GEN-LAST:event_resetWeightButtonActionPerformed
private void resetCompareButtonActionPerformed(java.awt.event.ActionEvent evt){//GEN-FIRST:event_resetCompareButtonActionPerformed
	    try {
		    Database.resetSetting(""combine_threshold"");
		    Database.resetSetting(""max_diff_best_score"");
		    Database.resetSetting(""match_min_score"");
		    Database.resetSetting(""compare_relative_score"");
		    Database.resetSetting(""duration_limit"");
		    updateSettings();
	    } catch (SQLException e) {
		    e.printStackTrace();
	    }
    }","//GEN-LAST:event_resetWeightButtonActionPerformed
private void resetCompareButtonActionPerformed(java.awt.event.ActionEvent evt) 
{ //GEN-HEADEREND:event_resetCompareButtonActionPerformed
    if (evt.getSource() == resetCompareButton)
    {
        resetCompare();
    }
}   ",18,False
"// $ANTLR start T25
public final void mT25() throws RecognitionException{
    try {
        int _type = T25;
        // /Users/michaelarace/CodaClient/CodaClient.g:58:5: ( ']' )
        // /Users/michaelarace/CodaClient/CodaClient.g:58:7: ']'
        {
        match(']'); 

        }

        this.type = _type;
    }
    finally {
    }
}","// $ANTLR start T25
public final void mT25() throws RecognitionException 
{
    try
    {
        {
        match('T'); match('2'); match('5');

        }
    }
    catch (RecognitionException re)
    {
        reportError(re);
        recover(input, re);
    }
    finally
    {
    }
    return ;
}   ",20,True
"// $ANTLR start ASCIIStringLiteral
public final void mASCIIStringLiteral() throws RecognitionException{
    try {
        int _type = ASCIIStringLiteral;
        // /Users/michaelarace/CodaClient/CodaClient.g:244:5: ( '\\'' (~ '\\'' )* '\\'' ( '\\'' (~ '\\'' )* '\\'' )* )
        // /Users/michaelarace/CodaClient/CodaClient.g:245:5: '\\'' (~ '\\'' )* '\\'' ( '\\'' (~ '\\'' )* '\\'' )*
        {
        match('\''); 
        // /Users/michaelarace/CodaClient/CodaClient.g:245:10: (~ '\\'' )*
        loop5:
        do {
            int alt5=2;
            int LA5_0 = input.LA(1);

            if ( ((LA5_0>='\u0000' && LA5_0<='&')||(LA5_0>='(' && LA5_0<='\uFFFE')) ) {
                alt5=1;
            }


            switch (alt5) {
        	case 1 :
        	    // /Users/michaelarace/CodaClient/CodaClient.g:245:11: ~ '\\''
        	    {
        	    if ( (input.LA(1)>='\u0000' && input.LA(1)<='&')||(input.LA(1)>='(' && input.LA(1)<='\uFFFE') ) {
        	        input.consume();

        	    }
        	    else {
        	        MismatchedSetException mse =
        	            new MismatchedSetException(null,input);
        	        recover(mse);    throw mse;
        	    }


        	    }
        	    break;

        	default :
        	    break loop5;
            }
        } while (true);

        match('\''); 
        // /Users/michaelarace/CodaClient/CodaClient.g:245:24: ( '\\'' (~ '\\'' )* '\\'' )*
        loop7:
        do {
            int alt7=2;
            int LA7_0 = input.LA(1);

            if ( (LA7_0=='\'') ) {
                alt7=1;
            }


            switch (alt7) {
        	case 1 :
        	    // /Users/michaelarace/CodaClient/CodaClient.g:245:26: '\\'' (~ '\\'' )* '\\''
        	    {
        	    match('\''); 
        	    // /Users/michaelarace/CodaClient/CodaClient.g:245:31: (~ '\\'' )*
        	    loop6:
        	    do {
        	        int alt6=2;
        	        int LA6_0 = input.LA(1);

        	        if ( ((LA6_0>='\u0000' && LA6_0<='&')||(LA6_0>='(' && LA6_0<='\uFFFE')) ) {
        	            alt6=1;
        	        }


        	        switch (alt6) {
        	    	case 1 :
        	    	    // /Users/michaelarace/CodaClient/CodaClient.g:245:32: ~ '\\''
        	    	    {
        	    	    if ( (input.LA(1)>='\u0000' && input.LA(1)<='&')||(input.LA(1)>='(' && input.LA(1)<='\uFFFE') ) {
        	    	        input.consume();

        	    	    }
        	    	    else {
        	    	        MismatchedSetException mse =
        	    	            new MismatchedSetException(null,input);
        	    	        recover(mse);    throw mse;
        	    	    }


        	    	    }
        	    	    break;

        	    	default :
        	    	    break loop6;
        	        }
        	    } while (true);

        	    match('\''); 

        	    }
        	    break;

        	default :
        	    break loop7;
            }
        } while (true);


        }

        this.type = _type;
    }
    finally {
    }
}","// $ANTLR start ASCIIStringLiteral
public final void mASCIIStringLiteral() throws RecognitionException 
{
    try
    {
        int _type = ASCIIStringLiteral;
        int _channel = DEFAULT_TOKEN_CHANNEL;
        // ../org.universAAL.middleware.rdf/grammar/IRI.g4:153:2: ( QUOTED_STRING )
        // ../org.universAAL.middleware.rdf/grammar/IRI.g4:153:4: QUOTED_STRING
        {
        mQUOTED_STRING();
        }
        state.type = _type;
        state.channel = _channel;
    }
    finally
    {
    }
}   ",21,False
"// $ANTLR start Integer
public final void mInteger() throws RecognitionException{
    try {
        int _type = Integer;
        // /Users/michaelarace/CodaClient/CodaClient.g:236:9: ( '0' | '1' .. '9' ( '0' .. '9' )* )
        int alt2=2;
        int LA2_0 = input.LA(1);

        if ( (LA2_0=='0') ) {
            alt2=1;
        }
        else if ( ((LA2_0>='1' && LA2_0<='9')) ) {
            alt2=2;
        }
        else {
            NoViableAltException nvae =
                new NoViableAltException(""236:1: Integer : ( '0' | '1' .. '9' ( '0' .. '9' )* );"", 2, 0, input);

            throw nvae;
        }
        switch (alt2) {
            case 1 :
                // /Users/michaelarace/CodaClient/CodaClient.g:236:11: '0'
                {
                match('0'); 

                }
                break;
            case 2 :
                // /Users/michaelarace/CodaClient/CodaClient.g:236:17: '1' .. '9' ( '0' .. '9' )*
                {
                matchRange('1','9'); 
                // /Users/michaelarace/CodaClient/CodaClient.g:236:26: ( '0' .. '9' )*
                loop1:
                do {
                    int alt1=2;
                    int LA1_0 = input.LA(1);

                    if ( ((LA1_0>='0' && LA1_0<='9')) ) {
                        alt1=1;
                    }


                    switch (alt1) {
                	case 1 :
                	    // /Users/michaelarace/CodaClient/CodaClient.g:236:27: '0' .. '9'
                	    {
                	    matchRange('0','9'); 

                	    }
                	    break;

                	default :
                	    break loop1;
                    }
                } while (true);


                }
                break;

        }
        this.type = _type;
    }
    finally {
    }
}","// $ANTLR start Integer
public final void mInteger() throws RecognitionException 
{
    try
    {
        int _type = Integer;
        int _channel = DEFAULT_TOKEN_CHANNEL;
        // Integer.g4:3:9: ( ( '0' .. '9' )+ )
        // Integer.g4:3:11: ( '0' .. '9' )+
        {
            // Integer.g4:3:11: ( '0' .. '9' )+
            int cnt1 = 0;
            loop1:
            do
            {
                int alt1 = 2;
                int LA1_0 = input.LA(1);
                if (((LA1_0 >= '0' && LA1_0 <= '9')))
                {
                    alt1 = 1;
                }

                switch (alt1)
                {
                    case 1:
                        // Integer.g4:3:12: '0' .. '9'
                    {
                        matchRange('0', '9');
                    }
                    break;

                    default:
                        if (cnt1 >= 1)
                        {
                            break loop1;
                        }
                        EarlyExitException eee = new EarlyExitException(1, input);
                        throw eee;
                }
                cnt1++;
            } while (true);

        }
        state.type = _type;
        state.channel = _channel;
    }
    finally
    {
        // do for sure before leaving
    }
}   ",22,True
"// $ANTLR start T16
public final void mT16() throws RecognitionException{
    try {
        int _type = T16;
        // /Users/michaelarace/CodaClient/CodaClient.g:49:5: ( 'IN' )
        // /Users/michaelarace/CodaClient/CodaClient.g:49:7: 'IN'
        {
        match(""IN""); 


        }

        this.type = _type;
    }
    finally {
    }
}","// $ANTLR start T16
public final void mT16() throws RecognitionException 
{
    try
    {
        int _type = T16;
        int _channel = DEFAULT_TOKEN_CHANNEL;
        // T16.g4:3:7: ( 'T16' )
        // T16.g4:3:9: 'T16'
        {
        match(""T16""); 


        }

        state.type = _type;
        state.channel = _channel;
    }
    finally
    {
    }
}   ",24,True
"// $ANTLR start T14
public final void mT14() throws RecognitionException{
    try {
        int _type = T14;
        // /Users/michaelarace/CodaClient/CodaClient.g:47:5: ( 'APPLICATION' )
        // /Users/michaelarace/CodaClient/CodaClient.g:47:7: 'APPLICATION'
        {
        match(""APPLICATION""); 


        }

        this.type = _type;
    }
    finally {
    }
}","// $ANTLR start T14
public final void mT14() throws RecognitionException 
{
    try
    {
        int _type = T14;
        int _channel = DEFAULT_TOKEN_CHANNEL;
        // T.g4:3:5: ( 't' )
        // T.g4:3:7: 't'
        {
        match('t'); 

        }

        state.type = _type;
        state.channel = _channel;
    }
    finally
    {
    }
}   ",25,True
"// $ANTLR start T20
public final void mT20() throws RecognitionException{
    try {
        int _type = T20;
        // /Users/michaelarace/CodaClient/CodaClient.g:53:5: ( '=' )
        // /Users/michaelarace/CodaClient/CodaClient.g:53:7: '='
        {
        match('='); 

        }

        this.type = _type;
    }
    finally {
    }
}","// $ANTLR start T20
public final void mT20() throws RecognitionException 
{
    try
    {
        int _type = T20;
        int _channel = DEFAULT_TOKEN_CHANNEL;
        // T20.g4:6:5: ( 'T20' )
        // T20.g4:6:7: 'T20'
        {
        match(""T20""); 


        }

        state.type = _type;
        state.channel = _channel;
    }
    finally
    {
    }
}   ",26,True
"// $ANTLR start T19
public final void mT19() throws RecognitionException{
    try {
        int _type = T19;
        // /Users/michaelarace/CodaClient/CodaClient.g:52:5: ( 'SETENV' )
        // /Users/michaelarace/CodaClient/CodaClient.g:52:7: 'SETENV'
        {
        match(""SETENV""); 


        }

        this.type = _type;
    }
    finally {
    }
}","// $ANTLR start T19
public final void mT19() throws RecognitionException 
{
    try
    {
        int _type = T19;
        int _channel = DEFAULT_TOKEN_CHANNEL;
        // T.g4:3:5: ( 't' )
        // T.g4:3:7: 't'
        {
        match('t'); 

        }
        state.type = _type;
        state.channel = _channel;
    }
    finally
    {
    }
}   ",27,True
"// $ANTLR start T26
public final void mT26() throws RecognitionException{
    try {
        int _type = T26;
        // /Users/michaelarace/CodaClient/CodaClient.g:59:5: ( 'ERROR' )
        // /Users/michaelarace/CodaClient/CodaClient.g:59:7: 'ERROR'
        {
        match(""ERROR""); 


        }

        this.type = _type;
    }
    finally {
    }
}","// $ANTLR start T26
public final void mT26() throws RecognitionException 
{
    try
    {
        int _type = T26;
        int _channel = DEFAULT_TOKEN_CHANNEL;
        // T.g4:6:5: ( 't' )
        // T.g4:6:7: 't'
        {
        match('t'); 
        }

        state.type = _type;
        state.channel = _channel;
    }
    finally
    {
    }
}   ",28,True
"// $ANTLR start T23
public final void mT23() throws RecognitionException{
    try {
        int _type = T23;
        // /Users/michaelarace/CodaClient/CodaClient.g:56:5: ( 'DATA' )
        // /Users/michaelarace/CodaClient/CodaClient.g:56:7: 'DATA'
        {
        match(""DATA""); 


        }

        this.type = _type;
    }
    finally {
    }
}","// $ANTLR start T23
public final void mT23() throws RecognitionException 
{
    try
    {
        int _type = T23;
        int _channel = DEFAULT_TOKEN_CHANNEL;
        // T.g4:6:4: ( 't' )
        // T.g4:6:6: 't'
        {
        match('t'); 

        }

        state.type = _type;
        state.channel = _channel;
    }
    finally
    {
    }
}   ",33,True
"// $ANTLR start T27
public final void mT27() throws RecognitionException{
    try {
        int _type = T27;
        // /Users/michaelarace/CodaClient/CodaClient.g:60:5: ( 'EXIT' )
        // /Users/michaelarace/CodaClient/CodaClient.g:60:7: 'EXIT'
        {
        match(""EXIT""); 


        }

        this.type = _type;
    }
    finally {
    }
}","// $ANTLR start T27
public final void mT27() throws RecognitionException 
{
    try
    {
        mT27 = false;
        // grammar\\T.g4:29:5: ( 'T' )
        // grammar\\T.g4:29:7: 'T'
        {
        match('T'); 

        }

    }
    finally
    {
    	// do for sure before leaving
    }
}   ",35,True
"// $ANTLR start exit
// /Users/michaelarace/CodaClient/CodaClient.g:220:1: exit returns [boolean response] : 'EXIT' ;
public final exit_return exit() throws RecognitionException{
    exit_return retval = new exit_return();
    retval.start = input.LT(1);
    int exit_StartIndex = input.index();
    try {
        if ( backtracking>0 && alreadyParsedRule(input, 7) ) { return retval; }
        // /Users/michaelarace/CodaClient/CodaClient.g:221:2: ( 'EXIT' )
        // /Users/michaelarace/CodaClient/CodaClient.g:221:4: 'EXIT'
        {
        match(input,27,FOLLOW_27_in_exit338); if (failed) return retval;
        if ( backtracking==0 ) {

          			client.exit();
          			retval.response = true;
          		
        }

        }

        retval.stop = input.LT(-1);

    }

    	catch (MismatchedTokenException e) {
    		String msg = """";
    		String tokenName = ""<unknown>"";

                	if (e.expecting == Token.EOF) {
    			tokenName = ""EOF"";
    		} else  {
                    	tokenName = tokenNames[e.expecting];
               	}

                	msg = ""Mismatched input "" + getTokenErrorDisplay(e.token) + "" expecting "" + tokenName;
    		client.printError(msg + "" at line "" + e.line + "", position "" + e.charPositionInLine, 1008);
    	} catch (NoViableAltException e) {
    		//client.printError(""Line "" + e.line + "", Pos "" + e.charPositionInLine + "": "" + ""no viable alternative at input "" + getTokenErrorDisplay(e.token));
    	} catch (EarlyExitException e) {
    		client.printError(""Required (...)+ loop did not match anything at input "" + getTokenErrorDisplay(e.token)+ "" at line "" + e.line + "", position "" + e.charPositionInLine, 1008);
    	} catch (MismatchedSetException e) {
    		client.printError(""Mismatched input "" + getTokenErrorDisplay(e.token) + "" expecting set "" + e.expecting+ "" at line "" + e.line + "", position "" + e.charPositionInLine, 1008);
    	//} catch (MismatchedNotSetException e) {
    		//client.printError(""Line "" + e.line + "", Pos "" + e.charPositionInLine + "": "" + ""mismatched input "" + getTokenErrorDisplay(e.token) + "" expecting set "" + e.expecting);
    	} catch (FailedPredicateException e) {
    		client.printError(""Rule "" + e.ruleName + "" failed predicate: {"" + e.predicateText + ""}?""+ "" at line "" + e.line + "", position "" + e.charPositionInLine, 1008);
    	} catch (RecognitionException e) {
    		// do nothing
    	}

        
    finally {
        if ( backtracking>0 ) { memoize(input, 7, exit_StartIndex); }
    }
    return retval;
}","// $ANTLR start exit
// /Users/michaelarace/CodaClient/CodaClient.g:220:1: exit returns [boolean response] : 'EXIT' ;
public final exit_return exit() throws RecognitionException 
{
    boolean response = false;
    try
    {
        // /Users/michaelarace/CodaClient/CodaClient.g:221:2: ( 'EXIT' )
        // /Users/michaelarace/CodaClient/CodaClient.g:221:4: 'EXIT'
        {
        match(""EXIT""); 

        response = true;
        }

    }
    catch (RecognitionException re)
    {
        reportError(re);
        recover(input, re);
    }
    finally
    {
    }
    return response;
}   ",38,False
"// $ANTLR start T22
public final void mT22() throws RecognitionException{
    try {
        int _type = T22;
        // /Users/michaelarace/CodaClient/CodaClient.g:55:5: ( 'FETCH' )
        // /Users/michaelarace/CodaClient/CodaClient.g:55:7: 'FETCH'
        {
        match(""FETCH""); 


        }

        this.type = _type;
    }
    finally {
    }
}","// $ANTLR start T22
public final void mT22() throws RecognitionException 
{
    try
    {
        int _type = T22;
        int _channel = DEFAULT_TOKEN_CHANNEL;
        // T.g4:3:5: ( 'T' )
        // T.g4:3:7: 'T'
        {
        match('T'); 

        }

        state.type = _type;
        state.channel = _channel;
    }
    finally
    {
    }
}   ",39,True
"/*
 * imprime
 * 
 * (move
 *    destination,
 *    source
 * move)
 */
private void printStatement(MOVE s, int i){
    ident(i);
    print(""(move"");
    println();
    
    printExp(s.dst, i+1);
    print("","");
    println();
    
    printExp(s.src, i+1);
    println();
    
    ident(i);
    print(""move)"");
}","/*
 * imprime
 * 
 * (move
 *    destination,
 *    source
 * move)
 */
private void printStatement(MOVE s, int i) 
{
    printIndent();
    print(""move "");
    printExpression(s.getDestination(), i);
    print("", "");
    printExpression(s.getSource(), i);
    println("";"");
}   ",41,True
"/*
 * imprime
 * 
 * (mem
 *     exp
 * mem)
 */
private void printExp(MEM e, int i){
    ident(i);
    print(""(mem"");
    println();
    
    printExp(e.exp, i+1);
    println();
    
    ident(i);
    print(""mem)"");
}","/*
 * imprime
 * 
 * (mem
 *     exp
 * mem)
 */
private void printExp(MEM e, int i) 
{
    if (e instanceof MEM)
    {
        printExp((MEM) e, i);
    }
    else
    {
        printIndent(i);
        System.out.println(e);
    }
}   ",43,True
"/*
 * imprime
 * 
 * (call
 *     method,
 *     param1,
 *     param2,
 *     ...
 *     paramN
 * call)
 */
private void printExp(CALL e, int i){
    ident(i);
    print(""(call"");
    println();
    
    printExp(e.func, i+1);
    print("","");
    println();
    
    for( List<Exp> aux = e.args; aux != null; aux = aux.tail )
    {
        printExp(aux.head, i+1);
        
        if ( aux.tail != null )
            print("","");
        
        println();
    }
    
    ident(i);
    print(""call)"");
}","/*
 * imprime
 * 
 * (call
 *     method,
 *     param1,
 *     param2,
 *     ...
 *     paramN
 * call)
 */
private void printExp(CALL e, int i) 
{
    printExp(e.getMethod(), i);
    printExp(e.getParam(), i);
}   ",45,False
"/*
 * imprime
 * 
 * (seq
 *     stm1,
 *     stm2
 * seq)
 * 
 *  OU
 *  
 *  stm1
 */
private void printStatement(SEQ s, int i){
    if ( s.right == null )
        printStatement(s.left, i);
    else
    {
        ident(i);
        print(""(seq"");
        println();
        
        printStatement(s.left, i+1);
        print("","");
        println();
        
        printStatement(s.right, i+1);
        println();
        
        ident(i);
        print(""seq)"");
    }
}","/*
 * imprime
 * 
 * (seq
 *     stm1,
 *     stm2
 * seq)
 * 
 *  OU
 *  
 *  stm1
 */
private void printStatement(SEQ s, int i) 
{
    if (s.stm1 instanceof SEQ)
    {
        printStatement((SEQ) s.stm1, i);
    }
    else
    {
        printStatement(s.stm1, i);
    }

    if (s.stm2 instanceof SEQ)
    {
        printStatement((SEQ) s.stm2, i);
    }
    else
    {
        printStatement(s.stm2, i);
    }
}   ",46,True
"/**
 * Print a human-readable dump for debugging.
 */
public void show(java.io.PrintStream out){
    for (List<Node>p=nodes(); p!=null; p=p.tail)
    {
        Node n = p.head;
        out.print(n.toString());
        out.print("": "");
        for(List<Temp> q=def(n); q!=null; q=q.tail)
        {
            out.print(q.head.toString());
            out.print("" "");
        }
        out.print(isMove(n) ? ""<= "" : ""<- "");
        for(List<Temp> q=use(n); q!=null; q=q.tail)
        {
            out.print(q.head.toString());
            out.print("" "");
        }
        out.print(""; goto "");
        for(List<Node> q=n.succ(); q!=null; q=q.tail)
        {
            out.print(q.head.toString());
            out.print("" "");
        }
        out.println();
    }
}","/**
 * Print a human-readable dump for debugging.
 */
public void show(java.io.PrintStream out) 
{
    out.println(""  "" + name + "" = {"");
    for (int i = 0; i < size; i++)
    {
        out.print(""    "");
        if (i < 10) out.print("" "");
        out.print(i);
        out.print("": "");
        if (i < size - 1)
        {
            out.print(data[i]);
            out.print("", "");
        }
        else
        {
            out.print(data[i]);
        }
        out.println();
    }
    out.println(""  }"");
}   ",48,False
"/*----------------------*/
/* ASSIGN, ARRAY ASSIGN */
/*----------------------*/
public void visit(Assign node){        
    Symbol name = Symbol.symbol(node.var.s);
    
    tree.Exp var = getVariable(name);
    
    Exp e = ExpHandler.translate(frame, env, cinfo, minfo, node.exp);
    
    Stm s = new MOVE(var, e.unEx());
    
    result = new Nx(s);
}","/*----------------------*/
/* ASSIGN, ARRAY ASSIGN */
/*----------------------*/
public void visit(Assign node) 
{
    node.left.accept(this);
    node.right.accept(this);
}   ",49,False
"/*
 * imprime
 * 
 * (jump
 *     exp,
 *     label 1,
 *     label 2,
 *     ...
 *     label n
 * jump)
 */
private void printStatement(JUMP s, int i){
    ident(i);
    print(""(jump"");
    println();
    
    printExp(s.exp, i+1);
    print("","");
    println();
    
    
    for ( List<Label> aux = s.targets; aux != null; aux = aux.tail )
    {
        ident(i+1);
        print(aux.head.toString());
        
        if ( aux.tail != null )
            print("","");
        
        println();
    }
    
    ident(i);
    print(""jump)"");
}","/*
 * imprime
 * 
 * (jump
 *     exp,
 *     label 1,
 *     label 2,
 *     ...
 *     label n
 * jump)
 */
private void printStatement(JUMP s, int i) 
{
    printIndent(i);
    print(""jump"");
    printExpression(s.exp, 0);
    print("","");
    printLabel(s.label, 0);
    for (int j = 0; j < s.targets.size(); j++)
    {
        print("","");
        printLabel(s.targets.get(j), 0);
    }
    println();
}   ",51,True
"/*-----------*/
/* LESS THAN */
/*-----------*/
public void visit(LessThan node){
    Exp lhs = ExpHandler.translate(frame, env, cinfo, minfo, node.lhs);
    Exp rhs = ExpHandler.translate(frame, env, cinfo, minfo, node.rhs);
    
    int op = CJUMP.LT;
    
    result = new RelCx(op, lhs, rhs);        
}","/*-----------*/
/* LESS THAN */
/*-----------*/
public void visit(LessThan node) 
{
    node.left.accept(this);
    node.right.accept(this);
    this.m_output.append(""  i32.lt_s\n"");
}   ",52,False
"/*----------------------------*/
/* ARRAY LOOKUP, ARRAY LENGTH */
/*----------------------------*/
public void visit(ArrayLength node){
    tree.Exp array = ExpHandler.translate(frame, env, cinfo, minfo, node.array).unEx();
    
    Temp arr = new Temp();
    
    Temp size = new Temp();
    
    List<tree.Exp> params = new List<tree.Exp>(new TEMP(arr),
            new List<tree.Exp>(new CONST(node.line), null));
    
    
    tree.Stm move = new MOVE(new TEMP(arr), array);
    tree.Stm as = new EXPSTM(frame.externalCall(""assertPtr"", params));
    tree.Stm s = new MOVE(new TEMP(size),
            new BINOP(BINOP.PLUS, new TEMP(arr), new CONST(0)));
    
    tree.Stm aux = new SEQ(move, new SEQ(as,s));
    
    tree.Exp fetchSize = new ESEQ(aux, new MEM(new TEMP(size)));
    
    result = new Ex(fetchSize);
}","/*----------------------------*/
/* ARRAY LOOKUP, ARRAY LENGTH */
/*----------------------------*/
public void visit(ArrayLength node) 
{
    node.expr().accept(this);
    mv.visitMethodInsn(INVOKESTATIC, ""java/lang/Integer"", ""valueOf"", ""(I)Ljava/lang/Integer;"", false);
}   ",53,False
"/*-------*/
/* PRINT */
/*-------*/
public void visit(Print node){
    tree.Exp arg = ExpHandler.translate(frame, env, cinfo, minfo, node.exp).unEx();
    
    List<tree.Exp> param = new List<tree.Exp>(arg, null);
    
    tree.Exp call = frame.externalCall(""printInt"", param);
    
    result = new Nx(new EXPSTM(call));
}","/*-------*/
/* PRINT */
/*-------*/
public void visit(Print node) 
{
    print(""print("");
    node.expr().accept(this);
    print("");\n"");
}   ",54,False
"/*
 * imprime
 * 
 * (const
 *     const
 * const)
 */
private void printExp(CONST e, int i){
    ident(i);
    print(""(const"");
    println();
    
    ident(i+1);
    print("""" + e.value);
    println();
    
    ident(i);
    print(""const)"");
}","/*
 * imprime
 * 
 * (const
 *     const
 * const)
 */
private void printExp(CONST e, int i) 
{
    if (e instanceof CONST)
    {
        printExp((CONST)e.getCar(), i);
    }
    else
    {
        System.out.print(""("");
        printExp((CONST)e.getCdr().getCar(), 1);
        System.out.print("" "");
        printExp((CONST)e.getCdr().getCdr().getCar(), 2);
        System.out.print("")"");
    }
}   ",55,False
"/**
 * Override to handle rendering characters with textMode(SHAPE).
 */
protected void textCharImpl(char ch, float x, float y){
	if (textMode == SHAPE) {
		if (textFont.getFont() == null) {
			PGraphics
					.showWarning(""textMode(SHAPE) is disabled because the font ""
							+ ""\"""" + textFont.name + ""\"" is not available."");
		} else {
			textCharShapeImpl(ch, x, y);
		}
	} else {
		super.textCharImpl(ch, x, y);
	}
}","/**
 * Override to handle rendering characters with textMode(SHAPE).
 */
protected void textCharImpl(char ch, float x, float y) 
{
    if (textMode == SHAPE)
    {
        renderCharacter(ch, x, y);
    }
    else
    {
        super.textCharImpl(ch, x, y);
    }
}   ",60,False
"/**
 * Cleans up the object when it's destroyed.
 */
protected void finalize()
   throws Throwable{
   this.reader = null;
   super.finalize();
}","/**
 * Cleans up the object when it's destroyed.
 */
protected void finalize()
   throws Throwable 
{
   try
   {
      close();
   }
   finally
   {
      super.finalize();
   }
}  ",61,True
"/**
 * Make the OpenGL rendering context current for this thread.
 */
protected void detainContext(){
	try {
		while (context.makeCurrent() == GLContext.CONTEXT_NOT_CURRENT) {
			// System.out.println(""Context not yet current..."");
			// new Exception().printStackTrace(System.out);
			// Thread.sleep(1000);
			Thread.sleep(10);
		}
	} catch (InterruptedException e) {
		e.printStackTrace();
	}
}","/**
 * Make the OpenGL rendering context current for this thread.
 */
protected void detainContext() 
{
    if (context != null)
    {
        context.makeCurrent();
    }
}   ",63,True
"/**
 * Load the calculated color into a pre-allocated array so that it can be
 * quickly passed over to OpenGL.
 */
private final void calcColorBuffer(){
	if (colorBuffer == null) {
		// colorBuffer = BufferUtil.newFloatBuffer(4);
		colorBuffer = new float[4];
	}
	colorBuffer[0] = calcR;
	colorBuffer[1] = calcG;
	colorBuffer[2] = calcB;
	colorBuffer[3] = calcA;
	// colorBuffer.put(0, calcR);
	// colorBuffer.put(1, calcG);
	// colorBuffer.put(2, calcB);
	// colorBuffer.put(3, calcA);
	// colorBuffer.rewind();
}","/**
 * Load the calculated color into a pre-allocated array so that it can be
 * quickly passed over to OpenGL.
 */
private final void calcColorBuffer() 
{
    if (colorBuffer == null)
    {
        colorBuffer = new float[4];
    }
    color.getColorComponents(colorBuffer);
}   ",65,True
"/**
 * Set an image directly to the screen.
 * <P>
 * TODO not optimized properly, creates multiple temporary buffers the size
 * of the image. Needs to instead use image cache, but that requires two
 * types of image cache. One for power of 2 textures and another for
 * glReadPixels/glDrawPixels data that's flipped vertically. Both have their
 * components all swapped to native.
 */
public void set(int x, int y, PImage source){
	int[] backup = new int[source.pixels.length];
	System.arraycopy(source.pixels, 0, backup, 0, source.pixels.length);
	javaToNativeARGB(source);

	// TODO is this possible without intbuffer?
	IntBuffer setBuffer = BufferUtil.newIntBuffer(source.pixels.length);
	setBuffer.put(source.pixels);
	setBuffer.rewind();

	setRasterPos(x, (height - y) - source.height); // +source.height);
	gl.glDrawPixels(source.width, source.height, GL.GL_RGBA,
			GL.GL_UNSIGNED_BYTE, setBuffer);
	source.pixels = backup;
}","/**
 * Set an image directly to the screen.
 * <P>
 * TODO not optimized properly, creates multiple temporary buffers the size
 * of the image. Needs to instead use image cache, but that requires two
 * types of image cache. One for power of 2 textures and another for
 * glReadPixels/glDrawPixels data that's flipped vertically. Both have their
 * components all swapped to native.
 */
public void set(int x, int y, PImage source) 
{
    if (source == null) return;

    if (source.width != width || source.height != height)
    {
        throw new RuntimeException(""Image must be same dimensions as display window"");
    }

    glRasterPos2i(x, y);
    glDrawPixels(source.width, source.height, GL_RGBA, GL_UNSIGNED_BYTE, source.pixels);
}   ",68,True
"// public void noFill()
// public void fill(int rgb)
// public void fill(int rgb, float alpha)
// public void fill(float gray)
// public void fill(float gray, float alpha)
// public void fill(float x, float y, float z)
// public void fill(float x, float y, float z, float a)
protected void fillFromCalc(){
	super.fillFromCalc();
	calcColorBuffer();
	gl.glMaterialfv(GL.GL_FRONT_AND_BACK, GL.GL_AMBIENT_AND_DIFFUSE,
			colorBuffer, 0);
}","// public void noFill()
// public void fill(int rgb)
// public void fill(int rgb, float alpha)
// public void fill(float gray)
// public void fill(float gray, float alpha)
// public void fill(float x, float y, float z)
// public void fill(float x, float y, float z, float a)
protected void fillFromCalc() 
{
  if (fillFromCalc)
  {
    super.fill(calcR, calcG, calcB, calcA);
  }
  else
  {
    super.noFill();
  }
}   ",69,True
"/**
 * This is really inefficient and not a good idea in OpenGL. Use get() and
 * set() with a smaller image area, or call the filter on an image instead,
 * and then draw that.
 */
public void filter(int kind, float param){
	PImage temp = get();
	temp.filter(kind, param);
	set(0, 0, temp);
}","/**
 * This is really inefficient and not a good idea in OpenGL. Use get() and
 * set() with a smaller image area, or call the filter on an image instead,
 * and then draw that.
 */
public void filter(int kind, float param) 
{
    if (kind == FILTER_GRAYSCALE) {
        if (param == 1.0f) {
            filter = FILTER_GRAYSCALE;
        } else {
            filter = FILTER_GRAYSCALE_PARAM;
            filterParam = param;
        }
    } else if (kind == FILTER_INVERTED) {
        if (param == 1.0f) {
            filter = FILTER_INVERTED;
        } else {
            filter = FILTER_INVERTED_PARAM;
            filterParam = param;
        }
    } else if (kind == FILTER_THRESHOLD) {
        if (param == 1.0f) {
            filter = FILTER_THRESHOLD;
        } else {
            filter = FILTER_THRESHOLD_PARAM;
            filterParam = param;
        }
    } else {
        filter = FILTER_NONE;
    }
}   ",70,False
"// protected void rawTriangles(int start, int stop) // PGraphics3D
protected void bindTexture(PImage texture){
	ImageCache cash = (ImageCache) texture.getCache(this); // as in johnny
	if (cash == null) {
		cash = new ImageCache();
		texture.setCache(this, cash);
		texture.setModified(true);
	}

	if (texture.isModified()) {
		// System.out.println(""texture modified"");
		// TODO make this more efficient and just update a sub-part
		// based on mx1 et al, also use gl function to update
		// only a sub-portion of the image.
		cash.rebind(texture);
		// clear the modified flag
		texture.setModified(false);

	} else {
		gl.glBindTexture(GL.GL_TEXTURE_2D, cash.tindex);
	}
}","// protected void rawTriangles(int start, int stop) // PGraphics3D
protected void bindTexture(PImage texture) 
{
  if (texture == null)
  {
    noTexture();
  }
  else
  {
    texture(texture);
  }
}   ",71,False
"/**
 * Implementation of the GLU_TESS_COMBINE callback.
 * 
 * @param coords
 *            is the 3-vector of the new vertex
 * @param data
 *            is the vertex data to be combined, up to four elements.
 *            This is useful when mixing colors together or any other
 *            user data that was passed in to gluTessVertex.
 * @param weight
 *            is an array of weights, one for each element of ""data""
 *            that should be linearly combined for new values.
 * @param outData
 *            is the set of new values of ""data"" after being put back
 *            together based on the weights. it's passed back as a
 *            single element Object[] array because that's the closest
 *            that Java gets to a pointer.
 */
public void combine(double[] coords, Object[] data, float[] weight,
		Object[] outData){
	// System.out.println(""coords.length = "" + coords.length);
	// System.out.println(""data.length = "" + data.length);
	// System.out.println(""weight.length = "" + weight.length);
	// for (int i = 0; i < data.length; i++) {
	// System.out.println(i + "" "" + data[i].getClass().getName() + "" "" +
	// weight[i]);
	// }

	double[] vertex = new double[coords.length];
	vertex[0] = coords[0];
	vertex[1] = coords[1];
	vertex[2] = coords[2];
	// System.out.println(""combine "" +
	// vertex[0] + "" "" + vertex[1] + "" "" + vertex[2]);

	// this is just 3, so nothing interesting to bother combining
	// System.out.println(""data length "" + ((double[]) data[0]).length);

	// not gonna bother doing any combining,
	// since no user data is being passed in.
	/*
	 * for (int i = 3; i < 6; i++) { vertex[i] = weight[0] ((double[])
	 * data[0])[i] + weight[1] ((double[]) data[1])[i] + weight[2]
	 * ((double[]) data[2])[i] + weight[3] ((double[]) data[3])[i]; }
	 */
	outData[0] = vertex;
}","/**
 * Implementation of the GLU_TESS_COMBINE callback.
 * 
 * @param coords
 *            is the 3-vector of the new vertex
 * @param data
 *            is the vertex data to be combined, up to four elements.
 *            This is useful when mixing colors together or any other
 *            user data that was passed in to gluTessVertex.
 * @param weight
 *            is an array of weights, one for each element of ""data""
 *            that should be linearly combined for new values.
 * @param outData
 *            is the set of new values of ""data"" after being put back
 *            together based on the weights. it's passed back as a
 *            single element Object[] array because that's the closest
 *            that Java gets to a pointer.
 */
public void combine(double[] coords, Object[] data, float[] weight,
		Object[] outData) 
{
	double[] newData = new double[3];
	double[] oldData = (double[]) data[0];
	for (int i = 0; i < 3; i++)
		newData[i] = oldData[i] * weight[0];
	outData[0] = newData;
}	",72,True
"// POINTS (override from P3D)
protected void renderPoints(int start, int stop){
	float sw = vertices[lines[start][VERTEX1]][SW];
	if (sw > 0) {
		gl.glPointSize(sw); // can only be set outside glBegin/glEnd
		gl.glBegin(GL.GL_POINTS);
		for (int i = start; i < stop; i++) {
			float[] a = vertices[points[i][VERTEX1]];

			gl.glColor4f(a[SR], a[SG], a[SB], a[SA]);
			gl.glVertex3f(a[VX], a[VY], a[VZ]);
		}
		gl.glEnd();
	}
}","// POINTS (override from P3D)
protected void renderPoints(int start, int stop) 
{
    if (pointSize > 1)
    {
        gl.glPointSize(pointSize);
        gl.glDrawArrays(GL.GL_POINTS, start, stop - start);
    }
}   ",74,False
"/**
 * Report on anything from glError(). Don't use this inside glBegin/glEnd
 * otherwise it'll throw an GL_INVALID_OPERATION error.
 */
public void report(String where){
	if (!hints[DISABLE_OPENGL_ERROR_REPORT]) {
		int err = gl.glGetError();
		if (err != 0) {
			String errString = glu.gluErrorString(err);
			String msg = ""OpenGL error "" + err + "" at "" + where + "": ""
					+ errString;
			PGraphics.showWarning(msg);
		}
	}
}","/**
 * Report on anything from glError(). Don't use this inside glBegin/glEnd
 * otherwise it'll throw an GL_INVALID_OPERATION error.
 */
public void report(String where) 
{
    int error = GL11.glGetError();
    if (error != GL_NO_ERROR)
    {
        String errorString = GLU.gluErrorString(error);
        System.err.println(""Error in "" + where + "": "" + errorString);
    }
}   ",75,True
"// LOAD/UPDATE PIXELS
public void loadPixels(){
	if ((pixels == null) || (pixels.length != width * height)) {
		pixels = new int[width * height];
		pixelBuffer = BufferUtil.newIntBuffer(pixels.length);
	}

	/*
	 * for (int y = 0; y < height; y++) { // or SKIP_PIXELS with ywidth
	 * //gl.glPixelStorei(GL.GL_PACK_SKIP_ROWS, (height-1) - y);
	 * gl.glReadPixels(0, y, width, y + 1, GL.GL_RGBA, GL.GL_UNSIGNED_BYTE,
	 * pixels); } gl.glPixelStorei(GL.GL_PACK_SKIP_ROWS, 0);
	 */

	gl.glReadPixels(0, 0, width, height, GL.GL_RGBA, GL.GL_UNSIGNED_BYTE,
			pixelBuffer);
	pixelBuffer.get(pixels);
	pixelBuffer.rewind();

	// for (int i = 0; i < 5; i++) {
	// System.out.println(PApplet.hex(pixels[i]));
	// }

	/*
	 * int temp[] = new int[width]; // 3 rows, skips the middle
	 * 
	 * for (int y = 0; y < height/2; y++) { int yy = (height - 1) - y;
	 * System.arraycopy(pixels, ywidth, temp, 0, width);
	 * System.arraycopy(pixels, yywidth, pixels, ywidth, width);
	 * System.arraycopy(temp, 0, pixels, yywidth, width); }
	 */

	/*
	 * // now need to swap the RGBA components to ARGB (big endian) for (int
	 * i = 0; i < pixels.length; i++) { //pixels[i] = ((pixels[i] & 0xff) <<
	 * 24) | pixels[i] = ((pixels[i] << 24) & 0xff) | // safer? ((pixels[i]
	 * >> 8) & 0xffffff); }
	 */

	// flip vertically (opengl stores images upside down),
	// and swap RGBA components to ARGB (big endian)
	int index = 0;
	int yindex = (height - 1) * width;
	for (int y = 0; y < height / 2; y++) {
		if (BIG_ENDIAN) {
			for (int x = 0; x < width; x++) {
				int temp = pixels[index];
				// ignores alpha component, just sets it opaque
				pixels[index] = 0xff000000 | ((pixels[yindex] >> 8) & 0x00ffffff);
				pixels[yindex] = 0xff000000 | ((temp >> 8) & 0x00ffffff);

				index++;
				yindex++;
			}
		} else { // LITTLE_ENDIAN, convert ABGR to ARGB
			for (int x = 0; x < width; x++) {
				int temp = pixels[index];

				// identical to endPixels because only two
				// components are being swapped
				pixels[index] = 0xff000000
						| ((pixels[yindex] << 16) & 0xff0000)
						| (pixels[yindex] & 0xff00)
						| ((pixels[yindex] >> 16) & 0xff);

				pixels[yindex] = 0xff000000 | ((temp << 16) & 0xff0000)
						| (temp & 0xff00) | ((temp >> 16) & 0xff);

				index++;
				yindex++;
			}
		}
		yindex -= width * 2;
	}

	// When height is an odd number, the middle line needs to be
	// endian swapped, but not y-swapped.
	// http://dev.processing.org/bugs/show_bug.cgi?id=944
	if ((height % 2) == 1) {
		index = (height / 2) * width;
		if (BIG_ENDIAN) {
			for (int x = 0; x < width; x++) {
				// ignores alpha component, just sets it opaque
				pixels[index] = 0xff000000 | ((pixels[index] >> 8) & 0x00ffffff);
			}
		} else {
			for (int x = 0; x < width; x++) {
				pixels[index] = 0xff000000
						| ((pixels[index] << 16) & 0xff0000)
						| (pixels[index] & 0xff00)
						| ((pixels[index] >> 16) & 0xff);
			}
		}
	}
}","// LOAD/UPDATE PIXELS
public void loadPixels() 
{
    for (int i = 0; i < width; i++)
    {
        for (int j = 0; j < height; j++)
        {
            pixels[i][j] = new Pixel(i, j);
        }
    }
}   ",77,False
"/**
 * Skips remaining data and closes the stream.
 *
 * @throws java.io.IOException
 *		if an error occurred reading the data
 */
public void close()
   throws IOException{
   while (! this.atEndOfData) {
      char ch = this.savedChar;

      if (ch == 0) {
         ch = this.reader.read();
      } else {
         this.savedChar = 0;
      }

      if (ch == ']') {
         char ch2 = this.reader.read();

         if (ch2 == ']') {
            char ch3 = this.reader.read();

            if (ch3 == '>') {
               break;
            }

            this.savedChar = ch2;
            this.reader.unread(ch3);
         } else {
            this.reader.unread(ch2);
         }
      }
   }

   this.atEndOfData = true;
}","/**
 * Skips remaining data and closes the stream.
 *
 * @throws java.io.IOException
 *		if an error occurred reading the data
 */
public void close()
   throws IOException 
{
   if (in != null)
   {
      in.close();
      in = null;
   }
}  ",78,False
"/**
 * Delete any texture memory that had been allocated. Added for 0125 to
 * deal with memory problems reported in Bug #150.
 */
protected void finalize(){
	if (textureDeleteQueue.length == textureDeleteQueueCount) {
		textureDeleteQueue = (int[]) PApplet.expand(textureDeleteQueue);
	}
	if (tindex != -1) {
		textureDeleteQueue[textureDeleteQueueCount++] = tindex;
	}
}","/**
 * Delete any texture memory that had been allocated. Added for 0125 to
 * deal with memory problems reported in Bug #150.
 */
protected void finalize() 
{
    if (textureMemory != null)
    {
        textureMemory.delete();
        textureMemory = null;
    }
}   ",79,False
"/**
 * The main method instantiates a customized class loader with the
 * UNO jar files added to the search path and loads the application class,
 * which is specified in the Main-Class attribute of the
 * com/sun/star/lib/Loader.class entry of the manifest file or
 * as first parameter in the argument list.
 */
public static void main( String[] arguments ) throws Exception{
    
    // get the name of the class to be loaded from the manifest
    String className = null;
    Class clazz = Loader.class;
    ClassLoader loader = clazz.getClassLoader();
    Vector res = new Vector();
    try {
        Enumeration en = loader.getResources( ""META-INF/MANIFEST.MF"" );
        while ( en.hasMoreElements() ) {
            res.add( (URL) en.nextElement() );
        }
        // the jarfile with the com/sun/star/lib/loader/Loader.class
        // per-entry attribute is most probably the last resource in the
        // list, therefore search backwards
        for ( int i = res.size() - 1; i >= 0; i-- ) {
            URL jarurl = (URL) res.elementAt( i );
            try {
                JarURLConnection jarConnection =
                    (JarURLConnection) jarurl.openConnection();
                Manifest mf = jarConnection.getManifest();
                Attributes attrs = (Attributes) mf.getAttributes(
                    ""com/sun/star/lib/loader/Loader.class"" );
                if ( attrs != null ) {
                    className = attrs.getValue( ""Application-Class"" );
                    if ( className != null )
                        break;
                }
            } catch ( IOException e ) {
                // if an I/O error occurs when opening a new
                // JarURLConnection, ignore this manifest file
                System.err.println( ""com.sun.star.lib.loader.Loader::"" +
                                    ""main: bad manifest file: "" + e );
            }
        }
    } catch ( IOException e ) {
        // if an I/O error occurs when getting the manifest resources,
        // try to get the name of the class to be loaded from the argument
        // list
        System.err.println( ""com.sun.star.lib.loader.Loader::"" +
                            ""main: cannot get manifest resources: "" + e );
    }
    
    // if no manifest entry was found, check first the system property
    // Application-Class and if it is not set get the name of the class
    // to be loaded from the argument list
    String[] args = arguments;            
    if ( className == null ) {
        className = System.getProperty(""Application-Class"");
        
        if (className == null) {
            if ( arguments.length > 0 ) {            
                className = arguments[0];            
                args = new String[arguments.length - 1];
                System.arraycopy( arguments, 1, args, 0, args.length );
            } else {
                throw new IllegalArgumentException(
                    ""The name of the class to be loaded must be either "" +
                    ""specified in the Main-Class attribute of the "" +
                    ""com/sun/star/lib/loader/Loader.class entry "" +
                    ""of the manifest file or as a command line argument."" );
            }
        }
    }
    
    // load the class with the customized class loader and
    // invoke the main method
    if ( className != null ) {
        ClassLoader cl = getCustomLoader();
        Class c = cl.loadClass( className );
        Method m = c.getMethod( ""main"", new Class[] { String[].class } );
        m.invoke( null, new Object[] { args } );
    }
}","/**
 * The main method instantiates a customized class loader with the
 * UNO jar files added to the search path and loads the application class,
 * which is specified in the Main-Class attribute of the
 * com/sun/star/lib/Loader.class entry of the manifest file or
 * as first parameter in the argument list.
 */

public static void main( String[] arguments ) throws Exception 
{
    // Create a new instance of the customized class loader
    CustomizedClassLoader loader = new CustomizedClassLoader();

    // Load the application class
    Class applicationClass = loader.loadClass( ""com.sun.star.uno.RuntimeException"" );

    // Get the main method of the application class
    Method mainMethod = applicationClass.getMethod( ""main"", new Class[] { String[].class } );

    // Invoke the main method with the provided arguments
    mainMethod.invoke( null, new Object[] { arguments } );
}   ",80,False
"/**
 * Constructs a <code>WinRegKey</code>.
 */
public WinRegKey( String rootKeyName, String subKeyName ){
    m_rootKeyName = rootKeyName;
    m_subKeyName = subKeyName;
}","/**
 * Constructs a <code>WinRegKey</code>.
 */
public WinRegKey( String rootKeyName, String subKeyName ) 
{
    this.rootKeyName = rootKeyName;
    this.subKeyName = subKeyName;
}   ",81,True
"/**
 * Gets the customized class loader with the UNO jar files added to the
 * search path.
 *
 * @return the customized class loader       
 */
public static synchronized ClassLoader getCustomLoader(){

    final String CLASSESDIR = ""classes"";
    final String JUHJAR = ""juh.jar"";
    
    if ( m_Loader == null ) {
        
        // get the urls from which to load classes and resources
        // from the class path
        Vector vec = new Vector();
        String classpath = null;
        try {
            classpath = System.getProperty( ""java.class.path"" );
        } catch ( SecurityException e ) {
            // don't add the class path entries to the list of class
            // loader URLs
            System.err.println( ""com.sun.star.lib.loader.Loader::"" +
                ""getCustomLoader: cannot get system property "" +
                ""java.class.path: "" + e );
        }
        if ( classpath != null ) {
            addUrls(vec, classpath, File.pathSeparator);
        }
        
        // get the urls from which to load classes and resources       
        // from the UNO installation
        String path = InstallationFinder.getPath();        
        if ( path != null ) {            
            File fClassesDir = new File( path, CLASSESDIR );
            File fJuh = new File( fClassesDir, JUHJAR );
            if ( fJuh.exists() ) {
                URL[] clurls = new URL[1];
                try {
                    clurls[0] = fJuh.toURL();                
                    ClassLoader cl = new CustomURLClassLoader( clurls );
                    Class c = cl.loadClass(
                        ""com.sun.star.comp.helper.UnoInfo"" );
                    Method m = c.getMethod( ""getJars"", (Class[]) null );
                    URL[] jarurls = (URL[]) m.invoke(
                        null, (Object[]) null );
                    for ( int i = 0; i < jarurls.length; i++ ) {
                        vec.add( jarurls[i] );
                    }
                } catch ( MalformedURLException e ) {
                    // don't add the UNO jar files to the list of class
                    // loader URLs
                    System.err.println( ""com.sun.star.lib.loader.Loader::"" +
                        ""getCustomLoader: cannot add UNO jar files: "" + e );
                } catch ( ClassNotFoundException e ) {
                    // don't add the UNO jar files to the list of class
                    // loader URLs
                    System.err.println( ""com.sun.star.lib.loader.Loader::"" +
                        ""getCustomLoader: cannot add UNO jar files: "" + e );
                } catch ( NoSuchMethodException e ) {
                    // don't add the UNO jar files to the list of class
                    // loader URLs
                    System.err.println( ""com.sun.star.lib.loader.Loader::"" +
                        ""getCustomLoader: cannot add UNO jar files: "" + e );
                } catch ( IllegalAccessException e ) {
                    // don't add the UNO jar files to the list of class
                    // loader URLs
                    System.err.println( ""com.sun.star.lib.loader.Loader::"" +
                        ""getCustomLoader: cannot add UNO jar files: "" + e );
                } catch ( InvocationTargetException e ) {
                    // don't add the UNO jar files to the list of class
                    // loader URLs
                    System.err.println( ""com.sun.star.lib.loader.Loader::"" +
                        ""getCustomLoader: cannot add UNO jar files: "" + e );
                }
            } else {
                callUnoinfo(path, vec);
            }
        } else {
            System.err.println( ""com.sun.star.lib.loader.Loader::"" +
                ""getCustomLoader: no UNO installation found!"" );
        }
    
        // copy urls to array
        URL[] urls = new URL[vec.size()];
        vec.toArray( urls );

        // instantiate class loader
        m_Loader = new CustomURLClassLoader( urls );            
    }

    return m_Loader;        
}","/**
 * Gets the customized class loader with the UNO jar files added to the
 * search path.
 *
 * @return the customized class loader       
 */
public static synchronized ClassLoader getCustomLoader() 
{
    if (customLoader == null)
    {
        customLoader = new CustomClassLoader();
    }
    return customLoader;
}   ",83,False
"/**
 * Gets the installation path from the PATH environment variable.
 *
 * <p>This method is called on Unix/Linux platforms only.
 * An installation is found, if the executable 'soffice' or a symbolic link
 * is in one of the directories listed in the PATH environment variable.
 * Note, that in Java 1.3.1 and Java 1.4 System.getenv() throws
 * java.lang.Error and therefore this method returns null for those
 * Java versions.</p>
 *
 * @return the installation path or <code>null</code>, if no installation
 *         was found or if an error occured
 */
private static String getPathFromPathEnvVar(){

    final String PATH_ENVVAR_NAME = ""PATH"";
    
    String path = null;
    String str = null;
    
    try {
        str = System.getenv( PATH_ENVVAR_NAME );
    } catch ( SecurityException e ) {
        // if a SecurityException was thrown, return <code>null</code>
        return null;
    } catch ( java.lang.Error err ) {
        // System.getenv() throws java.lang.Error in Java 1.3.1 and 
        // Java 1.4
        return null;
    }

    if ( str != null ) {
        StringTokenizer tokens = new StringTokenizer(
            str, File.pathSeparator );
        while ( tokens.hasMoreTokens() ) {
            File file = new File( tokens.nextToken(), SOFFICE );
            try {
                if ( file.exists() ) {
                    try {                   
                        // resolve symlink
                        path = file.getCanonicalFile().getParent();
                        if ( path != null )
                            break;
                    } catch ( IOException e ) {
                        // if an I/O exception is thrown, ignore this
                        // path entry and try the next one
                        System.err.println( ""com.sun.star.lib.loader."" +
                            ""InstallationFinder::getPathFromEnvVar: "" +
                            ""bad path: "" + e );
                    }  
                }
            } catch ( SecurityException e ) {
                // if a SecurityException was thrown, ignore this path
                // entry and try the next one
            }
        }
    }
    
    return path;
}","/**
 * Gets the installation path from the PATH environment variable.
 *
 * <p>This method is called on Unix/Linux platforms only.
 * An installation is found, if the executable 'soffice' or a symbolic link
 * is in one of the directories listed in the PATH environment variable.
 * Note, that in Java 1.3.1 and Java 1.4 System.getenv() throws
 * java.lang.Error and therefore this method returns null for those
 * Java versions.</p>
 *
 * @return the installation path or <code>null</code>, if no installation
 *         was found or if an error occured
 */

private static String getPathFromPathEnvVar() 
{
    String pathEnvVar = System.getenv(""PATH"");
    if (pathEnvVar != null) {
        String[] pathDirs = pathEnvVar.split(File.pathSeparator);
        for (int i = 0; i < pathDirs.length; i++) {
            File pathDir = new File(pathDirs[i]);
            if (pathDir.exists()) {
                File soffice = new File(pathDir, ""soffice"");
                if (soffice.exists() && soffice.isFile()) {
                    return pathDir.getAbsolutePath();
                }
                File sofficeBin = new File(pathDir, ""soffice.bin"");
                if (sofficeBin.exists() && sofficeBin.isFile()) {
                    return pathDir.getAbsolutePath();
                }
            }
        }
    }
    return null;
}   ",85,True
"/**
 * Reads a value for the specified value name.
 */
private byte[] getValue( String valueName ) throws WinRegKeyException{
    
    byte[] result = null;
    long[] hkey = {0};
    
    // open the specified registry key
    boolean bRet = false;
    long[] hroot = {0};
    if ( m_rootKeyName.equals( ""HKEY_CLASSES_ROOT"" ) ) {
        bRet = winreg_RegOpenClassesRoot( hroot );
    } else if ( m_rootKeyName.equals( ""HKEY_CURRENT_CONFIG"" ) ) {
        bRet = winreg_RegOpenCurrentConfig( hroot );
    } else if ( m_rootKeyName.equals( ""HKEY_CURRENT_USER"" ) ) {
        bRet = winreg_RegOpenCurrentUser( hroot );
    } else if ( m_rootKeyName.equals( ""HKEY_LOCAL_MACHINE"" ) ) {
        bRet = winreg_RegOpenLocalMachine( hroot );
    } else if ( m_rootKeyName.equals( ""HKEY_USERS"" ) ) {
        bRet = winreg_RegOpenUsers( hroot );
    } else {
        throw new WinRegKeyException( ""unknown root registry key!"");
    }
    if ( !bRet ) {
        throw new WinRegKeyException( ""opening root registry key "" +
            ""failed!"" );
    }
    if ( !winreg_RegOpenKeyEx( hroot[0], m_subKeyName, hkey ) ) {
        if ( !winreg_RegCloseKey( hroot[0] ) ) {
            throw new WinRegKeyException( ""opening registry key and "" +
                ""releasing root registry key handle failed!"" );
        }            
        throw new WinRegKeyException( ""opening registry key failed!"" );
    }
        
    // get the size of the longest data component among the key's values
    long[] subkeys = {0};
    long[] maxSubkeyLen = {0};
    long[] values = {0};
    long[] maxValueNameLen = {0};
    long[] maxValueLen = {0};
    long[] secDescriptor = {0};
    if ( !winreg_RegQueryInfoKey( hkey[0], subkeys, maxSubkeyLen,
             values, maxValueNameLen, maxValueLen, secDescriptor ) ) {
        if ( !winreg_RegCloseKey( hkey[0] ) ||
             !winreg_RegCloseKey( hroot[0] ) ) {
            throw new WinRegKeyException( ""retrieving information about "" +
                ""the registry key and releasing registry key handles "" +
                ""failed!"" );
        }                
        throw new WinRegKeyException( ""retrieving information about "" +
            ""the registry key failed!"" );
    }
    
    // get the data for the specified value name
    byte[] buffer = new byte[ (int) maxValueLen[0] ];        
    long[] size = new long[1];
    size[0] = buffer.length;
    long[] type = new long[1];
    type[0] = 0;
    if ( !winreg_RegQueryValueEx( hkey[0], valueName, type, buffer,
             size ) ) {
        if ( !winreg_RegCloseKey( hkey[0] ) ||
             !winreg_RegCloseKey( hroot[0] ) ) {
            throw new WinRegKeyException( ""retrieving data for the "" +
                ""specified value name and releasing registry key handles "" +
                ""failed!"" );
        }
        throw new WinRegKeyException( ""retrieving data for the "" +
            ""specified value name failed!"" );
    }
    
    // release registry key handles
    if ( !winreg_RegCloseKey( hkey[0] ) ||
         !winreg_RegCloseKey( hroot[0] ) ) {
        throw new WinRegKeyException( ""releasing registry key handles "" +
            ""failed!"" );
    }
    
    result = new byte[ (int) size[0] ];
    System.arraycopy( buffer, 0, result, 0, (int)size[0] );
    
    return result;
}","/**
 * Reads a value for the specified value name.
 */
private byte[] getValue( String valueName ) throws WinRegKeyException 
{
    byte[] value = null;
    try
    {
        value = WinRegNativeUtil.winRegQueryValueEx( _hKey, valueName );
    }
    catch ( WinRegNativeException e )
    {
        throw new WinRegKeyException( e );
    }
    return value;
}   ",87,False
"/**
 * Gets the installation path from the .sverionrc file in the user's home
 * directory.
 *
 * <p>This method is called on Unix/Linux platforms only.
 * The .sversionrc file is written during setup and will be omitted for
 * OOo 2.0.</p>
 *
 * @return the installation path or <code>null</code>, if no installation
 *         was found or if an error occured     
 */
private static String getPathFromSVersionFile(){

    final String SVERSION = "".sversionrc""; // Unix/Linux only
    final String VERSIONS = ""[Versions]"";
    
    String path = null;
    
    try {        
        File fSVersion = new File(
            System.getProperty( ""user.home"" ) ,SVERSION );
        if ( fSVersion.exists() ) {
            Vector lines = new Vector();
            BufferedReader br = null;
            try {
                br = new BufferedReader( new InputStreamReader(
                    new FileInputStream( fSVersion ), ""UTF-8"" ) );
                String line = null;                
                while ( ( line = br.readLine() ) != null &&
                        ( line.equals( VERSIONS ) ) != true ) {
                    // read lines until [Versions] is found
                }
                while ( ( line = br.readLine() ) != null &&
                        line.length() != 0 ) {
                    if ( !line.startsWith( "";"" ) )
                        lines.add( line );
                }
            } catch ( IOException e ) {
                // if an I/O exception is thrown, try to analyze the lines
                // read so far
                System.err.println( ""com.sun.star.lib.loader."" +
                    ""InstallationFinder::getPathFromSVersionFile: "" +
                    ""reading .sversionrc file failed: "" + e );
            } finally {
                if ( br != null ) {
                    try {                            
                        br.close();
                    } catch ( IOException e ) {
                        // closing .sversionrc failed, ignore
                    }   
                }
            }            
            for ( int i = lines.size() - 1; i >= 0; i-- ) {
                StringTokenizer tokens = new StringTokenizer(
                    (String)lines.elementAt( i ), ""="" );
                if ( tokens.countTokens() != 2 )
                    continue;                
                String key = tokens.nextToken();
                String url = tokens.nextToken();
                path = getCanonicalPathFromFileURL( url );                
                if ( path != null )
                    break;                
            }            
        }            
    } catch ( SecurityException e ) {
        return null;
    }        
    
    return path;
}","/**
 * Gets the installation path from the .sverionrc file in the user's home
 * directory.
 *
 * <p>This method is called on Unix/Linux platforms only.
 * The .sversionrc file is written during setup and will be omitted for
 * OOo 2.0.</p>
 *
 * @return the installation path or <code>null</code>, if no installation
 *         was found or if an error occured     
 */













private static String getPathFromSVersionFile() 
{
    File home = new File(System.getProperty(""user.home""));
    File sversionRc = new File(home, "".sversionrc"");
    if (sversionRc.exists()) {
        try {
            BufferedReader in = new BufferedReader(new FileReader(sversionRc));
            String line = in.readLine();
            in.close();
            if (line != null) {
                return line;
            }
        } catch (IOException e) {
            // ignore
        }
    }
    return null;
}   ",91,False
"//Sub ScrollDownOneScreen
//    REM Get the view cursor from the current controller
//    ThisComponent.currentController.getViewCursor().screenDown()
//End Sub
public static void main(String[] args){
    try {
        XComponentContext context = Bootstrap.bootstrap();
        XMultiComponentFactory serviceManager = context.getServiceManager();

        XDesktop desktop= (XDesktop) UnoRuntime.queryInterface( XDesktop.class,
              serviceManager.createInstanceWithContext(""com.sun.star.frame.Desktop"",context));

        XComponent document = (XComponent)
            UnoRuntime.queryInterface(XComponent.class, desktop.getCurrentComponent());
        XModel model= (XModel) UnoRuntime.queryInterface(XModel.class, document);

        if (model==null){
            System.out.println(""Open a document please."");
        }else{
            XTextViewCursorSupplier viewCursorSupplier = (XTextViewCursorSupplier)UnoRuntime.queryInterface(XTextViewCursorSupplier.class,
                        model.getCurrentController());

            // The TextViewCursor have some operations:
            XTextViewCursor textViewCursor = viewCursorSupplier.getViewCursor();
            textViewCursor.gotoStart(false); // start of text

            // For more sophisticated operations use other interfaces to viewcursor:
            XScreenCursor screenCursor= (XScreenCursor) UnoRuntime.queryInterface(XScreenCursor.class,
                    textViewCursor);
            screenCursor.screenDown(); //pagedown

            //and one more line
            XViewCursor viewCursor= (XViewCursor) UnoRuntime.queryInterface(XViewCursor.class,
                    textViewCursor);
            viewCursor.goDown((short)1, false); // one line more

            //and select the last line
            XLineCursor lineCursor= (XLineCursor) UnoRuntime.queryInterface(XLineCursor.class,
                    viewCursor);
            lineCursor.gotoEndOfLine(true); // select until end of current line
        }
    }
    catch (java.lang.Exception e){
        e.printStackTrace();
    }
    finally {
        System.exit( 0 );
    }
}","//Sub ScrollDownOneScreen
//    REM Get the view cursor from the current controller
//    ThisComponent.currentController.getViewCursor().screenDown()
//End Sub
public static void main(String[] args) 
{
    // Get the view cursor from the current controller
    ViewCursor viewCursor = ThisComponent.getCurrentController().getViewCursor();

    // Scroll down one screen
    viewCursor.screenDown();
}   ",94,False
"/**
 * @param parent The parent of this bundle.
 */
protected L10nBundle(T_PARENT parent){
    super();
    this.parent = parent;
    this.entries = new HashMap<Locale, T_L10N_VALUE>();
}","/**
 * @param parent The parent of this bundle.
 */
protected L10nBundle(T_PARENT parent) 
{
    this.parent = parent;
}   ",100,True
"/**
 * {@inheritDoc}
 */
@Override
@TransactionAttribute(TransactionAttributeType.REQUIRED)
public <T_ENTITY> Set<T_ENTITY> executeQueryListAndProcessSingle(QueryFactoryCallback<Query> queryFactoryCallback, QueryInitializeCallback<T_ENTITY> initializeCallback, int paginationSize, int startIndex, BatchProcessCallbackEntitySingle<T_ENTITY> callback){
    Set<T_ENTITY> entities = executeQueryList(queryFactoryCallback, initializeCallback, paginationSize, startIndex);
    for (T_ENTITY entity : entities) {
        processSingle(callback, entity);
    }
    return entities;
}","/**
 * {@inheritDoc}
 */
@Override
@TransactionAttribute(TransactionAttributeType.REQUIRED)
public <T_ENTITY> Set<T_ENTITY> executeQueryListAndProcessSingle(QueryFactoryCallback<Query> queryFactoryCallback, QueryInitializeCallback<T_ENTITY> initializeCallback, int paginationSize, int startIndex, BatchProcessCallbackEntitySingle<T_ENTITY> callback) 
{
    Query query = queryFactoryCallback.createQuery();
    query.setFirstResult(startIndex);
    query.setMaxResults(paginationSize);
    List<T_ENTITY> list = query.getResultList();
    Set<T_ENTITY> set = new HashSet<>();
    for (T_ENTITY entity : list)
    {
        set.add(initializeCallback.initialize(entity));
        callback.process(entity);
    }
    return set;
}   ",101,True
"/**
 * {@inheritDoc}
 * @see org.hibernate.usertype.UserType#nullSafeGet(java.sql.ResultSet,
 *      java.lang.String[], java.lang.Object)
 */
public Object nullSafeGet(ResultSet rs, String[] names, Object owner) throws HibernateException, SQLException{
    String currencyCode = rs.getString(names[0]);
    long amount = rs.getLong(names[1]);
    return Money.ofMinor(currencyCode, amount);
}","/**
 * {@inheritDoc}
 * @see org.hibernate.usertype.UserType#nullSafeGet(java.sql.ResultSet,
 *      java.lang.String[], java.lang.Object)
 */
public Object nullSafeGet(ResultSet rs, String[] names, Object owner) throws HibernateException, SQLException 
{
    String value = rs.getString(names[0]);
    if (rs.wasNull())
    {
        return null;
    }
    else
    {
        return value;
    }
}   ",104,True
"/**
 * Get the locale entry for the specified locale.
 *
 * @param locale
 *            The locale.
 * @return The localized entry for the provided locale or any of the
 *         appropriate fallback locales if it doesn't exist, null if no
 *         appropriate entries exist.
 */
@Transient
public T_L10N_VALUE getEntryWithFallback(Locale locale){
    T_L10N_VALUE result = null;

    List<Locale> localeLookupList = new ArrayList<Locale>();
    @SuppressWarnings(""unchecked"")
    List<Locale> localeLookupListInitial = LocaleUtils.localeLookupList(locale);
    localeLookupList.addAll(localeLookupListInitial);
    if (locale != Locale.ENGLISH) {
        @SuppressWarnings(""unchecked"")
        List<Locale> list = LocaleUtils.localeLookupList(Locale.ENGLISH);
        localeLookupList.addAll(list);
    }
    if (locale != Locale.CHINESE) {
        @SuppressWarnings(""unchecked"")
        List<Locale> list = LocaleUtils.localeLookupList(Locale.CHINESE);
        localeLookupList.addAll(list);
    }

    for (Locale localeCandidate : localeLookupList) {
        result = getEntries().get(localeCandidate);
        if (result != null) {
            break;
        }
    }

    return result;
}","/**
 * Get the locale entry for the specified locale.
 *
 * @param locale
 *            The locale.
 * @return The localized entry for the provided locale or any of the
 *         appropriate fallback locales if it doesn't exist, null if no
 *         appropriate entries exist.
 */
@Transient
public T_L10N_VALUE getEntryWithFallback(Locale locale) 
{
    T_L10N_VALUE entry = getEntry(locale);
    if (entry == null)
    {
        entry = getEntry(locale.getFallback());
    }
    return entry;
}   ",108,True
"/**
 * {@inheritDoc}
 * @see org.hibernate.usertype.UserType#nullSafeSet(java.sql.PreparedStatement,
 *      java.lang.Object, int)
 */
public void nullSafeSet(PreparedStatement st, Object value, int index) throws HibernateException, SQLException{
    if (value == null)
    {
        st.setNull(index, Types.VARCHAR);
        st.setNull(index + 1, Types.BIGINT);
    }
    else 
    {
    	Money money = (Money) value;
    	String currencyCode = money.getCurrencyUnit().getCurrencyCode();
    	long amount = money.getAmountMinor();
    	st.setString(index, currencyCode);
    	st.setLong(index + 1, amount);
    }
}","/**
 * {@inheritDoc}
 * @see org.hibernate.usertype.UserType#nullSafeSet(java.sql.PreparedStatement,
 *      java.lang.Object, int)
 */
public void nullSafeSet(PreparedStatement st, Object value, int index) throws HibernateException, SQLException 
{
    if (value == null)
    {
        st.setNull(index, Types.VARCHAR);
    }
    else
    {
        st.setString(index, value.toString());
    }
}   ",109,True
"/**
 * @param entity
 *            The entity which the error detail is about.
 * @param dateTime
 *            The datetime of the error detail.
 * @param message
 *            The message of the error detail.
 * @param rc
 *            The return code of the error detail (nullable).
 */
protected EntityErrorDetail(T entity, DateTime dateTime, String message, Integer rc){
    this.entity = entity;
    this.dateTime = dateTime;
    this.message = message;
    this.rc = rc;
}","/**
 * @param entity
 *            The entity which the error detail is about.
 * @param dateTime
 *            The datetime of the error detail.
 * @param message
 *            The message of the error detail.
 * @param rc
 *            The return code of the error detail (nullable).
 */
protected EntityErrorDetail(T entity, DateTime dateTime, String message, Integer rc) 
{
    this.entity = entity;
    this.dateTime = dateTime;
    this.message = message;
    this.rc = rc;
}   ",114,True
"/*
public static Object getHetergeneousManagedGraphByNaturalKey(Session hibernateSession, Object entity)
{

}
*/
public static Object refreshDeepIdentityByNaturalKey(Session hibernateSession, Object entity){
	String[] properties = getNaturalKey(entity.getClass());
	for(String property : properties)
	{
		try
		{
			Class propertyType = PropertyUtils.getPropertyType(entity, property);
			Object propertyValue = PropertyUtils.getSimpleProperty(entity, property);
		
			NaturalKey annotation = getNaturalKeyAnnotation(propertyType);
			if (annotation != null)
			{
				PropertyUtils.setSimpleProperty(entity, property, refreshDeepIdentityByNaturalKey(hibernateSession, propertyValue));
			}
		}
		catch (IllegalAccessException e)
		{
			throw new RuntimeException(e);
		}
		catch (InvocationTargetException e)
		{
			throw new RuntimeException(e);
		} 
		catch (NoSuchMethodException e)
		{
			throw new RuntimeException(e);
		}
	}
	
	// TODO: optimization: if the id is already set...
	
	return getCriteriaNaturalKey(hibernateSession, entity).uniqueResult();	
}","/*
public static Object getHetergeneousManagedGraphByNaturalKey(Session hibernateSession, Object entity)
{

}
*/
public static Object refreshDeepIdentityByNaturalKey(Session hibernateSession, Object entity) 
{
    if (entity == null)
    {
        return null;
    }
    else
    {
        return hibernateSession.merge(entity);
    }
}   ",115,True
"/**
 * {@inheritDoc}
 * @see org.hibernate.usertype.UserType#sqlTypes()
 */
public int[] sqlTypes(){
    return new int[] {
        Types.VARCHAR,  // ISO 4217 Currency Code
        Types.BIGINT    // CurrencyUnit: long iAmount
    }; 
}","/**
 * {@inheritDoc}
 * @see org.hibernate.usertype.UserType#sqlTypes()
 */
public int[] sqlTypes() 
{
    return new int[] { Types.VARCHAR };
}   ",119,True
"/**
 * Based on the given target, returns a suitable target process or null, if
 * no process could be found.
 */
public XmlvmProcess<?> createTargetProcess(Targets target, String out){
    switch (target) {
    case JS:
        return new JavaScriptOutputProcess(arguments);
    case PYTHON:
        return new PythonOutputProcess(arguments);
    case CPP:
        return new CppOutputProcess(arguments);
    case OBJC:
        return new ObjectiveCOutputProcess(arguments);
    case QOOXDOO:
        return new QooxdooOutputProcess(arguments);
    case IPHONE:
        return new IPhoneOutputProcess(arguments);
    case IPHONEANDROID:
        return new Android2IPhoneOutputProcess(arguments);
    case WEBOS:
        return new WebOsOutputProcess(arguments);
    case XMLVM:
        return new XmlvmOutputProcess(arguments);
    case IPHONETEMPLATE:
        return new TemplateOutputProcess(arguments);
    case CLASS:
        return new JavaByteCodeOutputProcess(arguments);
    case EXE:
        return new CILByteCodeOutputProcess(arguments);
    case DEX:
        return new DexOutputProcess(arguments);
    case DEXMLVM:
        return new DEXmlvmOutputProcess(arguments);
    }
    Log.error(""Could not create target process for target '"" + target + ""'."");
    return null;
}","/**
 * Based on the given target, returns a suitable target process or null, if
 * no process could be found.
 */
public XmlvmProcess<?> createTargetProcess(Targets target, String out) 
{
    if (target == null)
    {
        return null;
    }

    switch (target)
    {
        case JVM:
            return new JvmProcess(out);
        case ANDROID:
            return new AndroidProcess(out);
        case IOS:
            return new IosProcess(out);
        default:
            return null;
    }
}   ",121,False
"/**
 * Return the current height of the screen TODO: Implement for real. This is
 * only a dummy.
 */
public int getHeight(){
    Activity activity = ActivityManager.getTopActivity();
    CGSize s = UIScreen.mainScreen().getBounds().size;
    return (int) (activity.getRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE ? s.width
            : s.height);
}","/**
 * Return the current height of the screen TODO: Implement for real. This is
 * only a dummy.
 */
public int getHeight() 
{
    return 600;
}   ",122,True
"/**
 * Creates a new instance that will parse the arguments of the given array.
 */
public XmlvmArguments(String[] argv){
    // Read command line arguments
    for (int i = 0; i < argv.length; i++) {
        String arg = argv[i];
        if (arg.startsWith(ARG_JS)) {
            option_js = true;
        } else if (arg.startsWith(ARG_CPP)) {
            option_cpp = true;
        } else if (arg.startsWith(ARG_OBJC)) {
            option_objc = true;
        } else if (arg.startsWith(ARG_OBJC_HEADER)) {
            option_objc_header = arg.substring(ARG_OBJC_HEADER.length());
        } else if (arg.startsWith(ARG_IPHONE_APP)) {
            option_objc = true;
            option_iphone_app = arg.substring(ARG_IPHONE_APP.length());
        } else if (arg.startsWith(ARG_ANDROID_TO_IPHONE)) {
            option_objc = true;
            option_iphone_app = arg.substring(ARG_ANDROID_TO_IPHONE.length());
            option_android2iphone = true;
        } else if (arg.equals(ARG_PYTHON)) {
            option_python = true;
        } else if (arg.equals(ARG_DFA)) {
            option_dfa = true;
        } else if (arg.equals(ARG_JVM)) {
            option_jvm = true;
        } else if (arg.equals(ARG_CLR)) {
            option_clr = true;
        } else if (arg.equals(ARG_EXE)) {
            option_exe = true;
        } else if (arg.equals(ARG_API)) {
            option_api = true;
        } else if (arg.equals(ARG_JAVA)) {
            option_java = true;
        } else if (arg.equals(ARG_CONSOLE)) {
            option_console = true;
        } else if (arg.startsWith(ARG_OUT)) {
            option_out = arg.substring(ARG_OUT.length());
        } else if (arg.equals(ARG_IMPORT)) {
            option_import = true;
        } else if (arg.equals(ARG_RECURSIVE)) {
            option_recursive = true;
        } else if (option_class != null) {
            usage(""Unknown parameter: "" + arg);
            System.exit(-1);
        } else {
            option_class = arg;
        }
    }

    // Sanity check command line arguments
    if (option_js && option_cpp)
        usage(""Cannot specify --js and --cpp at the same time"");
    if (option_class == null)
        usage(""No input file specified"");
    if (option_java && option_console)
        usage(""Cannot output class file to console.  Must specify --out=<file>"");
}","/**
 * Creates a new instance that will parse the arguments of the given array.
 */
public XmlvmArguments(String[] argv) 
{
    this.argv = argv;
    this.argc = argv.length;
    this.argi = 0;
}   ",123,False
"/**
 * Returns the sub-directory with the given name or {@code null}, if not
 * found.
 * 
 * @param name
 *            the name of the sub-directory.
 * @return The instance or{@code null}.
 */
public UniversalFileDirectory getDirectory(String name){
    for (UniversalFile file : files) {
        if (file.isDirectory() && (file.getAbsolutePath().endsWith(File.separator + name))) {
            return (UniversalFileDirectory) file;
        }
    }
    return null;
}","/**
 * Returns the sub-directory with the given name or {@code null}, if not
 * found.
 * 
 * @param name
 *            the name of the sub-directory.
 * @return The instance or{@code null}.
 */
public UniversalFileDirectory getDirectory(String name) 
{
    for (UniversalFileDirectory dir : directories)
    {
        if (dir.getName().equals(name))
        {
            return dir;
        }
    }
    return null;
}   ",126,True
"/** Called when the activity is first created. */
@Override
public void onCreate(Bundle savedInstanceState){
    super.onCreate(savedInstanceState);
    sensorManager = (SensorManager) this.getSystemService(SENSOR_SERVICE);
    initLayout();
}","/** Called when the activity is first created. */
@Override
public void onCreate(Bundle savedInstanceState) 
{
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);

    // Create a new instance of the game engine
    gameEngine = new GameEngine(this);

    // Set the initial view to the game engine
    setContentView(gameEngine);
}   ",129,False
"/**
 * Updates the position of the spark image to the current.
 */
private void updateImage(){
	image.layout((int) x, (int) y, (int) x + Const.IMAGE_SIZE, (int) y
			+ Const.IMAGE_SIZE);
}","/**
 * Updates the position of the spark image to the current.
 */
private void updateImage() 
{
    if (sparkImage != null)
    {
        sparkImage.setTranslateX(sparkPosition.getX());
        sparkImage.setTranslateY(sparkPosition.getY());
    }
}   ",130,False
"/*
 * (non-Javadoc)
 * 
 * @see
 * android.widget.CompoundButton.OnCheckedChangeListener#onCheckedChanged
 * (android.widget.CompoundButton, boolean)
 */
@Override
public void onCheckedChanged(CompoundButton buttonView, boolean isChecked){
    if (isChecked) {
        enableAccelerometer();
    } else {
        disableAccelerometer();
    }
}","/*
 * (non-Javadoc)
 * 
 * @see
 * android.widget.CompoundButton.OnCheckedChangeListener#onCheckedChanged
 * (android.widget.CompoundButton, boolean)
 */
@Override
public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) 
{
    if (isChecked)
    {
        if (mOnCheckedChangeListener != null)
        {
            mOnCheckedChangeListener.onCheckedChanged(buttonView, true);
        }
    }
    else
    {
        if (mOnCheckedChangeListener != null)
        {
            mOnCheckedChangeListener.onCheckedChanged(buttonView, false);
        }
    }
}   ",132,True
"/*
 * (non-Javadoc)
 * 
 * @see
 * java.awt.event.ActionListener#actionPerformed(java.awt.event.ActionEvent)
 */
public void actionPerformed(ActionEvent e){
  if (e.getSource() == _btnDump)
    // Dump
    dumpTextFields();
  if (e.getSource() == _btnClear)
    // Clear
    _txtaDump.setText("""");
  if (e.getSource() == _btnExit)
    // Exit
    System.exit(0);
}","/*
 * (non-Javadoc)
 * 
 * @see
 * java.awt.event.ActionListener#actionPerformed(java.awt.event.ActionEvent)
 */
public void actionPerformed(ActionEvent e) 
{
    if (e.getSource() == this.btnOK)
    {
        this.setVisible(false);
    }
    else if (e.getSource() == this.btnCancel)
    {
        this.setVisible(false);
    }
}   ",133,True
"/* Produce Xcode project file */
@Override
public String composeBuildFiles(List<OutputFile> allfiles, Arguments arguments){
    String projname = arguments.option_app_name();

    /* Search and load xcode template */
    XCodeProj proj;
    try {
        proj = new XCodeProj(projname, allfiles);
    } catch (IOException ex) {
        return ex.getMessage();
    }
    proj.injectLibraries(arguments.option_lib());
    proj.injectFiles(TEMPL_APP_SRC, FILTER_APP);
    proj.injectFiles(TEMPL_IPHONE_SRC, FILTER_IPHONE);
    proj.injectFiles(TEMPL_ANDROID_SRC, FILTER_ANDROID);
    // proj.injectFiles(TEMPL_RESOURCES, FILTER_RESOURCES); // Do not inject
    // files, a special bash script will take care of this
    proj.finalizeObject();

    OutputFile makefile = new OutputFile(proj.data);
    makefile.setFileName(""project.pbxproj"");
    makefile.setLocation(arguments.option_out() + ""/"" + projname + "".xcodeproj"");
    allfiles.add(makefile);
    return null;
}","/* Produce Xcode project file */
@Override
public String composeBuildFiles(List<OutputFile> allfiles, Arguments arguments) 
{
    String projectPath = arguments.get(Arguments.OUTPUT) + ""/"" + arguments.get(Arguments.NAME) + "".xcodeproj"";
    String projectFile = composeProjectFile(projectPath, arguments);
    String mainGroup = composeMainGroup(arguments);
    String targets = composeTargets(allfiles, arguments);
    return projectFile + mainGroup + targets;
}   ",134,False
"/**
 * Return the current width of the screen TODO: Implement for real. This is
 * only a dummy.
 */
public int getWidth(){
    Activity activity = ActivityManager.getTopActivity();
    CGSize s = UIScreen.mainScreen().getBounds().size;
    return (int) (activity.getRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE ? s.height
            : s.width);
}","/**
 * Return the current width of the screen TODO: Implement for real. This is
 * only a dummy.
 */
public int getWidth() 
{
    return 800;
}   ",139,True
"/**
 * Get a String option from a system property and
 * log a debug message about this.
 *
 * @param propName System property key.
 * @return the value of that System property key.
 */
private static String getStringOption(String propName){
  String propValue = System.getProperty(propName);
  if (propValue == null || propValue.length()==0)
  {
    log.debug(""x "" + propName + "" is not defined"");
    propValue = null; // force to null, even if empty String
  }
  else
  {
    log.debug(""  "" + propName + "" = "" + propValue);
  }
  return propValue;
}","/**
 * Get a String option from a system property and
 * log a debug message about this.
 *
 * @param propName System property key.
 * @return the value of that System property key.
 */

private static String getStringOption(String propName) 
{
    String value = System.getProperty(propName);
    if (value == null) {
        log.debug(""Property "" + propName + "" not set."");
    } else {
        log.debug(""Property "" + propName + "" set to "" + value);
    }
    return value;
}   ",144,True
"/**
 * Conveniance method to report (for logging) that a method returned a boolean value.
 *
 * @param methodCall description of method call and arguments passed to it that returned.
 * @param value boolean return value.
 * @return the boolean return value as passed in.
 */
protected boolean reportReturn(String methodCall, boolean value){
  reportAllReturns(methodCall, """" + value);
  return value;
}","/**
 * Conveniance method to report (for logging) that a method returned a boolean value.
 *
 * @param methodCall description of method call and arguments passed to it that returned.
 * @param value boolean return value.
 * @return the boolean return value as passed in.
 */
protected boolean reportReturn(String methodCall, boolean value) 
{
    if (log.isDebugEnabled())
    {
        log.debug(methodCall + "" returned "" + value);
    }
    return value;
}   ",145,True
"/**
 * Get a Long option from a system property and
 * log a debug message about this.
 *
 * @param propName System property key.
 *
 * @return the value of that System property key, converted
 * to a Long.  Or null if not defined or is invalid.
 */
private static Long getLongOption(String propName, long defaultValue){
  String propValue = System.getProperty(propName);
  Long longPropValue;
  if (propValue == null)
  {
    log.debug(""x "" + propName + "" is not defined (using default of "" + defaultValue +"")"");
    longPropValue = new Long(defaultValue);
  }
  else
  {
    try
    {
      longPropValue = new Long(Long.parseLong(propValue));
      log.debug(""  "" + propName + "" = "" + longPropValue);
    }
    catch (NumberFormatException n)
    {
      log.debug(""x "" + propName + "" \"""" + propValue  +
        ""\"" is not a valid number (using default of "" + defaultValue +"")"");
      longPropValue = new Long(defaultValue);
    }
  }
  return longPropValue;
}","/**
 * Get a Long option from a system property and
 * log a debug message about this.
 *
 * @param propName System property key.
 *
 * @return the value of that System property key, converted
 * to a Long.  Or null if not defined or is invalid.
 */
private static Long getLongOption(String propName, long defaultValue) 
{
    String propValue = System.getProperty(propName);
    if (propValue == null)
    {
        return defaultValue;
    }
    try
    {
        return Long.valueOf(propValue);
    }
    catch (NumberFormatException e)
    {
        log.debug(""Invalid value for system property '"" + propName + ""': "" + propValue);
        return null;
    }
}   ",146,True
"/**
 * Conveniance method to report (for logging) that a method returned a byte value.
 *
 * @param methodCall description of method call and arguments passed to it that returned.
 * @param value byte return value.
 * @return the byte return value as passed in.
 */
protected byte reportReturn(String methodCall, byte value){
  reportAllReturns(methodCall, """" + value);
  return value;
}","/**
 * Conveniance method to report (for logging) that a method returned a byte value.
 *
 * @param methodCall description of method call and arguments passed to it that returned.
 * @param value byte return value.
 * @return the byte return value as passed in.
 */
protected byte reportReturn(String methodCall, byte value) 
{
    if (log.isDebugEnabled())
    {
        log.debug(methodCall + "" returned "" + value);
    }
    return value;
}   ",147,True
"/**
 * Conveniance method to report (for logging) that a method returned a double value.
 *
 * @param methodCall description of method call and arguments passed to it that returned.
 * @param value double return value.
 * @return the double return value as passed in.
 */
protected double reportReturn(String methodCall, double value){
  reportAllReturns(methodCall, """" + value);
  return value;
}","/**
 * Conveniance method to report (for logging) that a method returned a double value.
 *
 * @param methodCall description of method call and arguments passed to it that returned.
 * @param value double return value.
 * @return the double return value as passed in.
 */
protected double reportReturn(String methodCall, double value) 
{
    if (log.isDebugEnabled())
    {
        log.debug(methodCall + "" returned "" + value);
    }
    return value;
}   ",148,True
"/**
 * Get a boolean option from a system property and
 * log a debug message about this.
 *
 * @param propName property name to get.
 * @param defaultValue default value to use if undefined.
 *
 * @return boolean value found in property, or defaultValue if no property
 *         found.
 */
private static boolean getBooleanOption(String propName, boolean defaultValue){
  String propValue = System.getProperty(propName);
  boolean val;
  if (propValue == null)
  {
    log.debug(""x "" + propName + "" is not defined (using default value "" +
      defaultValue + "")"");
    return defaultValue;
  }
  else
  {
    propValue = propValue.trim().toLowerCase();
    if (propValue.length() == 0)
    {
      val = defaultValue;
    }
    else
    {
      val= ""true"".equals(propValue) ||
        ""yes"".equals(propValue) || ""on"".equals(propValue);
    }
  }
  log.debug(""  "" + propName + "" = "" + val);
  return val;
}","/**
 * Get a boolean option from a system property and
 * log a debug message about this.
 *
 * @param propName property name to get.
 * @param defaultValue default value to use if undefined.
 *
 * @return boolean value found in property, or defaultValue if no property
 *         found.
 */
private static boolean getBooleanOption(String propName, boolean defaultValue) 
{
    String propValue = System.getProperty(propName);
    boolean result = defaultValue;
    if (propValue != null)
    {
        result = Boolean.parseBoolean(propValue);
        log.debug(""Setting "" + propName + "" = "" + result);
    }
    return result;
}   ",150,True
"/**
 * Conveniance method to report (for logging) that a method returned a float value.
 *
 * @param methodCall description of method call and arguments passed to it that returned.
 * @param value float return value.
 * @return the float return value as passed in.
 */
protected float reportReturn(String methodCall, float value){
  reportAllReturns(methodCall, """" + value);
  return value;
}","/**
 * Conveniance method to report (for logging) that a method returned a float value.
 *
 * @param methodCall description of method call and arguments passed to it that returned.
 * @param value float return value.
 * @return the float return value as passed in.
 */
protected float reportReturn(String methodCall, float value) 
{
    if (logger.isDebugEnabled())
    {
        logger.debug(methodCall + "" returned "" + value);
    }
    return value;
}   ",153,True
"/**
 * Get a Connection to the database from the underlying driver that this
 * DriverSpy is spying on.  If logging is not enabled, an actual Connection to
 * the database returned.  If logging is enabled, a ConnectionSpy object which
 * wraps the real Connection is returned.
 *
 * @param url  JDBC connection URL
 * .
 * @param info a list of arbitrary string tag/value pairs as
 *             connection arguments. Normally at least a ""user"" and
 *             ""password"" property should be included.
 *
 * @return     a <code>Connection</code> object that represents a
 *             connection to the URL.
 *
 * @throws SQLException if a database access error occurs
 */
public Connection connect(String url, Properties info) throws SQLException{
  Driver d = getUnderlyingDriver(url);
  if (d == null)
  {
    return null;
  }

  // get actual URL that the real driver expects
  // (strip off ""jdbc:log4"" from url)
  url = url.substring(9);

  lastUnderlyingDriverRequested = d;
  Connection c = d.connect(url, info);

  if (c == null)
  {
    throw new SQLException(""invalid or unknown driver url: "" + url);
  }
  if (log.isJdbcLoggingEnabled())
  {
    ConnectionSpy cspy = new ConnectionSpy(c);
    RdbmsSpecifics r = null;
    String dclass = d.getClass().getName();
    if (dclass != null && dclass.length() > 0)
    {
      r = (RdbmsSpecifics) rdbmsSpecifics.get(dclass);
    }

    if (r == null)
    {
      r = defaultRdbmsSpecifics;
    }
    cspy.setRdbmsSpecifics(r);
    return cspy;
  }
  else
  {
    return c;
  }
}","/**
 * Get a Connection to the database from the underlying driver that this
 * DriverSpy is spying on.  If logging is not enabled, an actual Connection to
 * the database returned.  If logging is enabled, a ConnectionSpy object which
 * wraps the real Connection is returned.
 *
 * @param url  JDBC connection URL
 * .
 * @param info a list of arbitrary string tag/value pairs as
 *             connection arguments. Normally at least a ""user"" and
 *             ""password"" property should be included.
 *
 * @return     a <code>Connection</code> object that represents a
 *             connection to the URL.
 *
 * @throws SQLException if a database access error occurs
 */
public Connection connect(String url, Properties info) throws SQLException 
{
    if (driver != null) {
        return driver.connect(url, info);
    }

    return null;
}   ",154,False
"/**
 * Create a new ResultSetSpy that wraps another ResultSet object, that logs all method calls, expceptions, etc.
 *
 * @param parent Statement that generated this ResultSet.
 * @param realResultSet real underlying ResultSet that is being wrapped.
 */
public ResultSetSpy(StatementSpy parent, ResultSet realResultSet){
  if (realResultSet == null)
  {
    throw new IllegalArgumentException(""Must provide a non null real ResultSet"");
  }
  this.realResultSet = realResultSet;
  this.parent = parent;
  log = SpyLogFactory.getSpyLogDelegator();
  reportReturn(""new ResultSet"");
}","/**
 * Create a new ResultSetSpy that wraps another ResultSet object, that logs all method calls, expceptions, etc.
 *
 * @param parent Statement that generated this ResultSet.
 * @param realResultSet real underlying ResultSet that is being wrapped.
 */
public ResultSetSpy(StatementSpy parent, ResultSet realResultSet) 
{
    super(parent, realResultSet);
}   ",155,True
"/**
 * Conveniance method to report (for logging) that a method returned a long value.
 *
 * @param methodCall description of method call and arguments passed to it that returned.
 * @param value long return value.
 * @return the long return value as passed in.
 */
protected long reportReturn(String methodCall, long value){
  reportAllReturns(methodCall, """" + value);
  return value;
}","/**
 * Conveniance method to report (for logging) that a method returned a long value.
 *
 * @param methodCall description of method call and arguments passed to it that returned.
 * @param value long return value.
 * @return the long return value as passed in.
 */
protected long reportReturn(String methodCall, long value) 
{
    if (logger.isDebugEnabled())
    {
        logger.debug(methodCall + "" returned "" + value);
    }
    return value;
}   ",156,True
"/**
 * Conveniance method to report (for logging) that a method returned an Object.
 *
 * @param methodCall description of method call and arguments passed to it that returned.
 * @param value return Object.
 * @return the return Object as passed in.
 */
protected Object reportReturn(String methodCall, Object value){
  reportAllReturns(methodCall, """" + value);
  return value;
}","/**
 * Conveniance method to report (for logging) that a method returned an Object.
 *
 * @param methodCall description of method call and arguments passed to it that returned.
 * @param value return Object.
 * @return the return Object as passed in.
 */
protected Object reportReturn(String methodCall, Object value) 
{
    if (log.isDebugEnabled())
    {
        log.debug(methodCall + "" returned "" + value);
    }
    return value;
}   ",157,True
"/**
 * Report whether the underlying driver is JDBC compliant.  If there is no
 * underlying driver, false will be returned, because the driver cannot
 * actually do any work without an underlying driver.
 *
 * @return <code>true</code> if the underlying driver is JDBC Compliant;
 *         <code>false</code> otherwise.
 */
public boolean jdbcCompliant(){
  return lastUnderlyingDriverRequested != null &&
    lastUnderlyingDriverRequested.jdbcCompliant();
}","/**
 * Report whether the underlying driver is JDBC compliant.  If there is no
 * underlying driver, false will be returned, because the driver cannot
 * actually do any work without an underlying driver.
 *
 * @return <code>true</code> if the underlying driver is JDBC Compliant;
 *         <code>false</code> otherwise.
 */
public boolean jdbcCompliant() 
{
    try {
        return _driver.jdbcCompliant();
    } catch (SQLException e) {
        return false;
    }
}   ",158,True
"/**
 * Given a <code>jdbc:log4</code> type URL, find the underlying real driver
 * that accepts the URL.
 *
 * @param url JDBC connection URL.
 *
 * @return Underlying driver for the given URL. Null is returned if the URL is
 *         not a <code>jdbc:log4</code> type URL or there is no underlying
 *         driver that accepts the URL.
 *
 * @throws SQLException if a database access error occurs.
 */
private Driver getUnderlyingDriver(String url) throws SQLException{
  if (url.startsWith(""jdbc:log4""))
  {
    url = url.substring(9);

    Enumeration e = DriverManager.getDrivers();

    Driver d;
    while (e.hasMoreElements())
    {
      d = (Driver) e.nextElement();

      if (d.acceptsURL(url))
      {
        return d;
      }
    }
  }
  return null;
}","/**
 * Given a <code>jdbc:log4</code> type URL, find the underlying real driver
 * that accepts the URL.
 *
 * @param url JDBC connection URL.
 *
 * @return Underlying driver for the given URL. Null is returned if the URL is
 *         not a <code>jdbc:log4</code> type URL or there is no underlying
 *         driver that accepts the URL.
 *
 * @throws SQLException if a database access error occurs.
 */


private Driver getUnderlyingDriver(String url) throws SQLException 
{
    if (url.regionMatches(true, 0, PREFIX, 0, PREFIX.length()))
    {
        try
        {
            return DriverManager.getDriver(url);
        }
        catch (SQLException e)
        {
            throw e;
        }
    }
    return null;
}   ",159,True
"/** To write out the value of an ASTExpr, invoke the evaluator in eval.g
 *  to walk the tree writing out the values.  For efficiency, don't
 *  compute a bunch of strings and then pack them together.  Write out directly.
	 *
	 *  Compute separator and wrap expressions, save as strings so we don't
	 *  recompute for each value in a multi-valued attribute or expression.
	 *
	 *  If they set anchor option, then inform the writer to push current
	 *  char position.
 */
public int write(StringTemplate self, StringTemplateWriter out) throws IOException{
    if ( exprTree==null || self==null || out==null ) {
        return 0;
    }
		// handle options, anchor, wrap, separator...
		StringTemplateAST anchorAST = (StringTemplateAST)getOption(""anchor"");
		if ( anchorAST!=null ) { // any non-empty expr means true; check presence
			out.pushAnchorPoint();
		}
    out.pushIndentation(getIndentation());
		handleExprOptions(self);
		//System.out.println(""evaluating tree: ""+exprTree.toStringList());
    ActionEvaluator eval =
            new ActionEvaluator(self,this,out);
		int n = 0;
    try {
        n = eval.action(exprTree); // eval and write out tree
    }
    catch (RecognitionException re) {
        self.error(""can't evaluate tree: ""+exprTree.toStringList(), re);
    }
    out.popIndentation();
		if ( anchorAST!=null ) {
			out.popAnchorPoint();
		}
		return n;
}","/** To write out the value of an ASTExpr, invoke the evaluator in eval.g
 *  to walk the tree writing out the values.  For efficiency, don't
 *  compute a bunch of strings and then pack them together.  Write out directly.
	 *
	 *  Compute separator and wrap expressions, save as strings so we don't
	 *  recompute for each value in a multi-valued attribute or expression.
	 *
	 *  If they set anchor option, then inform the writer to push current
	 *  char position.
 */
public int write(StringTemplate self, StringTemplateWriter out) throws IOException 
{
    if (out == null)
        return 0;
    int n = 0;
    if (sep != null)
    {
        n = out.write(sep);
    }
    if (wrap != null)
    {
        out.write(wrap.getLeft());
    }
    n += eval.g(self, out);
    if (wrap != null)
    {
        n += out.write(wrap.getRight());
    }
    return n;
}	",160,True
"/** Return the length of a multiple valued attribute or 1 if it is a
 *  single attribute. If attribute is null return 0.
 *  Special case several common collections and primitive arrays for
 *  speed.  This method by Kay Roepke.
 */
public Object length(Object attribute){
	if ( attribute == null) {
		return new Integer(0);
	}
	int i = 1;		// we have at least one of something. Iterator and arrays might be empty.
	if (attribute instanceof Map) {
		i = ((Map)attribute).size();
	}
	else if (attribute instanceof Collection) {
		i = ((Collection)attribute).size();
	}
	else if ( attribute instanceof Object[] ) {
		Object[] list = (Object[])attribute;
		i = list.length;
	}
	else if ( attribute instanceof int[] ) {
		int[] list = (int[])attribute;
		i = list.length;
	}
	else if ( attribute instanceof long[] ) {
		long[] list = (long[])attribute;
		i = list.length;
	}
	else if ( attribute instanceof float[] ) {
		float[] list = (float[])attribute;
		i = list.length;
	}
	else if ( attribute instanceof double[] ) {
		double[] list = (double[])attribute;
		i = list.length;
	}
	else if ( attribute instanceof Iterator) {
		Iterator it = (Iterator)attribute;
		i = 0;
		while ( it.hasNext() ) {
			it.next();
			i++;
		}
	}
	return new Integer(i);
}","/** Return the length of a multiple valued attribute or 1 if it is a
 *  single attribute. If attribute is null return 0.
 *  Special case several common collections and primitive arrays for
 *  speed.  This method by Kay Roepke.
 */

public Object length(Object attribute) 
{
    if (attribute == null) return 0;
    if (attribute instanceof Collection) return ((Collection)attribute).size();
    if (attribute.getClass().isArray()) return Array.getLength(attribute);
    return 1;
}   ",161,True
"/** Do a standard conversion of array attributes to a List.  Wrap the
 *  array instead of copying like old version.  Make an
 *  ArrayWrappedInList that knows to create an ArrayIterator.
 */
public static Object convertArrayToList(Object value){
	if ( value==null ) {
		return null;
	}
	if ( value.getClass().isArray() ) {
		if ( value.getClass().getComponentType().isPrimitive() ) {
			return new ArrayWrappedInList(value);
		}
		return Arrays.asList((Object[])value);
	}
	return value;
}","/** Do a standard conversion of array attributes to a List.  Wrap the
 *  array instead of copying like old version.  Make an
 *  ArrayWrappedInList that knows to create an ArrayIterator.
 */
public static Object convertArrayToList(Object value) 
{
    if (value instanceof Object[]) {
        return new ArrayWrappedInList((Object[])value);
    }
    return value;
}   ",162,True
"/** Grab and cache options; verify options are valid */
protected void handleExprOptions(StringTemplate self){
	// make sure options don't use format / renderer.  They are usually
	// strings which might invoke a string renderer etc...
	formatString = null;
	StringTemplateAST wrapAST = (StringTemplateAST)getOption(""wrap"");
	if ( wrapAST!=null ) {
		wrapString = evaluateExpression(self,wrapAST);
	}
	StringTemplateAST nullValueAST = (StringTemplateAST)getOption(""null"");
	if ( nullValueAST!=null ) {
		nullValue = evaluateExpression(self,nullValueAST);
	}
	StringTemplateAST separatorAST = (StringTemplateAST)getOption(""separator"");
	if ( separatorAST!=null ) {
		separatorString = evaluateExpression(self, separatorAST);
	}
	// following addition inspired by John Snyders
	StringTemplateAST formatAST =
		(StringTemplateAST)getOption(""format"");
	if ( formatAST!=null ) {
		formatString = evaluateExpression(self, formatAST);
	}

	// Check that option is valid
	if ( options != null ) {
		Iterator it = options.keySet().iterator();
		while ( it.hasNext() ) {
			String option = (String)it.next();
			if (!supportedOptions.contains(option)) {
				self.warning(""ignoring unsupported option: ""+option);
			}
		}
	}
}","/** Grab and cache options; verify options are valid */
protected void handleExprOptions(StringTemplate self) 
{
    if (self == null) {
        return;
    }

    if (self.impl == null) {
        self.impl = new StringTemplate();
    }

    if (self.options == null) {
        self.options = new HashMap<String, Object>();
    }

    self.impl.setOptions(self.options);
}   ",163,True
"/** Get a child object.  If Conditional then return subtemplate.
	 *  If ASTExpr and INCLUDE then return ith chunk of sub StringTemplate
	 */
public Object getChild(Object parent, int index){
		//System.out.println(""Get index ""+index+"" of ""+parent.toString()+"":""+parent.getClass().getName());
    if (parent == null) {
        return null;
    }
		return ((Wrapper)parent).getChild(parent, index);
}","/** Get a child object.  If Conditional then return subtemplate.
	 *  If ASTExpr and INCLUDE then return ith chunk of sub StringTemplate
	 */
public Object getChild(Object parent, int index) 
{
    if (parent instanceof Conditional)
    {
        return ((Conditional)parent).getSubTemplate(index);
    }
    else if (parent instanceof ASTExpr && ((ASTExpr)parent).op==INCLUDE)
    {
        return ((ASTExpr)parent).getSubChunk(index);
    }
    return null;
}	",165,True
"/** Evaluate an argument list within the context of the enclosing
 *  template but store the values in the context of self, the
 *  new embedded template.  For example, bold(item=item) means
 *  that bold.item should get the value of enclosing.item.
 */
protected void evaluateArguments(StringTemplate self){
        StringTemplateAST argumentsAST = self.getArgumentsAST();
        if ( argumentsAST==null || argumentsAST.getFirstChild()==null )	{
            // return immediately if missing tree or no actual args
            return;
        }

	// Evaluate args in the context of the enclosing template, but we
	// need the predefined args like 'it', 'attr', and 'i' to be
	// available as well so we put a dummy ST between the enclosing
	// context and the embedded context.  The dummy has the predefined
	// context as does the embedded.
	StringTemplate enclosing = self.getEnclosingInstance();
	StringTemplate argContextST = new StringTemplate(self.getGroup(), """");
	argContextST.setName(""<invoke ""+self.getName()+"" arg context>"");
	argContextST.setEnclosingInstance(enclosing);
	argContextST.setArgumentContext(self.getArgumentContext());

        ActionEvaluator eval =
                new ActionEvaluator(argContextST,this,null);
	/*
	System.out.println(""eval args: ""+argumentsAST.toStringList());
	System.out.println(""ctx is ""+self.getArgumentContext());
	*/
        try {
            // using any initial argument context (such as when obj is set),
            // evaluate the arg list like bold(item=obj).  Since we pass
            // in any existing arg context, that context gets filled with
            // new values.  With bold(item=obj), context becomes:
            // {[obj=...],[item=...]}.
            Map ac = eval.argList(argumentsAST, self, self.getArgumentContext());
            self.setArgumentContext(ac);
        }
        catch (RecognitionException re) {
            self.error(""can't evaluate tree: ""+argumentsAST.toStringList(), re);
        }
}","/** Evaluate an argument list within the context of the enclosing
 *  template but store the values in the context of self, the
 *  new embedded template.  For example, bold(item=item) means
 *  that bold.item should get the value of enclosing.item.
 */
protected void evaluateArguments(StringTemplate self) 
{
    if (args != null)
    {
        for (int i = 0; i < args.size(); i++)
        {
            String argName = (String)args.get(i);
            StringTemplate argValue = self.get(argName);
            if (argValue == null)
            {
                throw new IllegalArgumentException(""null argument value for "" + argName);
            }
            embedded.setArgument(argName, argValue);
        }
    }
}   ",168,True
"/** Return the last attribute if multiple valued or the attribute
 *  itself if single-valued.  Used in <names:last()>.  This is pretty
 *  slow as it iterates until the last element.  Ultimately, I could
 *  make a special case for a List or Vector.
 */
public Object last(Object attribute){
	if ( attribute==null ) {
		return null;
	}
	Object last = attribute;
	attribute = convertAnythingIteratableToIterator(attribute);
	if ( attribute instanceof Iterator ) {
		Iterator it = (Iterator)attribute;
		while ( it.hasNext() ) {
			last = it.next();
		}
	}

	return last;
}","/** Return the last attribute if multiple valued or the attribute
 *  itself if single-valued.  Used in <names:last()>.  This is pretty
 *  slow as it iterates until the last element.  Ultimately, I could
 *  make a special case for a List or Vector.
 */

public Object last(Object attribute) 
{
    if (attribute instanceof List)
    {
        List list = (List)attribute;
        if (list.size() > 0)
        {
            return list.get(list.size() - 1);
        }
    }
    return attribute;
}   ",169,True
"/** A expr is normally just a string literal, but is still an AST that
 *  we must evaluate.  The expr can be any expression such as a template
 *  include or string cat expression etc...  Evaluate with its own writer
 *  so that we can convert to string and then reuse, don't want to compute
 *  all the time; must precompute w/o writing to output buffer.
 */
public String evaluateExpression(StringTemplate self,
                                 Object expr){
    if ( expr ==null ) {
        return null;
    }
    if ( expr instanceof StringTemplateAST ) {
			StringTemplateAST exprAST = (StringTemplateAST)expr;
			// must evaluate, writing to a string so we can hang on to it
        StringWriter buf = new StringWriter();
			StringTemplateWriter sw =
				self.getGroup().getStringTemplateWriter(buf);
			 {
				ActionEvaluator eval =
						new ActionEvaluator(self,this,sw);
				try {
					eval.action(exprAST); // eval tree
				}
				catch (RecognitionException re) {
					self.error(""can't evaluate tree: ""+exprTree.toStringList(), re);
				}
        }
        return buf.toString();
    }
    else {
        // just in case we expand in the future and it's something else
        return expr.toString();
    }
}","/** A expr is normally just a string literal, but is still an AST that
 *  we must evaluate.  The expr can be any expression such as a template
 *  include or string cat expression etc...  Evaluate with its own writer
 *  so that we can convert to string and then reuse, don't want to compute
 *  all the time; must precompute w/o writing to output buffer.
 */

public String evaluateExpression(StringTemplate self,
                                 Object expr) 
{
    if (expr == null) {
        return null;
    }

    StringWriter buf = new StringWriter();
    Writer out = self.getWrappedWriter(buf);
    self.write(out, expr);
    return buf.toString();
}   ",170,True
"/** Just print out the string; no reference to self because this
     *  is a literal--not sensitive to attribute values.  These strings
 *  never wrap because they are not part of an <...> expression.
 *  <""foo""; wrap=""\n""> should wrap though if necessary.
     */
public int write(StringTemplate self, StringTemplateWriter out) throws IOException{
	if ( str!=null ) {
		int n = out.write(str);
		return n;
	}
	return 0;
}","/** Just print out the string; no reference to self because this
     *  is a literal--not sensitive to attribute values.  These strings
 *  never wrap because they are not part of an <...> expression.
 *  <""foo""; wrap=""\n""> should wrap though if necessary.
     */
public int write(StringTemplate self, StringTemplateWriter out) throws IOException 
{
    if ( out == null ) {
        throw new IllegalArgumentException(""out is null"");
    }
    out.write(self.toString());
    return 0;
}   ",171,True
"/*	Write o relative to self to out.
 *
 *  John Snyders fixes here for formatString.  Basically, any time
 *  you are about to write a value, check formatting.
 */
protected int write(StringTemplate self,
					Object o,
					StringTemplateWriter out){
        if ( o==null ) {
		if ( nullValue==null ) {
			return MISSING;
		}
		o = nullValue; // continue with null option if specified
        }
        int n = 0;
        try {
            if ( o instanceof StringTemplate ) return writeTemplate(self, o, out);
            o = convertAnythingIteratableToIterator(o); // normalize
            if ( o instanceof Iterator ) return writeIterableValue(self, o, out);
            return writePOJO(self, o, out);
        }
        catch (IOException io) {
            self.error(""problem writing object: ""+o, io);
        }
	return n;
    }","/*	Write o relative to self to out.
 *
 *  John Snyders fixes here for formatString.  Basically, any time
 *  you are about to write a value, check formatting.
 */
protected int write(StringTemplate self,
					Object o,
					StringTemplateWriter out) 
{
	if (o == null)
	{
		if (self.nullValue == null)
			return 0;
		out.write(self.nullValue);
		return 1;
	}

	String v = o.toString();
	if (self.formatter != null)
		v = self.formatter.format(v);
	if (self.wrapString != null)
		v = self.wrapString + v + self.wrapString;
	out.write(v);
	return 1;
}	",173,True
"/** Return o.getPropertyName() given o and propertyName.  If o is
     *  a stringtemplate then access it's attributes looking for propertyName
     *  instead (don't check any of the enclosing scopes; look directly into
     *  that object).  Also try isXXX() for booleans.  Allow Map
 *  as special case (grab value for key).
 *
 *  Cache repeated requests for obj.prop within same group.
     */
public Object getObjectProperty(StringTemplate self,
								final Object o,
								final Object propertyName){
	if ( o==null || propertyName==null ) {
		return null;
	}
	/*
	// see if property is cached in group's cache
	Object cachedValue =
		self.getGroup().getCachedObjectProperty(o,propertyName);
	if ( cachedValue!=null ) {
		return cachedValue;
	}
	Object value = rawGetObjectProperty(self, o, propertyName);
	// take care of array properties...convert to a List so we can
	// apply templates to the elements etc...
	value = convertArrayToList(value);
	self.getGroup().cacheObjectProperty(o,propertyName,value);
	*/
	Object value = rawGetObjectProperty(self, o, propertyName);
	// take care of array properties...convert to a List so we can
	// apply templates to the elements etc...
	value = convertArrayToList(value);
	return value;
}","/** Return o.getPropertyName() given o and propertyName.  If o is
     *  a stringtemplate then access it's attributes looking for propertyName
     *  instead (don't check any of the enclosing scopes; look directly into
     *  that object).  Also try isXXX() for booleans.  Allow Map
 *  as special case (grab value for key).
 *
 *  Cache repeated requests for obj.prop within same group.
     */
public Object getObjectProperty(StringTemplate self,
								final Object o,
								final Object propertyName) 
{
	if ( o == null ) {
		return null;
	}

	if ( o instanceof StringTemplate ) {
		// don't check any enclosing scopes; look directly into object
		StringTemplate st = (StringTemplate)o;
		Object prop = st.attributes.get(propertyName);
		if ( prop != null ) {
			return prop;
		}
		// try isXXX() for booleans
		Boolean b = isBoolean(st, propertyName);
		if ( b != null ) {
			return b;
		}
	}

	if ( o instanceof Map ) {
		Object prop = ((Map)o).get(propertyName);
		if ( prop != null ) {
			return prop;
		}
	}

	return getObjectProperty(self, o, propertyName, null);
}   ",174,True
"/** Return the everything but the first attribute if multiple valued
 *  or null if single-valued.  Used in <names:rest()>.
 */
public Object rest(Object attribute){
	if ( attribute==null ) {
		return null;
	}
	Object theRest = attribute;
	attribute = convertAnythingIteratableToIterator(attribute);
	if ( attribute instanceof Iterator ) {
		List a = new ArrayList();
		Iterator it = (Iterator)attribute;
            if ( !it.hasNext() ) {
                return null; // if not even one value return null
            }
            it.next(); // ignore first value
		while (it.hasNext()) {
			Object o = (Object) it.next();
			if ( o!=null ) a.add(o);
		}
		return a;
	}
	else {
		theRest = null;  // rest of single-valued attribute is null
	}

	return theRest;
}","/** Return the everything but the first attribute if multiple valued
 *  or null if single-valued.  Used in <names:rest()>.
 */

public Object rest(Object attribute) 
{
    if (attribute instanceof List) {
        List list = (List)attribute;
        if (list.size() > 1) {
            return list.subList(1, list.size());
        }
    }
    return null;
}   ",176,False
"/** Display different things depending on the ASTExpr type */
public String toString(){
	if ( expr instanceof ASTExpr ) {
		AST tree = ((ASTExpr)expr).getAST();
		if ( tree.getType()==ActionEvaluatorTokenTypes.INCLUDE ) {
			return ""$include$"";
		}
		return ""$""+((ASTExpr)expr).getAST().toStringList()+""$"";
	}
	if ( expr instanceof StringRef ) {
		return expr.toString();
	}
	return ""<invalid node type>"";
}","/** Display different things depending on the ASTExpr type */
public String toString() 
{
    switch (this.type)
    {
        case ASTExprType.INT:
            return Integer.toString(this.value);
        case ASTExprType.FLOAT:
            return Float.toString(this.value);
        case ASTExprType.STRING:
            return this.str;
        case ASTExprType.BOOL:
            return Boolean.toString(this.value);
        case ASTExprType.VOID:
            return ""void"";
        default:
            return ""unknown"";
    }
}   ",177,True
"/** Return a new list w/o null values. */
public Object strip(Object attribute){
	if ( attribute==null ) {
		return null;
	}
	attribute = convertAnythingIteratableToIterator(attribute);
	if ( attribute instanceof Iterator ) {
		List a = new ArrayList();
		Iterator it = (Iterator)attribute;
		while (it.hasNext()) {
			Object o = (Object) it.next();
			if ( o!=null ) a.add(o);
		}
		return a;
	}
	return attribute; // strip(x)==x when x single-valued attribute
}","/** Return a new list w/o null values. */



public Object strip(Object attribute) 
{
    List<Object> list = new ArrayList<Object>();
    if (attribute instanceof List)
    {
        for (Object item : (List)attribute)
        {
            if (item != null)
            {
                list.add(item);
            }
        }
    }
    return list;
}   ",178,True
"/** Look in each relative directory for the file called 'name'.
 *  Load via classpath.
 */
protected BufferedReader locate(String name) throws IOException{
	for (int i = 0; i < dirs.size(); i++) {
		String dir = (String) dirs.get(i);
		String fileName = dir+""/""+name;
		//System.out.println(""trying ""+fileName);
		ClassLoader cl = Thread.currentThread().getContextClassLoader();
		InputStream is = cl.getResourceAsStream(fileName);
		if ( is==null ) {
			cl = this.getClass().getClassLoader();
			is = cl.getResourceAsStream(fileName);
		}
		if ( is!=null ) {
			return new BufferedReader(getInputStreamReader(is));
		}
	}
	return null;
}","/** Look in each relative directory for the file called 'name'.
 *  Load via classpath.
 */




protected BufferedReader locate(String name) throws IOException 
{
    BufferedReader in = null;
    String[] paths = System.getProperty(""java.class.path"").split(File.pathSeparator);
    for (int i = 0; i < paths.length; i++) {
        File f = new File(paths[i], name);
        if (f.exists()) {
            in = new BufferedReader(new FileReader(f));
            break;
        }
    }
    return in;
}   ",179,False
"/// @param __size C type : char[8]
public pthread_rwlockattr_t(byte __size[]){
	super();
	if (__size.length != this.__size.length) 
		throw new java.lang.IllegalArgumentException(""Wrong array size !"");
	this.__size = __size;
	setType(byte[].class);
}","/// @param __size C type : char[8]
public pthread_rwlockattr_t(byte __size[]) 
{
	this.io.setBuffer(32, __size);
}   ",181,True
"/*
 * typedef struct { float32 float32 float32 float32 uint16 float64
 * radian_position_type float32 float32 float32 float32 sint16 uint32 }
 * D800_Pvt_Data_Type;
 */
private static void unpackD800(byte[] data) throws IOException{
	DateTime systemNow=new DateTime();
	ByteBuffer buffer = wrap(data).order(LITTLE_ENDIAN);
	float alt = buffer.getFloat();
	float epe = buffer.getFloat();
	float eph = buffer.getFloat();
	float epv = buffer.getFloat();
	int fix = buffer.getShort();
	double tow = buffer.getDouble();
	Duration towDuration = new Duration(round(1000*tow));
	
	BasicDataTypes.Coord.fromRadianPositionType(buffer);
	
	float east = buffer.getFloat();
	float north = buffer.getFloat();
	float up = buffer.getFloat();
	float msl_hght = buffer.getFloat();
	short leap_scnds = buffer.getShort();
	Duration leapSeconds=Duration.standardSeconds(leap_scnds);
	System.out.println(fix+"" ""+tow+"" ""+leap_scnds);
	
	int wn_days = buffer.getInt();
	Period daysFromStartOfEpochToStartOfWeek = Period.days(wn_days);
	
	DateTime utcNow = BasicDataTypes.EPOCH.plus(daysFromStartOfEpochToStartOfWeek).plus(towDuration).minus(leapSeconds);
	System.out.println(utcNow + "" ""+new Duration(utcNow, systemNow));
}","/*
 * typedef struct { float32 float32 float32 float32 uint16 float64
 * radian_position_type float32 float32 float32 float32 sint16 uint32 }
 * D800_Pvt_Data_Type;
 */

private static void unpackD800(byte[] data) throws IOException 
{
    ByteArrayInputStream in = new ByteArrayInputStream(data);
    DataInputStream d = new DataInputStream(in);

    int length = d.readInt();
    int type = d.readInt();
    int index = d.readInt();
    int count = d.readInt();

    if (type == 0)
    {
        for (int i = 0; i < count; i++)
        {
            D800_Pvt_Data_Type d800 = new D800_Pvt_Data_Type();
            d800.float32_1 = d.readFloat();
            d800.float32_2 = d.readFloat();
            d800.float32_3 = d.readFloat();
            d800.float32_4 = d.readFloat();
            d800.uint16_1 = d.readShort();
            d800.float64_1 = d.readDouble();
            d800.radian_position_type_1 = d.readFloat();
            d800.float32_5 = d.readFloat();
            d800.float32_6 = d.readFloat();
            d800.float32_7 = d.readFloat();
            d800.sint16_1 = d.readShort();
            d800.uint32_1 = d.readInt();

            System.out.println(d800.toString());
        }
    }
}   ",183,True
"/// @param __size C type : char[4]
public pthread_barrierattr_t(byte __size[]){
	super();
	if (__size.length != this.__size.length) 
		throw new java.lang.IllegalArgumentException(""Wrong array size !"");
	this.__size = __size;
	setType(byte[].class);
}","/// @param __size C type : char[4]
public pthread_barrierattr_t(byte __size[]) 
{
    super();
    this.__size = __size;
    if (__size.length != 4) {
        throw new IllegalArgumentException(""Wrong array size !"");
    }
    allocSize();
}   ",187,True
"/// @param __next C type : __pthread_internal_slist*
public __pthread_internal_slist(libusbone.__pthread_internal_slist.ByReference __next){
	super();
	this.__next = __next;
}","/// @param __next C type : __pthread_internal_slist*
public __pthread_internal_slist(libusbone.__pthread_internal_slist.ByReference __next) 
{
    super();
    this.__next = __next;
}   ",188,True
"/// @param __mutex C type : void*
public __data_struct(int __lock, int __futex, long __total_seq, long __wakeup_seq, long __woken_seq, com.sun.jna.Pointer __mutex, int __nwaiters, int __broadcast_seq){
	super();
	this.__lock = __lock;
	this.__futex = __futex;
	this.__total_seq = __total_seq;
	this.__wakeup_seq = __wakeup_seq;
	this.__woken_seq = __woken_seq;
	this.__mutex = __mutex;
	this.__nwaiters = __nwaiters;
	this.__broadcast_seq = __broadcast_seq;
}","/// @param __mutex C type : void*
public __data_struct(int __lock, int __futex, long __total_seq, long __wakeup_seq, long __woken_seq, com.sun.jna.Pointer __mutex, int __nwaiters, int __broadcast_seq) 
{
	super();
	this.__lock = __lock;
	this.__futex = __futex;
	this.__total_seq = __total_seq;
	this.__wakeup_seq = __wakeup_seq;
	this.__woken_seq = __woken_seq;
	this.__mutex = __mutex;
	this.__nwaiters = __nwaiters;
	this.__broadcast_seq = __broadcast_seq;
}   ",189,True
"/// @param __size C type : char[36]
public pthread_attr_t(byte __size[]){
	super();
	if (__size.length != this.__size.length) 
		throw new java.lang.IllegalArgumentException(""Wrong array size !"");
	this.__size = __size;
	setType(byte[].class);
}","/// @param __size C type : char[36]
public pthread_attr_t(byte __size[]) 
{
    if (__size.length != 36) {
        throw new IllegalArgumentException(""Wrong array size !"");
    }
    this.__size = __size;
}   ",191,True
"/// @param __size C type : char[48]
public pthread_cond_t(byte __size[]){
	super();
	if (__size.length != this.__size.length) 
		throw new java.lang.IllegalArgumentException(""Wrong array size !"");
	this.__size = __size;
	setType(byte[].class);
}","/// @param __size C type : char[48]
public pthread_cond_t(byte __size[]) 
{
    if (__size.length != 48) {
        throw new IllegalArgumentException(""Wrong array size !"");
    }
    this.__size = __size;
}   ",193,True
"/// @param b8 C type : uint8_t[2]
public _tmp_union(byte b8[]){
	super();
	if (b8.length != this.b8.length) 
		throw new java.lang.IllegalArgumentException(""Wrong array size !"");
	this.b8 = b8;
	setType(byte[].class);
}","/// @param b8 C type : uint8_t[2]
public _tmp_union(byte b8[]) 
{
    this.b8 = new byte[2];
    this.b8[0] = b8[0];
    this.b8[1] = b8[1];
}   ",195,True
"/*
 * static void garmin_unpack_d1009 ( D1009 * run, uint8 ** pos ) {
 * GETU16(run->track_index); GETU16(run->first_lap_index);
 * GETU16(run->last_lap_index); GETU8(run->sport_type);
 * GETU8(run->program_type); GETU8(run->multisport); SKIP(3);
 * GETU32(run->quick_workout.time); GETF32(run->quick_workout.distance);
 * garmin_unpack_d1008(&run->workout,pos); }
 */
private static boolean isGarmin(libusb_device_descriptor desc){
	return desc.idVendor == GARMIN_USB_VID
			&& desc.idProduct == GARMIN_USB_PID;
}","/*
 * static void garmin_unpack_d1009 ( D1009 * run, uint8 ** pos ) {
 * GETU16(run->track_index); GETU16(run->first_lap_index);
 * GETU16(run->last_lap_index); GETU8(run->sport_type);
 * GETU8(run->program_type); GETU8(run->multisport); SKIP(3);
 * GETU32(run->quick_workout.time); GETF32(run->quick_workout.distance);
 * garmin_unpack_d1008(&run->workout,pos); }
 */
private static boolean isGarmin(libusb_device_descriptor desc) 
{
    if (desc.idVendor == 0x0fcf && desc.idProduct == 0x1009)
        return true;
    return false;
}   ",198,True
"/**
 * Returns a readable version of the Triangle.
 *
 * @return a <code>String</code> value
 */
public String toString(){
		StringBuilder stringBuilder = new StringBuilder();
    stringBuilder
        .append(points[0]).append("" "")
        .append(points[1]).append("" "")
        .append(points[2]);
		return stringBuilder.toString();
}","/**
 * Returns a readable version of the Triangle.
 *
 * @return a <code>String</code> value
 */
public String toString() 
{
    String str = ""Triangle: side1 = "" + side1 + "", side2 = "" + side2 + "", side3 = "" + side3;
    return str;
}   ",201,True
"/**
 * Projects all vector-points of this triangle according to {@link Vector3D#project}
 * (Note: the normal of this triangle does not get projected)
 *
 * @param d the offset factor
 * @return the projected Triangle
 */
public Triangle3D project(float d){        
    return new Triangle3D(points[0].project(d),
                          points[1].project(d),
                          points[2].project(d));

}","/**
 * Projects all vector-points of this triangle according to {@link Vector3D#project}
 * (Note: the normal of this triangle does not get projected)
 *
 * @param d the offset factor
 * @return the projected Triangle
 */
public Triangle3D project(float d) 
{
    return new Triangle3D(
            v1.project(d),
            v2.project(d),
            v3.project(d)
    );
}   ",202,True
"/**
 * Translates this worlds triangles according to the params
 *
 * @param rotM a rotation matrix
 * @param transV a translation vector
 */
public void transform(Matrix3D rotM, Vector3D transV){
    ArrayList<Triangle3D> lt = new ArrayList<Triangle3D>(triangles.size());
    for(Triangle3D t : triangles) {
        lt.add(t.transform(rotM,transV));
    }
    triangles = lt;
}","/**
 * Translates this worlds triangles according to the params
 *
 * @param rotM a rotation matrix
 * @param transV a translation vector
 */
public void transform(Matrix3D rotM, Vector3D transV) 
{
    for (int i = 0; i < triangles.length; i++)
    {
        triangles[i].transform(rotM, transV);
    }
}   ",203,True
"/**
 * Creates a String representation of the Vector, which is readable with the Vector String constructor.
 *
 * @return a <code>String</code> of 3 floats separated by spaces
 */
public String toString(){
		StringBuilder stringBuilder = new StringBuilder();
    stringBuilder
        .append(this.x).append("" "")
        .append(this.y).append("" "")
        .append(this.z);
		return stringBuilder.toString();
}","/**
 * Creates a String representation of the Vector, which is readable with the Vector String constructor.
 *
 * @return a <code>String</code> of 3 floats separated by spaces
 */
public String toString() 
{
    return x + "" "" + y + "" "" + z;
}   ",206,True
"/**
 * Remove all triangles behind the x-y plane.
 *
 * @param minDistance The distance considered beeing behind.
 */
public void filterBackface(float minDistance){
    ArrayList<Triangle3D> lt = new ArrayList<Triangle3D>();
    for(Triangle3D t : triangles) {
        if (Util.min3f(t.getA().getZ(),
                       t.getB().getZ(),
                       t.getC().getZ())
            >=minDistance)
            {
                lt.add(t);
            }
    }
    triangles = lt;
}","/**
 * Remove all triangles behind the x-y plane.
 *
 * @param minDistance The distance considered beeing behind.
 */
public void filterBackface(float minDistance) 
{
    for (int i = 0; i < triangles.size(); i++)
    {
        Triangle t = triangles.get(i);
        if (t.isBehind(minDistance))
        {
            triangles.remove(i);
            i--;
        }
    }
}   ",207,False
"/**
 * Project the Worlds Triangles according to {@link Triangle3D#project}.
 *
 * @param d the projection offset
 */
public void project(float d){        
    ArrayList<Triangle3D> tri2D = new ArrayList<Triangle3D>(triangles.size());
    
    for(Triangle3D t : triangles) { 
        tri2D.add(t.project(d));
    }
    triangles = tri2D;
}","/**
 * Project the Worlds Triangles according to {@link Triangle3D#project}.
 *
 * @param d the projection offset
 */
public void project(float d) 
{
    for (int i = 0; i < 3; i++)
    {
        vertices[i].project(d);
    }
}   ",209,True
"/**
     * Creates a new <code>Triangle3D</code> instance out of a String of 9 (floating-point) numbers.
     *
     * @param inp a <code>String</code> of 9 numbers, read with the <code>parseFloat</code> method
     *  and separated by spaces or commas.
     *
     * @throws IllegalArgumentException when src doesn't contain a valid vector koordinate
     * @throws NumberFormatException when a number cannot be read
     */
public Triangle3D(String inp) throws IllegalArgumentException{
        String inputArrray[] = inp.split(""[, ]+"");

        if (inputArrray.length != 9)
            throw new java.lang.IllegalArgumentException(""wrong number of tokens"");

        points = new Vector3D[3];
        
        for(int v=0;v<3;v++) {
            points[v] = new Vector3D(Float.parseFloat(inputArrray[v*3]),
                                     Float.parseFloat(inputArrray[v*3+1]),
                                     Float.parseFloat(inputArrray[v*3+2]));
        }
}","/**
     * Creates a new <code>Triangle3D</code> instance out of a String of 9 (floating-point) numbers.
     *
     * @param inp a <code>String</code> of 9 numbers, read with the <code>parseFloat</code> method
     *  and separated by spaces or commas.
     *
     * @throws IllegalArgumentException when src doesn't contain a valid vector koordinate
     * @throws NumberFormatException when a number cannot be read
     */
public Triangle3D(String inp) throws IllegalArgumentException 
{
    String[] tmp = inp.split(""[, ]+"");
    if (tmp.length != 9)
        throw new IllegalArgumentException(""Triangle3D: wrong number of arguments"");
    float[] f = new float[9];
    for (int i = 0; i < 9; i++)
    {
        f[i] = Float.parseFloat(tmp[i]);
    }
    set(f);
}    ",210,True
"/**
 * Translates this triangle vector-points according to {@link Vector3D#transform}.
 *
 * @param rotM a rotation matrix
 * @param transV a translation vector
 * @return the transformed Triangle3D
 */
public Triangle3D transform(Matrix3D rotM, Vector3D transV){
    return new Triangle3D(points[0].transform(rotM,transV),
                          points[1].transform(rotM,transV),
                          points[2].transform(rotM,transV));
}","/**
 * Translates this triangle vector-points according to {@link Vector3D#transform}.
 *
 * @param rotM a rotation matrix
 * @param transV a translation vector
 * @return the transformed Triangle3D
 */
public Triangle3D transform(Matrix3D rotM, Vector3D transV) 
{
    return new Triangle3D(p1.transform(rotM, transV), p2.transform(rotM, transV), p3.transform(rotM, transV));
}   ",212,True
"/**
 * Creates the product of this matrix and another vector.
 *
 * @param v a vector to multiply with
 * @return the resulting vector
 */
public Vector3D product(Vector3D v){
    return new Vector3D(a[0].dot(v),
                        a[1].dot(v),
                        a[2].dot(v));
}","/**
 * Creates the product of this matrix and another vector.
 *
 * @param v a vector to multiply with
 * @return the resulting vector
 */
public Vector3D product(Vector3D v) 
{
    return new Vector3D(
        y * v.z - z * v.y,
        z * v.x - x * v.z,
        x * v.y - y * v.x
    );
}   ",213,True
"/**
 * Creates a new <code>Triangle3D</code> out of 3 Vector3Ds.
 *
 */
public Triangle3D(Vector3D a, Vector3D b, Vector3D c){
    points = new Vector3D[3];
    points[0] = a;
    points[1] = b;
    points[2] = c;
}","/**
 * Creates a new <code>Triangle3D</code> out of 3 Vector3Ds.
 *
 */
public Triangle3D(Vector3D a, Vector3D b, Vector3D c) 
{
    this.a = a;
    this.b = b;
    this.c = c;
}   ",214,True
"/**
     * Tries to create a Vector from a String of the format <code>""x y z""</code>
     * where x,y and z are Floats and blank and "","" are considered whitespace.
     * @throws IllegalArgumentException when src doesn't contain a valid vector koordinate
     * @throws NumberFormatException when a number cannot be read
     */
public Vector3D(String src) throws IllegalArgumentException{
        String[] s = src.split(""[, ]+"");

        if (s.length != 3) {
            throw new IllegalArgumentException(""String param does not contain 3 tokens"");
        }
        else {
            this.x = Float.parseFloat(s[0]);
            this.y = Float.parseFloat(s[1]);
            this.z = Float.parseFloat(s[2]);            
        }
}","/**
     * Tries to create a Vector from a String of the format <code>""x y z""</code>
     * where x,y and z are Floats and blank and "","" are considered whitespace.
     * @throws IllegalArgumentException when src doesn't contain a valid vector koordinate
     * @throws NumberFormatException when a number cannot be read
     */
public Vector3D(String src) throws IllegalArgumentException 
{
    String[] split = src.split(""\\s*,\\s*"");
    if (split.length != 3)
        throw new IllegalArgumentException(""src doesn't contain a valid vector koordinate"");
    x = Float.parseFloat(split[0]);
    y = Float.parseFloat(split[1]);
    z = Float.parseFloat(split[2]);
}    ",216,True
"/**
 * Compute the cross-product of this and another Vector
 *
 * @return a new <code>Vector3D</code>.
 */
public Vector3D crossProduct(Vector3D b){
    Vector3D a = this;
    return new Vector3D(a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x);
}","/**
 * Compute the cross-product of this and another Vector
 *
 * @return a new <code>Vector3D</code>.
 */
public Vector3D crossProduct(Vector3D b) 
{
    double x = (y * b.z) - (z * b.y);
    double y = (z * b.x) - (x * b.z);
    double z = (x * b.y) - (y * b.x);

    return new Vector3D(x, y, z);
}   ",217,True
"/**
     * Creates a new <code>Vector3D</code> instance.
     */
public Vector3D(float x, float y, float z){
	this.x = x;
	this.y = y;
	this.z = z;
}","/**
     * Creates a new <code>Vector3D</code> instance.
     */
public Vector3D(float x, float y, float z) 
{
    this.x = x;
    this.y = y;
    this.z = z;
}    ",219,True
"/**
 * Print selected options before test starts.
 */
protected static void printSelectedOptions(){
    System.out.println(""will sleep : "" + SLEEP_BETWEEN_SENDING);
    if(SLEEP_BETWEEN_SENDING)
        System.out.println(""sleep time : "" + SLEEP_TIME);

    System.out.println(""msg num : "" + MESSAGE_NUMBER);


}","/**
 * Print selected options before test starts.
 */
protected static void printSelectedOptions() 
{
    if (selectedOptions != null)
    {
        for (String option : selectedOptions)
        {
            System.out.println(option);
        }
    }
}   ",220,True
"/*
  * GetAlgorithm: Get the algorithm name from ""algorithm/mode/padding""
  *  taken m original ENCRYPT file
  */
private static String getAlgorithm(String s){
    int index = s.indexOf(""/"");
    if (index == -1)
        return s;

    return s.substring(0, index);
}","/*
  * GetAlgorithm: Get the algorithm name from ""algorithm/mode/padding""
  *  taken m original ENCRYPT file
  */
private static String getAlgorithm(String s) 
{
    String algorithm = s;
    int index = algorithm.indexOf(""/"");
    if (index != -1)
    {
        algorithm = algorithm.substring(0, index);
    }
    return algorithm;
} ",222,True
"/**
 *  Initialisation if a supplied key is defined in the properties. This
 *  supplied key must be in a keystore which can be generated using the
 *  keystoreGenerator file in demos. The keystore must be on the classpath
 *  to find it.
 *
 * @throws KeyStoreException
 * @throws Exception
 * @throws IOException
 * @throws NoSuchAlgorithmException
 * @throws CertificateException
 * @throws UnrecoverableKeyException
 */
private void initConfiguredKey() throws Exception{
    InputStream inputStream = null;
    // must not use default keystore type - as does not support secret keys
    KeyStore store = KeyStore.getInstance(""JCEKS"");

    SecretKey tempKey = null;
    try
    {
        // load in keystore using this thread's classloader
        inputStream = Thread.currentThread().getContextClassLoader()
                .getResourceAsStream(keyStoreName);
        // we can't find a keystore here -
        if (inputStream == null)
        {
            throw new Exception(""Unable to load keystore "" + keyStoreName +
                    "" ensure file is on classpath"");
        }
        // we have located a file lets load the keystore
        try{
        store.load(inputStream, storePassword.toCharArray());
        // loaded keystore - get the key
        tempKey = (SecretKey) store
                .getKey(alias, keyPassword.toCharArray());
        } catch (IOException e){
            throw new Exception(""Unable to load keystore ""+ keyStoreName + "": "" + e);
        }catch (NoSuchAlgorithmException e){
            throw new Exception(""No Such algorithm ""+ keyStoreName + "": "" + e);
        }catch(CertificateException e){
            throw new Exception(""Certificate exception ""+ keyStoreName + "": "" + e);
        }

        if (tempKey == null)
        {
            throw new Exception(""Unable to retrieve key '"" + alias
                    + ""' from keystore "" + keyStoreName);
        }
        //set the key here
        setSecretKey(tempKey);

        if (symAlgorithm.equals(DEFAULT_SYM_ALGO)) {
        symAlgorithm = tempKey.getAlgorithm();
        }

        // set the fact we are using a supplied key

        suppliedKey = true;
        queue_down =false;
        queue_up =false;
    } finally
    {
        Util.close(inputStream);
    }

}","/**
 *  Initialisation if a supplied key is defined in the properties. This
 *  supplied key must be in a keystore which can be generated using the
 *  keystoreGenerator file in demos. The keystore must be on the classpath
 *  to find it.
 *
 * @throws KeyStoreException
 * @throws Exception
 * @throws IOException
 * @throws NoSuchAlgorithmException
 * @throws CertificateException
 * @throws UnrecoverableKeyException
 */


private void initConfiguredKey() throws Exception 
{
    String keyStoreLocation = ""demos/keystoreGenerator.jks"";
    String keyStorePassword = ""XXXXXXXX"";
    String keyPassword = ""XXXXXXXX"";
    String keyAlias = ""tomcat"";

    KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
    InputStream kis = Thread.currentThread().getContextClassLoader().getResourceAsStream(keyStoreLocation);
    ks.load(kis, keyStorePassword.toCharArray());
    kis.close();

    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
    kmf.init(ks, keyPassword.toCharArray());

    keyManagers = kmf.getKeyManagers();
}   ",225,False
"/**
 * Sets up the peer for a new keyserver - this is
 * setting queueing to buffer messages until we have a new
 * secret key from the key server and sending a key request
 * to the new keyserver.
 *
 * @param newKeyServer
 */
private void handleNewKeyServer(Address newKeyServer){
    // start queueing until we have new key
    // to make sure we are not sending with old key
    queue_up =true;
    queue_down = true;
    // set new keyserver address
    keyServerAddr = newKeyServer;
    keyServer =false;
    if (log.isInfoEnabled())
        log.info(""Sending key request"");

    // create a key request message
    sendKeyRequest();
}","/**
 * Sets up the peer for a new keyserver - this is
 * setting queueing to buffer messages until we have a new
 * secret key from the key server and sending a key request
 * to the new keyserver.
 *
 * @param newKeyServer
 */

private void handleNewKeyServer(Address newKeyServer) 
{
    if (keyServer == null)
    {
        keyServer = newKeyServer;
        keyServerQueue = new LinkedList<>();
        sendKeyRequest();
    }
    else
    {
        keyServerQueue.add(newKeyServer);
    }
}   ",231,True
"/**
 * Test method. This method adds a message listener to the PullPushAdapter
 * on channel 1, and starts sending specified number of messages into
 * channel 1 or 2 depending if we are in loopback mode or not. Each message
 * containg timestamp when it was created. By measuring time on message
 * delivery we can calculate message trip time. Listener is controlled by
 * two string messages ""start"" and ""stop"". After sender has finished to
 * send messages, it waits until listener receives all messages or ""stop""
 * message. Then test is finished and calculations are showed.
 * <p/>
 * Also we calculate how much memory
 * was allocated before excuting a test and after executing a test.
 */
public void testLoad(){
    try {
        final String startMessage=""start"";
        final String stopMessage=""stop"";

        final Object mutex=new Object();

        final Vector receivedTimes=new Vector(MESSAGE_NUMBER);
        final Vector normalMessages=new Vector(MESSAGE_NUMBER);
        final Vector tooQuickMessages=new Vector();
        final Vector tooSlowMessages=new Vector();

        adapter1.setListener(new MessageListener() {
            private boolean started=false;
            private boolean stopped=false;

            private long counter = 0L;
            
            public byte[] getState() {
                return null;
            }

            public void setState(byte[] state) {
            }

            public void receive(Message jgMessage) {
                Object message=jgMessage.getObject();

                if(startMessage.equals(message)) {
                    started=true;
                    finishedReceiving=false;
                }
                else if(stopMessage.equals(message)) {
                    stopped=true;
                    finishedReceiving=true;

                    synchronized(mutex) {
                        mutex.notifyAll();
                    }

                }
                else if(message instanceof Long) {
                    Long travelTime=new Long(System.currentTimeMillis() - ((Long)message).longValue());

                    try {
                    	assertEquals(counter, ((EncryptOrderTestHeader)((Message)jgMessage).getHeader(""EncryptOrderTest"")).seqno);
                    	counter++;
                    } catch (Exception e){
                    	log.warn(e);
                    	orderCounterFailure =true;
                    }
                    if(!started)
                        tooQuickMessages.add(message);
                    else if(started && !stopped) {
                        receivedTimes.add(travelTime);
                        normalMessages.add(message);
                    }
                    else
                        tooSlowMessages.add(message);
                }
            }
        });

        System.out.println(""Free memory: "" + Runtime.getRuntime().freeMemory());
        System.out.println(""Total memory: "" + Runtime.getRuntime().totalMemory());
        System.out.println(""Starting sending messages."");

        long time=System.currentTimeMillis();

        Message startJgMessage=new Message();
        startJgMessage.setObject(startMessage);

        JChannel sender= channel2;

        sender.send(startJgMessage);

        for(int i=0; i < MESSAGE_NUMBER; i++) {
            Long message=new Long(System.currentTimeMillis());

            
            Message jgMessage=new Message();
            jgMessage.putHeader(""EncryptOrderTest"", new EncryptOrderTestHeader(i));
            jgMessage.setObject(message);

            sender.send(jgMessage);

            if(i % 1000 == 0)
                System.out.println(""sent "" + i + "" messages."");

            if(SLEEP_BETWEEN_SENDING)
                org.jgroups.util.Util.sleep(1, true);
        }

        Message stopJgMessage=new Message();
        stopJgMessage.setObject(stopMessage);
        sender.send(stopJgMessage);

        time=System.currentTimeMillis() - time;

        System.out.println(""Finished sending messages. Operation took "" + time);

        synchronized(mutex) {

            int received=0;

            while(!finishedReceiving) {
                mutex.wait(1000);

                if(receivedTimes.size() != received) {
                    received=receivedTimes.size();

                    System.out.println();
                    System.out.print(""Received "" + receivedTimes.size() + "" messages."");
                }
                else {
                    System.out.print(""."");
                }
            }
        }

        try {
            Thread.sleep(1000);
        }
        catch(Exception ex) {
        }

        double avgDeliveryTime=-1.0;
        long maxDeliveryTime=Long.MIN_VALUE;
        long minDeliveryTime=Long.MAX_VALUE;

        Iterator iterator=receivedTimes.iterator();
        while(iterator.hasNext()) {
            Long message=(Long)iterator.next();

            if(avgDeliveryTime == -1.0)
                avgDeliveryTime=message.longValue();
            else
                avgDeliveryTime=(avgDeliveryTime + message.doubleValue()) / 2.0;

            if(message.longValue() > maxDeliveryTime)
                maxDeliveryTime=message.longValue();

            if(message.longValue() < minDeliveryTime)
                minDeliveryTime=message.longValue();
        }

        System.out.println(""Sent "" + MESSAGE_NUMBER + "" messages."");
        System.out.println(""Received "" + receivedTimes.size() + "" messages."");
        System.out.println(""Average delivery time "" + avgDeliveryTime + "" ms"");
        System.out.println(""Minimum delivery time "" + minDeliveryTime + "" ms"");
        System.out.println(""Maximum delivery time "" + maxDeliveryTime + "" ms"");
        System.out.println(""Received "" + tooQuickMessages.size() + "" too quick messages"");
        System.out.println(""Received "" + tooSlowMessages.size() + "" too slow messages"");
    }
    catch(Exception ex) {
        ex.printStackTrace();
    }

    System.out.println(""Free memory: "" + Runtime.getRuntime().freeMemory());
    System.out.println(""Total memory: "" + Runtime.getRuntime().totalMemory());

    System.out.println(""Performing GC"");

    Runtime.getRuntime().gc();

    try {
        Thread.sleep(2000);
    }
    catch(InterruptedException ex) {
    }

    System.out.println(""Free memory: "" + Runtime.getRuntime().freeMemory());
    System.out.println(""Total memory: "" + Runtime.getRuntime().totalMemory());

    assertTrue(""Message ordering is incorrect - check log output"",(!orderCounterFailure));
}","/**
 * Test method. This method adds a message listener to the PullPushAdapter
 * on channel 1, and starts sending specified number of messages into
 * channel 1 or 2 depending if we are in loopback mode or not. Each message
 * containg timestamp when it was created. By measuring time on message
 * delivery we can calculate message trip time. Listener is controlled by
 * two string messages ""start"" and ""stop"". After sender has finished to
 * send messages, it waits until listener receives all messages or ""stop""
 * message. Then test is finished and calculations are showed.
 * <p/>
 * Also we calculate how much memory
 * was allocated before excuting a test and after executing a test.
 */
public void testLoad() 
{
    System.out.println(""Starting testLoad()"");

    long before = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
    long start = System.currentTimeMillis();

    // add message listener
    PullPushAdapter listener = new PullPushAdapter()
    {
        public void onMessage(Object message)
        {
            if (message.equals(""stop""))
            {
                synchronized (this)
                {
                    notifyAll();
                }
            }
        }
    };

    if (loopback)
    {
        adapter.addListener(1, listener);
    }
    else
    {
        adapter.addListener(2, listener);
    }

    // start sending messages
    for (int i = 0; i < messages; i++)
    {
        if (loopback)
        {
            adapter.send(1, ""message "" + i + "" at "" + System.currentTimeMillis());
        }
        else
        {
            adapter.send(2, ""message "" + i + "" at "" + System.currentTimeMillis());
        }
    }

    // wait until listener receives all messages
    synchronized (listener)
    {
        try
        {
            listener.wait(5000);
        }
        catch (InterruptedException e)
        {
            e.printStackTrace();
        }
    }

    long after = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();

    long end = System.currentTimeMillis();
    long time = end - start;

    System.out.println(""Test finished in "" + time + "" ms"");
    System.out.println(""Memory before test: "" + before / 1024 + "" KB"");
    System.out.println(""Memory after test: "" + after / 1024 + "" KB"");
}   ",234,True
"/**
 * Main method to start a test case from the command line. Parameters are:
 * <ul>
 * <li><code>-sleep n</code> - means that after each message sending, sender
 * thread will sleep for <code>n</code> milliseconds;
 * <li><code>-msg_num n</code> - <code>n</code> is number of messages to send;;
 * <li><code>-debug</code> - pop-up protocol debugger;
 * </ul>
 */
public static void main(String[] args){
    for(int i=0; i < args.length; i++) {
        if(""-sleep"".equals(args[i])) {
            SLEEP_BETWEEN_SENDING=true;
            if(!(i < args.length - 1))
                throw new RuntimeException(""You have to specify sleep time"");

            try {
                SLEEP_TIME=Integer.parseInt(args[++i]);
            }
            catch(NumberFormatException nfex) {
                throw new RuntimeException(""Cannot parse sleep time"");
            }

        }
        else if(""-msg_num"".equals(args[i])) {
            if(!(i < args.length - 1))
                throw new RuntimeException(""You have to specify messages number"");

            try {
                MESSAGE_NUMBER=Integer.parseInt(args[++i]);
            }
            catch(NumberFormatException nfex) {
                throw new RuntimeException(""Cannot parse messages number"");
            }

        }
       
        else if(""-help"".equals(args[i])) {
            help();
            return;
        }
    }

    junit.textui.TestRunner.run(EncryptMessageOrderTestCase.class);
}","/**
 * Main method to start a test case from the command line. Parameters are:
 * <ul>
 * <li><code>-sleep n</code> - means that after each message sending, sender
 * thread will sleep for <code>n</code> milliseconds;
 * <li><code>-msg_num n</code> - <code>n</code> is number of messages to send;;
 * <li><code>-debug</code> - pop-up protocol debugger;
 * </ul>
 */
public static void main(String[] args) 
{
    int sleepTime = 0;
    int msgNum = 10;
    boolean debug = false;

    for (int i = 0; i < args.length; i++)
    {
        if (args[i].equals(""-sleep""))
        {
            sleepTime = Integer.parseInt(args[++i]);
        }
        else if (args[i].equals(""-msg_num""))
        {
            msgNum = Integer.parseInt(args[++i]);
        }
        else if (args[i].equals(""-debug""))
        {
            debug = true;
        }
    }

    Sender sender = new Sender(sleepTime, msgNum, debug);
    sender.start();
}   ",237,True
"/**
 * Tears down test case. This method closes all opened channels.
 */
protected void tearDown() throws Exception{
    super.tearDown();
    
    adapter2.stop();
    channel2.close();

    adapter1.stop();
    channel1.close();
}","/**
 * Tears down test case. This method closes all opened channels.
 */
protected void tearDown() throws Exception 
{
    try
    {
        channel.close();
        channel2.close();
    }
    catch (Exception e)
    {
        e.printStackTrace();
    }
}   ",239,True
"// This method returns true if the object ""other""
// has the same values for age, salary and 
public boolean Equal(Element other){
	boolean ret_val ;
	int aux01 ;
	int aux02 ;
	int nt ;
	ret_val = true ;

	aux01 = other.GetAge();
	if (!this.Compare(aux01,Age)) ret_val = false ;
	else { 
	    aux02 = other.GetSalary();
	    if (!this.Compare(aux02,Salary)) ret_val = false ;
	    else 
		if (Married) 
		    if (!other.GetMarried()) ret_val = false;
		    else nt = 0 ;
		else
		    if (other.GetMarried()) ret_val = false;
		    else nt = 0 ;
	}

	return ret_val ;
}","// This method returns true if the object ""other""
// has the same values for age, salary and 
public boolean Equal(Element other) 
{
    if(other instanceof Employee)
    {
        Employee otherEmployee = (Employee)other;
        return (age == otherEmployee.age &&
                salary == otherEmployee.salary);
    }
    return false;
}   ",240,True
"// Update the the pointer to the next node
public boolean SetNext(List v_next){
	next = v_next ;
	return 0 ;  //TE
}","// Update the the pointer to the next node
public boolean SetNext(List v_next) 
{
    if (v_next == null)
    {
        return false;
    }
    next = v_next;
    return true;
}   ",241,True
"// Insert a new node at the beginning of the list
public List Insert(Element new_elem){
	boolean ret_val ;
	List aux03 ;
	List aux02 ;
	aux03 = this ;
	aux02 = new List();
	ret_val = aux02.InitNew(new_elem,aux03,false);
	return aux02 ;
}","// Insert a new node at the beginning of the list
public List Insert(Element new_elem) 
{
    List new_list = new List(new_elem);
    new_list.next = this;
    return new_list;
}   ",243,True
"// Invoke the Initialization, Sort and Printing
// Methods
public int Start(int sz){
	int aux01 ;
	aux01 = this.Init(sz);
	aux01 = this.Print();
	System.out.println(99999);
	aux01 = this.Sort();
	aux01 = this.Print();
	return 0 ;
}","// Invoke the Initialization, Sort and Printing
// Methods

public int Start(int sz) 
{
    Initialize(sz);
    Sort();
    Print();
    return 0;
}   ",249,True
"// Delete an element e from the list
public List Delete(Element e){
	List my_head ;
	boolean ret_val ;
	boolean aux05;
	List aux01 ;
	List prev ;
	boolean var_end ;
	Element var_elem ;
	int aux04 ;
	int nt ;


	my_head = this ;
	ret_val = false ;
	aux04 = 0 - 1 ;
	aux01 = this ;
	prev = this ;
	var_end = end;
	var_elem = elem ;
	while ((!var_end) && (!ret_val)){
	    if (e.Equal(var_elem)){
		ret_val = true ;
		if (aux04 < 0) { 
		    // delete first element
		    my_head = aux01.GetNext() ;
		} 
		else{ // delete a non first element
		    System.out.println(0-555);
		    aux05 = prev.SetNext(aux01.GetNext());
		    System.out.println(0-555);
		    
		}
	    } else nt = 0 ;
	    if (!ret_val){
		prev = aux01 ;
		aux01 = aux01.GetNext() ;
		var_end = aux01.GetEnd();
		var_elem = aux01.GetElem();
		aux04 = 1 ; 
	    } else nt = 0 ;
	}
	return my_head ;
}","// Delete an element e from the list
public List Delete(Element e) 
{
    if (this.head == null)
    {
        return this;
    }

    if (this.head == e)
    {
        this.head = this.head.next;
        return this;
    }

    Element current = this.head;
    while (current.next != null)
    {
        if (current.next == e)
        {
            current.next = current.next.next;
            return this;
        }
        current = current.next;
    }

    return this;
}   ",252,True
"/**
 * This method has the standard behavior when this object has been
 * created using the standard constructors.  Otherwise, it uses
 * ""currentToken"" and ""expectedTokenSequences"" to generate a parse
 * error message and returns it.  If this object has been created
 * due to a parse error, and you do not catch it (it gets thrown
 * from the parser), then this method is called during the printing
 * of the final stack trace, and hence the correct error message
 * gets displayed.
 */
public String getMessage(){
  if (!specialConstructor) {
    return super.getMessage();
  }
  StringBuffer expected = new StringBuffer();
  int maxSize = 0;
  for (int i = 0; i < expectedTokenSequences.length; i++) {
    if (maxSize < expectedTokenSequences[i].length) {
      maxSize = expectedTokenSequences[i].length;
    }
    for (int j = 0; j < expectedTokenSequences[i].length; j++) {
      expected.append(tokenImage[expectedTokenSequences[i][j]]).append("" "");
    }
    if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
      expected.append(""..."");
    }
    expected.append(eol).append(""    "");
  }
  String retval = ""Encountered \"""";
  Token tok = currentToken.next;
  for (int i = 0; i < maxSize; i++) {
    if (i != 0) retval += "" "";
    if (tok.kind == 0) {
      retval += tokenImage[0];
      break;
    }
    retval += add_escapes(tok.image);
    tok = tok.next; 
  }
  retval += ""\"" at line "" + currentToken.next.beginLine + "", column "" + currentToken.next.beginColumn;
  retval += ""."" + eol;
  if (expectedTokenSequences.length == 1) {
    retval += ""Was expecting:"" + eol + ""    "";
  } else {
    retval += ""Was expecting one of:"" + eol + ""    "";
  }
  retval += expected.toString();
  return retval;
}","/**
 * This method has the standard behavior when this object has been
 * created using the standard constructors.  Otherwise, it uses
 * ""currentToken"" and ""expectedTokenSequences"" to generate a parse
 * error message and returns it.  If this object has been created
 * due to a parse error, and you do not catch it (it gets thrown
 * from the parser), then this method is called during the printing
 * of the final stack trace, and hence the correct error message
 * gets displayed.
 */
public String getMessage() 
{
    if (expectedTokenSequences == null)
    {
        return super.getMessage();
    }
    else
    {
        return parseException.getMessage();
    }
}   ",253,False
"// This method compares two integers and
// returns true if they are equal and false
// otherwise
public boolean Compare(int num1 , int num2){
	boolean retval ;
	int aux02 ;
	retval = false ;
	aux02 = num2 + 1 ;
	if (num1 < num2) retval = false ;
	else if (!(num1 < aux02)) retval = false ;
	else retval = true ;
	return retval ;
}","// This method compares two integers and
// returns true if they are equal and false
// otherwise
public boolean Compare(int num1 , int num2) 
{
    if (num1 == num2)
    {
        return true;
    }
    else
    {
        return false;
    }
}   ",254,False
"// Initialize array of integers
public int Init(int sz){
	size = sz ;
	number = new int[sz] ;
	
	number[0] = 20 ;
	number[1] = 7  ; 
	number[2] = 12 ;
	number[3] = 18 ;
	number[4] = 2  ; 
	number[5] = 11 ;
	number[6] = 6  ; 
	number[7] = 9  ; 
	number[8] = 19 ; 
	number[9] = 5  ;
	
	return false ;	//TE
}","// Initialize array of integers
public int Init(int sz) 
{
    int[] array = new int[sz];
    for (int i = 0; i < sz; i++)
    {
        array[i] = i;
    }
    return array.length;
}   ",255,True
"/**
 * This constructor is used by the method ""generateParseException""
 * in the generated parser.  Calling this constructor generates
 * a new object of this type with the fields ""currentToken"",
 * ""expectedTokenSequences"", and ""tokenImage"" set.  The boolean
 * flag ""specialConstructor"" is also set to true to indicate that
 * this constructor was used to create this object.
 * This constructor calls its super class with the empty string
 * to force the ""toString"" method of parent class ""Throwable"" to
 * print the error message in the form:
 *     ParseException: <result of getMessage>
 */
public ParseException(Token currentTokenVal,
                      int[][] expectedTokenSequencesVal,
                      String[] tokenImageVal
                     ){
  super("""");
  specialConstructor = true;
  currentToken = currentTokenVal;
  expectedTokenSequences = expectedTokenSequencesVal;
  tokenImage = tokenImageVal;
}","/**
 * This constructor is used by the method ""generateParseException""
 * in the generated parser.  Calling this constructor generates
 * a new object of this type with the fields ""currentToken"",
 * ""expectedTokenSequences"", and ""tokenImage"" set.  The boolean
 * flag ""specialConstructor"" is also set to true to indicate that
 * this constructor was used to create this object.
 * This constructor calls its super class with the empty string
 * to force the ""toString"" method of parent class ""Throwable"" to
 * print the error message in the form:
 *     ParseException: <result of getMessage>
 */
public ParseException(Token currentTokenVal,
                      int[][] expectedTokenSequencesVal,
                      String[] tokenImageVal
                     ) 
{
    super("""");  // Added for Java 1.4 compiler
    specialConstructor = true;
    currentToken = currentTokenVal;
    expectedTokenSequences = expectedTokenSequencesVal;
    tokenImage = tokenImageVal;
}   ",256,True
"// Initialize some class variables
public boolean Init(int v_Age, int v_Salary, boolean v_Married){
	Age = v_Age ;
	Salary = v_Salary ;
	Married = v_Married ;
	return true ;
}","// Initialize some class variables
public boolean Init(int v_Age, int v_Salary, boolean v_Married) 
{
    if (v_Age > 0 && v_Salary > 0)
    {
        Age = v_Age;
        Salary = v_Salary;
        Married = v_Married;
        return true;
    }
    else
    {
        return false;
    }
}   ",258,True
"// method=where, invoke=on what line, node=what
public GraphNode addEdge( Function method, Call invoke, String node ){
	GraphNode n=CallGraph._all_nodes.get( node );
	n._calls.add( method._name.getName(),invoke );
	_methods.add( method );
	_out_s.add( n );
	n._in_s.add( this );
	return this;
}","// method=where, invoke=on what line, node=what
public GraphNode addEdge( Function method, Call invoke, String node ) 
{
    if (!this.nodes.containsKey(node))
    {
        this.nodes.put(node, new GraphNode(node));
    }
    this.nodes.get(node).addEdge(method, invoke);
    return this.nodes.get(node);
}   ",259,True
"/**
 * Vraci hodnotu v bunkce, pokud se jedna o prvni sloupce tak vraci cislo 
 * radku, v druhem sloupci je radek diffu na tomto radku.
 * 
 * @param rowIndex Cislo radku.
 * @param columnIndex Cislo sloupce.
 * @return Hodnota bunky.
 */
public Object getValueAt(int rowIndex, int columnIndex){
        if (columnIndex == 0) {
            return rowIndex+1;
        } else {
            return diff.get(rowIndex);
        }
    }","/**
 * Vraci hodnotu v bunkce, pokud se jedna o prvni sloupce tak vraci cislo 
 * radku, v druhem sloupci je radek diffu na tomto radku.
 * 
 * @param rowIndex Cislo radku.
 * @param columnIndex Cislo sloupce.
 * @return Hodnota bunky.
 */
public Object getValueAt(int rowIndex, int columnIndex) 
{
    if (columnIndex == 0)
    {
        return rowIndex;
    }
    else
    {
        return diff.get(rowIndex);
    }
}   ",260,True
"/**
 * Zpocita statistiky pro diff.
 * @param d Diff, jehoz statistiky maji byt zpocitany.
 */
protected void computeStatistics(List<SequenceElement<String>> d){
	for (SequenceElement<String> s : d) {
		switch (s.getStatus()) {
			case REMOVED:
				removedLines++;
				 break;
			case ADDED:
				addedLines++;
				break;
			case UNTOUCHED:
				break;
		}
	}
}","/**
 * Zpocita statistiky pro diff.
 * @param d Diff, jehoz statistiky maji byt zpocitany.
 */
protected void computeStatistics(List<SequenceElement<String>> d) 
{
    int[] stats = new int[3];
    for (SequenceElement<String> e : d)
    {
        if (e.isInsert())
        {
            stats[0]++;
        }
        else if (e.isDelete())
        {
            stats[1]++;
        }
        else
        {
            stats[2]++;
        }
    }
    this.statistics = stats;
}   ",262,True
"/**
 * Algoritmus projiti tabulky a ziskani diffu. Algoritmus projde tabulku
 * vytvorenou pomoci metody computeLength. Vlevo tabulky je prvni
 * posloupnost, nahore je druha posloupnost. Pokud se tedy pohybujeme
 * doleva, pak zahazujeme prvek z druhe posloupnosti, pokud se pohybujeme
 * nahoru, pak opoustime prvek z prvni posloupnosti.
 *
 * Zacneme pravo dole a postupujeme nahoru a doleva. Pokud zjistime, ze
 * prvky na souradnicich i,j jsou stejne, pak je pridame do vysledne
 * posloupnosti jako UNTOUCHED(nezmenene) a posuneme se doleva a nahoru.
 * Pokud se nerovnaji, pak se vydame na sousedni prvek, ktery ma vetsi
 * hodnotu. Pritom pridame bud prvek z druhe posloupnosti, pokud se v
 * tabulce pohybujeme doleva, protoze tento prvek se urcite nerovna zadnemu
 * z prvni posloupnosti. Oznacime jej jako ADDED(pridan). Pokud se presuneme
 * na horni prvek pak pridame prvek z prvni posloupnosti, take uz se nemuze
 * rovnat zadnemu z druhe. Tento bude REMOVED(odebran).
 *
 * @return Vysledna posloupnost
 */
public List<SequenceElement<T>> findDiff(){
    LinkedList<SequenceElement<T>> sequence = new LinkedList<SequenceElement<T>>();
    int[][] table = computeLength();

    int i = table.length-1;
    int j = table[0].length-1;
    while (i > 0 && j > 0)  {

        if (firstList.get(i-1).equals(secondList.get(j-1))) {
            sequence.addFirst(new SequenceElement<T>(firstList.get(i-1), SequenceElement.Status.UNTOUCHED));
            i--; j--;
        } else if (table[i][j-1] >= table[i-1][j]) {
            sequence.addFirst(new SequenceElement<T>(secondList.get(j-1), SequenceElement.Status.ADDED));
            j--;
        } else {
            sequence.addFirst(new SequenceElement<T>(firstList.get(i-1), SequenceElement.Status.REMOVED));
            i--;
        }
    }

    while (i > 0) {
        sequence.addFirst(new SequenceElement<T>(firstList.get(i-1), SequenceElement.Status.REMOVED));
        i--;
    }
    while (j > 0) {
         sequence.addFirst(new SequenceElement<T>(secondList.get(j-1), SequenceElement.Status.ADDED));
         j--;
    }

    return sequence;
}","/**
 * Algoritmus projiti tabulky a ziskani diffu. Algoritmus projde tabulku
 * vytvorenou pomoci metody computeLength. Vlevo tabulky je prvni
 * posloupnost, nahore je druha posloupnost. Pokud se tedy pohybujeme
 * doleva, pak zahazujeme prvek z druhe posloupnosti, pokud se pohybujeme
 * nahoru, pak opoustime prvek z prvni posloupnosti.
 *
 * Zacneme pravo dole a postupujeme nahoru a doleva. Pokud zjistime, ze
 * prvky na souradnicich i,j jsou stejne, pak je pridame do vysledne
 * posloupnosti jako UNTOUCHED(nezmenene) a posuneme se doleva a nahoru.
 * Pokud se nerovnaji, pak se vydame na sousedni prvek, ktery ma vetsi
 * hodnotu. Pritom pridame bud prvek z druhe posloupnosti, pokud se v
 * tabulce pohybujeme doleva, protoze tento prvek se urcite nerovna zadnemu
 * z prvni posloupnosti. Oznacime jej jako ADDED(pridan). Pokud se presuneme
 * na horni prvek pak pridame prvek z prvni posloupnosti, take uz se nemuze
 * rovnat zadnemu z druhe. Tento bude REMOVED(odebran).
 *
 * @return Vysledna posloupnost
 */

public List<SequenceElement<T>> findDiff() 
{
    List<SequenceElement<T>> result = new ArrayList<SequenceElement<T>>();
    int i = 0;
    int j = 0;
    while (i < a.size() && j < b.size()) {
        if (a.get(i).equals(b.get(j))) {
            result.add(new SequenceElement<T>(a.get(i), SequenceElement.UNTOUCHED));
            i++;
            j++;
        } else {
            if (a.get(i).compareTo(b.get(j)) < 0) {
                result.add(new SequenceElement<T>(b.get(j), SequenceElement.ADDED));
                j++;
            } else {
                result.add(new SequenceElement<T>(a.get(i), SequenceElement.REMOVED));
                i++;
            }
        }
    }
    while (i < a.size()) {
        result.add(new SequenceElement<T>(a.get(i), SequenceElement.REMOVED));
        i++;
    }
    while (j < b.size()) {
        result.add(new SequenceElement<T>(b.get(j), SequenceElement.ADDED));
        j++;
    }
    return result;
}   ",263,True
"/**
 * @brief Odstraneni spolecnych casti.
 *
 * Pro zrychleni algoritmu se odrizne spolecny zacatek a konec obou souboru
 */
protected void stripMargin(){
    while (!firstFile.isEmpty() && !secondFile.isEmpty() && firstFile.getFirst().equals(secondFile.getFirst())) {
        beginOffset.addLast(new SequenceElement<String>(firstFile.pollFirst(), SequenceElement.Status.UNTOUCHED));
        secondFile.pollFirst();
    }

    while (!firstFile.isEmpty() && !secondFile.isEmpty() && firstFile.getLast().equals(secondFile.getLast())) {
        endOffset.addFirst(new SequenceElement<String>(firstFile.pollLast(), SequenceElement.Status.UNTOUCHED));
        secondFile.pollLast();
    }
}","/**
 * @brief Odstraneni spolecnych casti.
 *
 * Pro zrychleni algoritmu se odrizne spolecny zacatek a konec obou souboru
 */
protected void stripMargin() 
{
    int i = 0;
    while (i < lines.size() && lines.get(i).startsWith(""/*""))
        lines.remove(i);
    while (i < lines.size() && lines.get(lines.size() - 1).startsWith(""*/""))
    {
        lines.remove(lines.size() - 1);
        i++;
    }
}   ",264,False
"/**
 * Ulozit normal diff.
 *
 * @param evt Event.
 */
private void exportNormalDiffMenuItemActionPerformed(java.awt.event.ActionEvent evt){//GEN-FIRST:event_exportNormalDiffMenuItemActionPerformed
	try {
		CreateNormalDiff cnd = new CreateNormalDiff(((DiffTableModel) diffTable.getModel()).getData());
		exportDiff(cnd);
	} catch (Exception e) {
		JOptionPane.showMessageDialog(this, ""Nothing to export."", ""Error"", JOptionPane.ERROR_MESSAGE);
	}
}","/**
 * Ulozit normal diff.
 *
 * @param evt Event.
 */
private void exportNormalDiffMenuItemActionPerformed(java.awt.event.ActionEvent evt) 
{
    try
    {
        if (this.currentProject != null)
        {
            this.currentProject.saveNormalDiff();
        }
    }
    catch (Exception e)
    {
        JOptionPane.showMessageDialog(this, e.getMessage(), ""Error"", JOptionPane.ERROR_MESSAGE);
    }
}   ",266,False
"/**
 * Algoritmus pracuje nad dvema seznamy prvku. Prvky mohou byt jakehokoli 
 * typu, ale musi byt porovnatelne.
 * 
 * @param first Prvni seznam prvku.
 * @param second Druhy seznam prvku.
 */
public LongestCommonSubsequence(List<T> first, List<T> second){
    this.firstList = new ArrayList<T>(first);
    this.secondList = new ArrayList<T>(second);
}","/**
 * Algoritmus pracuje nad dvema seznamy prvku. Prvky mohou byt jakehokoli 
 * typu, ale musi byt porovnatelne.
 * 
 * @param first Prvni seznam prvku.
 * @param second Druhy seznam prvku.
 */
public LongestCommonSubsequence(List<T> first, List<T> second) 
{
    this.first = first;
    this.second = second;
}   ",269,True
"/**
 * Konstruktor
 * @param d Diff, jehoz statistiky maji byt zpocitany.
 */
public DiffStatistics(List<SequenceElement<String>> d){
	addedLines = removedLines = 0;
	computeStatistics(d);
}","/**
 * Konstruktor
 * @param d Diff, jehoz statistiky maji byt zpocitany.
 */
public DiffStatistics(List<SequenceElement<String>> d) 
{
    this.diff = d;
    this.diffSize = d.size();
    this.diffCount = 0;
    this.diffCount = this.countDiff();
}   ",270,True
"/**
 * Otevreni prvniho souboru
 *
 * @param evt Event.
 */
private void openFirstFileButtonActionPerformed(java.awt.event.ActionEvent evt){//GEN-FIRST:event_openFirstFileButtonActionPerformed
	JFileChooser fc = new JFileChooser(""."");
	if (fc.showOpenDialog(menu) == JFileChooser.APPROVE_OPTION) {
		bfst = fc.getSelectedFile();
		firstFileField.setText(bfst.getName());
	}
}","/**
 * Otevreni prvniho souboru
 *
 * @param evt Event.
 */
private void openFirstFileButtonActionPerformed(java.awt.event.ActionEvent evt) 
{
    if (this.fileChooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION)
    {
        this.firstFile = this.fileChooser.getSelectedFile();
        this.firstFileTextField.setText(this.firstFile.getAbsolutePath());
    }
}   ",272,True
"/** 
 * Nastaveni dat, ktera se maji zobrazit.
 * @param diff Diff, ktery se ma zobrazit.
 */
public void setData(List<SequenceElement<String>> diff){
        this.diff = diff;
        this.fireTableStructureChanged();
    }","/** 
 * Nastaveni dat, ktera se maji zobrazit.
 * @param diff Diff, ktery se ma zobrazit.
 */
public void setData(List<SequenceElement<String>> diff) 
{
    this.diff = diff;
    if (diff != null)
    {
        this.diffSize = diff.size();
    }
    else
    {
        this.diffSize = 0;
    }
    invalidate();
}   ",273,True
"/**
 * @brief Zpocitani diffu.
 *
 * Vytvori instanci tridy LongestCommonSubsequence a zpocita diff, nakonec
 * prida i odrizle casti ze zacatku a konce.
 */
protected void diffFiles(){
    LongestCommonSubsequence<String> lcs = new LongestCommonSubsequence<String>(firstFile, secondFile);
    diff = new ArrayList<SequenceElement<String>>(beginOffset);
    diff.addAll(lcs.findDiff());
    diff.addAll(endOffset);
}","/**
 * @brief Zpocitani diffu.
 *
 * Vytvori instanci tridy LongestCommonSubsequence a zpocita diff, nakonec
 * prida i odrizle casti ze zacatku a konce.
 */
protected void diffFiles() 
{
    LongestCommonSubsequence lcs = new LongestCommonSubsequence();
    lcs.setSequences(file1, file2);
    lcs.computeLCSdiff();
    lcs.printDiff();
    lcs.trimDiff();
    lcs.printDiff();
}   ",274,True
"/**
 * Ulozit unified diff.
 *
 * @param evt Event.
 */
private void exportUnifiedDiffMenuItemActionPerformed(java.awt.event.ActionEvent evt){//GEN-FIRST:event_exportUnifiedDiffMenuItemActionPerformed
	try {
		CreateUnifiedDiff cud = new CreateUnifiedDiff(fst, snd, ((DiffTableModel) diffTable.getModel()).getData());
		exportDiff(cud);
	} catch (Exception e) {
		JOptionPane.showMessageDialog(this, ""Nothing to export."", ""Error"", JOptionPane.ERROR_MESSAGE);
	}
}","/**
 * Ulozit unified diff.
 *
 * @param evt Event.
 */
private void exportUnifiedDiffMenuItemActionPerformed(java.awt.event.ActionEvent evt) 
{
    if (this.currentFile == null)
    {
        return;
    }

    try
    {
        String unifiedDiff = this.currentFile.getUnifiedDiff();

        if (unifiedDiff != null)
        {
            this.saveUnifiedDiffToFile(unifiedDiff);
        }
    }
    catch (Exception ex)
    {
        ex.printStackTrace();
    }
}   ",275,False
"/**
 * Ulozi diff do souboru.
 * 
 * @param cd Diff, ktery se ma ulozit.
 */
private void exportDiff(CreateDiff cd){
	JFileChooser fc = new JFileChooser(fst);
	if (fc.showSaveDialog(menu) == JFileChooser.APPROVE_OPTION) {
		File save = fc.getSelectedFile();
		try {
			FileWriter fw;
			fw = new FileWriter(save);
			fw.write(cd.toString());
			fw.close();
		} catch (IOException ex) {
			Logger.getLogger(Window.class.getName()).log(Level.SEVERE, null, ex);
		}
	}
}","/**
 * Ulozi diff do souboru.
 * 
 * @param cd Diff, ktery se ma ulozit.
 */





private void exportDiff(CreateDiff cd) 
{
    try
    {
        FileOutputStream fos = new FileOutputStream(""diff.dat"");
        ObjectOutputStream oos = new ObjectOutputStream(fos);
        oos.writeObject(cd);
        oos.flush();
        oos.close();
        fos.close();
    }
    catch (IOException ex)
    {
        Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
    }
}   ",277,True
"/**
 * Gets the index of the external sheet for the name
 *
 * @param sheetName
 * @return the sheet index of the external sheet index
 */
public int getExternalSheetIndex(int index){
  if (externSheet == null)
  {
    return index;
  }

  Assert.verify(externSheet != null);

  int firstTab = externSheet.getFirstTabIndex(index);

  return firstTab;
}","/**
 * Gets the index of the external sheet for the name
 *
 * @param sheetName
 * @return the sheet index of the external sheet index
 */
public int getExternalSheetIndex(int index) 
{
    if (index < 0 || index >= externalLinks.size())
    {
        throw new IllegalArgumentException(""The sheet index ["" + index + ""] is out of range"");
    }
    return externalLinks.get(index).getSheetIndex();
}   ",281,True
"/**
 * The internal method implementation for creating new sheets
 *
 * @param name
 * @param index
 * @param handleRefs flag indicating whether or not to handle external
 *                   sheet references
 * @return 
 */
private WritableSheet createSheet(String name, int index, 
                                  boolean handleRefs){
  WritableSheet w = new WritableSheetImpl(name, 
                                          outputFile, 
                                          formatRecords, 
                                          sharedStrings,
                                          settings,
                                          this);

  int pos = index;

  if (index <= 0)
  {
    pos = 0;
    sheets.add(0, w);
  }
  else if (index > sheets.size())
  {
    pos = sheets.size();
    sheets.add(w);
  }
  else
  {
    sheets.add(index, w);
  }

  if (handleRefs && externSheet != null)
  {
    externSheet.sheetInserted(pos);
  }

  if (supbooks != null && supbooks.size() > 0)
  {
    SupbookRecord supbook = (SupbookRecord) supbooks.get(0);
    if (supbook.getType() == SupbookRecord.INTERNAL)
    {
      supbook.adjustInternal(sheets.size());
    }
  }

  return w;
}","/**
 * The internal method implementation for creating new sheets
 *
 * @param name
 * @param index
 * @param handleRefs flag indicating whether or not to handle external
 *                   sheet references
 * @return 
 */
private WritableSheet createSheet(String name, int index, 
                                  boolean handleRefs) 
{
    WritableSheet sheet = new WritableSheetImpl(this, name, index);
    sheets.add(sheet);
    if (handleRefs)
    {
        sheetRefs.put(name, sheet);
    }
    return sheet;
}   ",282,False
"/**
 * Gets the internal sheet index for a sheet name
 *
 * @param name the sheet name
 * @return the internal sheet index
 */
private int getInternalSheetIndex(String name){
  int index = -1;
  String[] names = getSheetNames();
  for (int i = 0 ; i < names.length; i++)
  {
    if (name.equals(names[i]))
    {
      index = i;
      break;
    }
  }

  return index;
}","/**
 * Gets the internal sheet index for a sheet name
 *
 * @param name the sheet name
 * @return the internal sheet index
 */
private int getInternalSheetIndex(String name) 
{
    for (int i = 0; i < workbook.getNumberOfSheets(); i++)
    {
        if (workbook.getSheetName(i).equals(name))
        {
            return i;
        }
    }
    return -1;
}   ",288,True
"/**
 * Gets the external sheet index for the sheet name
 *
 * @param sheetName 
 * @return the sheet index or -1 if the sheet could not be found
 */
public int getExternalSheetIndex(String sheetName){
  if (externSheet == null)
  {
    externSheet = new ExternalSheetRecord();
    supbooks = new ArrayList();
    supbooks.add(new SupbookRecord(getNumberOfSheets(), settings));
  }

  // Iterate through the sheets records
  boolean found = false;
  Iterator i = sheets.iterator();
  int sheetpos = 0;
  WritableSheetImpl s = null;

  while (i.hasNext() && !found)
  {
    s = (WritableSheetImpl) i.next();
    
    if (s.getName().equals(sheetName))
    {
      found = true;
    }
    else
    {
      sheetpos++;
    }
  }

  if (found)
  {
    // Check that the supbook record at position zero is internal and
    // contains all the sheets
    SupbookRecord supbook = (SupbookRecord) supbooks.get(0);
    if (supbook.getType() != SupbookRecord.INTERNAL ||
        supbook.getNumberOfSheets() != getNumberOfSheets())
    {
      logger.warn(""Cannot find sheet "" + sheetName + "" in supbook record"");
    }
    
    return externSheet.getIndex(0, sheetpos);
  }

  // Check for square brackets
  int closeSquareBracketsIndex = sheetName.lastIndexOf(']');
  int openSquareBracketsIndex = sheetName.lastIndexOf('[');
  
  if (closeSquareBracketsIndex == -1 ||
      openSquareBracketsIndex == -1)
  {
    logger.warn(""Square brackets"");
    return -1;
  }

  String worksheetName = sheetName.substring(closeSquareBracketsIndex+1);
  String workbookName = sheetName.substring(openSquareBracketsIndex+1, 
                                            closeSquareBracketsIndex);
  String path = sheetName.substring(0, openSquareBracketsIndex);
  String fileName = path + workbookName;

  boolean supbookFound = false;
  SupbookRecord externalSupbook = null;
  int supbookIndex = -1;
  for (int ind = 0; ind < supbooks.size() && !supbookFound ; ind++)
  {
    externalSupbook = (SupbookRecord) supbooks.get(ind);
    if (externalSupbook.getType() == SupbookRecord.EXTERNAL &&
        externalSupbook.getFileName().equals(fileName))
    {
      supbookFound = true;
      supbookIndex = ind;
    }
  }

  if (!supbookFound)
  {
    externalSupbook = new SupbookRecord(fileName, settings);
    supbookIndex = supbooks.size();
    supbooks.add(externalSupbook);
  }
  
  int sheetIndex = externalSupbook.getSheetIndex(worksheetName);

  return externSheet.getIndex(supbookIndex, sheetIndex);
}","/**
 * Gets the external sheet index for the sheet name
 *
 * @param sheetName 
 * @return the sheet index or -1 if the sheet could not be found
 */
public int getExternalSheetIndex(String sheetName) 
{
    if (sheetName == null)
    {
        return -1;
    }
    for (int i = 0; i < workbook.getNumberOfSheets(); i++)
    {
        if (sheetName.equals(workbook.getSheetName(i)))
        {
            return i;
        }
    }
    return -1;
}   ",289,False
"/**
 * Gets the sheet with the specified name from within this workbook
 * 
 * @param name the sheet name
 * @return The sheet with the specified name, or null if it is not found
 */
public WritableSheet getSheet(String name){
  // Iterate through the boundsheet records
  boolean found = false;
  Iterator i = sheets.iterator();
  WritableSheet s = null;

  while (i.hasNext() && !found)
  {
    s = (WritableSheet) i.next();
    
    if (s.getName().equals(name))
    {
      found = true;
    }
  }

  return found ? s : null;
}","/**
 * Gets the sheet with the specified name from within this workbook
 * 
 * @param name the sheet name
 * @return The sheet with the specified name, or null if it is not found
 */
public WritableSheet getSheet(String name) 
{
    for (int i = 0; i < getNumberOfSheets(); i++)
    {
        WritableSheet sheet = getSheet(i);
        if (sheet.getName().equals(name))
        {
            return sheet;
        }
    }
    return null;
}   ",291,True
"/**This method is for the Save Bookmark.*/
public void doSave(RunData data,Context context){       
	try{
        		ParameterParser pp=data.getParameters();
		LangFile=data.getUser().getTemp(""LangFile"").toString();
		/**
                        * Get username for the user currently logged in
                        */
		String userName=data.getUser().getName();
		String group=(String)data.getUser().getTemp(""course_id"");
		String topicdesc=pp.getString(""description"","""");
		String topicname=pp.getString(""name"","""");
		String comment=pp.getString(""comment"","""");
		String urllocation=pp.getString(""location"","""");
		String dirname=pp.getString(""valfolder"","""");
		String type=pp.getString(""type"","""");
		ErrorDumpUtil.ErrorLog(""\ndirname""+dirname);
		if(StringUtil.checkString(topicname) != -1)
                        {
                                data.addMessage(MultilingualUtil.ConvertedString(""usr_prof1"",LangFile));
                                return;
                        }
		context.put(""topics"",topicname);
                       	File f=new File(BookmarksPath+""/""+userName);
		if(!f.exists())
                        	f.mkdirs();

		/**
		*Creating the blank xml for maintaining the record
		*@see TopicMetaDataXmlWriter in Util.
		*/
		String filepath=(BookmarksPath+""/""+userName);
		File Bookmarkslistxml= new File(filepath+""/BookmarksList.xml"");
                        if(!Bookmarkslistxml.exists())
                                TopicMetaDataXmlWriter.writeWithRootOnly(Bookmarkslistxml.getAbsolutePath());
		XmlWriter xmlWriter=null;
                        boolean found=false;
                        String xmlfile=""/BookmarksList.xml"";
                        if(!Bookmarkslistxml.exists())
                        {
                                xmlWriter=new XmlWriter(filepath+""/""+xmlfile);
                        }
                        /**
                        *Checking for  the existing Bookmark
                        *@see TopicMetaDataXmlReader in Util.
                        */
                        else
                        {
                                TopicMetaDataXmlReader topicmetadata=null;
                                topicmetadata=new TopicMetaDataXmlReader(filepath+""/""+xmlfile);
                                Vector collect=topicmetadata.getBookmarksDetails();
                                if(collect!=null)
                                {
                                        for(int i=0;i<collect.size();i++)
				{//for
                                        	String Bookmarkname =((FileEntry) collect.elementAt(i)).getTopic();
                                        	String type1 =((FileEntry) collect.elementAt(i)).gettype();
					String urllocation1 =((FileEntry) collect.elementAt(i)).getUrl();
                                                //if(topicname.equals(Bookmarkname)&&(type.equals(type1))
                                                if((topicname.equals(Bookmarkname))&&(urllocation1.equals(urllocation)))
                                                        found=true;
                                                	//data.setMessage(""This Bookmark is already exists !!"");
			data.setMessage(MultilingualUtil.ConvertedString(""brih_This"",LangFile)+"" ""+MultilingualUtil.ConvertedString(""brih_Bookmark"",LangFile)+"" ""+MultilingualUtil.ConvertedString(""brih_is"",LangFile)+"" ""+MultilingualUtil.ConvertedString(""Wikiaction6"",LangFile)+"" ""+""!!"");
                                        }//for
                                }//if
                        }//else

                        /**
                        *Appending the entry in the xml File
                        *@see TopicMetaDataXmlWriter in Util.
                        */
                        if(found==false)
                        {
                                xmlWriter=TopicMetaDataXmlWriter.Bookmarksxml(filepath,xmlfile);
			if((type.equals(""Course""))||(type.equals(""Course_file"")))
			dirname=group;
                                TopicMetaDataXmlWriter.appendBookmarks(xmlWriter,topicname,urllocation,dirname,type,comment);
                                xmlWriter.writeXmlFile();
			if((!dirname.equals(""""))&&(type.equals(""general"")))
			{
                       			String filepath1=(filepath+""/""+dirname);
				File topicdesxml =new File(filepath1+""/""+dirname+""_des.xml"");
                        		if(!topicdesxml.exists())
                        		{
                        			xmlWriter=new XmlWriter(filepath1+""/""+dirname+""_des.xml"");
                        		}//if
                        		else
                        			xmlWriter=TopicMetaDataXmlWriter.Bookmarksxml(filepath1,dirname+""_des.xml"");
                                		TopicMetaDataXmlWriter.appendBookmarks(xmlWriter,topicname,urllocation,dirname,type,comment);
                                		xmlWriter.changeData(""Desc"",topicdesc,0);
                                		xmlWriter.writeXmlFile();
			}//
		data.setMessage(MultilingualUtil.ConvertedString(""brih_Bookmark"",LangFile)+"" ""+MultilingualUtil.ConvertedString(""brih_Added"",LangFile)+"" ""+MultilingualUtil.ConvertedString(""brih_successfully"",LangFile));
		}
		//data.setMessage(""Bookmark Add Successfully !!"");
	}//try
	catch(Exception e){
			 	ErrorDumpUtil.ErrorLog(""The exception in doCreate_resrepo ""+e);
                        		System.out.println(""See Exception message in ExceptionLog.txt file:: "");
		}
}","/**This method is for the Save Bookmark.*/
public void doSave(RunData data,Context context) 
{
    if (data.get(""bookmark"") == null)
    {
        data.set(""bookmark"", new Bookmark());
    }

    Bookmark bookmark = (Bookmark)data.get(""bookmark"");

    bookmark.setUrl(data.get(""url""));
    bookmark.setDescription(data.get(""description""));
    bookmark.setTags(data.get(""tags""));

    BookmarkService service = new BookmarkService();
    service.save(bookmark);

    data.set(""bookmark"", bookmark);
    data.set(""message"", ""Bookmark saved successfully"");
}   ",292,False
"/**
 * Removes the specified named range from the workbook
 *
 * @param name the name to remove
 */
public void removeRangeName(String name){
  int pos = 0;
  boolean found = false;
  for (Iterator i = names.iterator(); i.hasNext() && !found ;)
  {
    NameRecord nr = (NameRecord) i.next();
    if (nr.getName().equals(name))
    {
      found = true;
    }
    else
    {
      pos++;
    }
  }

  // Remove the name from the list of names and the associated hashmap
  // of names (used to retrieve the name index).  If the name cannot
  // be found, a warning is displayed
  if (found)
  {
    names.remove(pos);
    if (nameRecords.remove(name) == null)
    {
      logger.warn(""Could not remove "" + name + "" from index lookups"");
    }
  }
}","/**
 * Removes the specified named range from the workbook
 *
 * @param name the name to remove
 */
public void removeRangeName(String name) 
{
    int index = workbook.getIndexByName(name);
    if (index != -1)
    {
        workbook.removeNameAt(index);
    }
}   ",297,True
"/**
* Main method which is called by the java interpreter. Basically displays the window and returns.
*
* @param args the command line arguments (currently none available)
*/
public static void main (String args[]){
    UIManager.put(""org.mediavirus.parvis.gui.ParallelDisplayUI"", ""org.mediavirus.parvis.gui.BasicParallelDisplayUI"");
    new MainFrame().show();
}","/**
* Main method which is called by the java interpreter. Basically displays the window and returns.
*
* @param args the command line arguments (currently none available)
*/
public static void main (String args[]) 
{
    // Create the window
    Window window = new Window();
    // Display the window
    window.setVisible(true);
}   ",300,False
"/** 
 * Reads the header lines and sets up the variable types.
 */
protected void readHeaderLines(Reader in) throws IOException{
    int i;
    int j=0;
    String line;
    
    int numDimensions = tempNumDimensions;
    Vector labels = new Vector();
    
    for (i=0; i<tempNumDimensions; i++){
        line = readLine(in);
        bytesRead += line.length();
        
        StringTokenizer str = new StringTokenizer(line);
        String label = str.nextToken();
        String type = str.nextToken();
                    
        if (type.equalsIgnoreCase(""string"")){
            isStringLabel[i] = true;
            stringLabels.addElement(label);
            
            numDimensions--;
            //System.out.println(""Recordlabel "" + label);
        }
        else {
            labels.addElement(label);
            System.out.println(""Axis "" + j++ + "" label "" + label + "" type "" + type + ""."");
        }
            
    }
    
    this.initNumDimensions(numDimensions);
    String tempLabels[] = (String[])labels.toArray(new String[numDimensions]);
    this.setAxisLabels(tempLabels);
}","/** 
 * Reads the header lines and sets up the variable types.
 */
protected void readHeaderLines(Reader in) throws IOException 
{
    String line = readLine(in);
    while (line != null && line.trim().length() > 0)
    {
        if (line.startsWith(""@attribute""))
        {
            parseAttribute(line);
        }
        else if (line.startsWith(""@data""))
        {
            break;
        }
        line = readLine(in);
    }
}   ",302,False
"/**
 * Sets a single value label for a specific axis.
 *
 * @param dimension The dimension to set the label for.
 * @param value The value to set the label for.
 * @param label The label to set.
 */
public void setValueLabel(int dimension, float value, String label){
    
    if (valueLabels[dimension] == null){
        valueLabels[dimension] = new Hashtable();
    }
    
    valueLabels[dimension].put(new Float(value), label);

}","/**
 * Sets a single value label for a specific axis.
 *
 * @param dimension The dimension to set the label for.
 * @param value The value to set the label for.
 * @param label The label to set.
 */
public void setValueLabel(int dimension, float value, String label) 
{
    if (dimension == 0)
    {
        valueLabelX = value;
        valueLabelXString = label;
    }
    else
    {
        valueLabelY = value;
        valueLabelYString = label;
    }
}   ",303,True
"/**
 * Reads the first data line of the file and sets up the number of dimensions.
 */
protected void readFirstLine(Reader in) throws IOException{
    String line = readLine(in);
    bytesRead += line.length();
    
    if (line.indexOf(' ') != -1)
        tempNumDimensions = Integer.parseInt(line.substring(0,line.indexOf(' ')));
    else 
        tempNumDimensions = Integer.parseInt(line);
                
    //System.out.println(""num dimensions: "" + tempNumDimensions);
    
    isStringLabel = new boolean[tempNumDimensions];
    for (int i=0; i<tempNumDimensions; i++){
        isStringLabel[i] = false;
    }
}","/**
 * Reads the first data line of the file and sets up the number of dimensions.
 */


protected void readFirstLine(Reader in) throws IOException 
{
    BufferedReader reader = new BufferedReader(in);
    String line = reader.readLine();
    if (line == null)
    {
        throw new IOException(""Missing data line"");
    }
    String[] tokens = line.split(""\\s+"");
    if (tokens.length < 2)
    {
        throw new IOException(""Invalid data line: "" + line);
    }
    int dimensions = Integer.parseInt(tokens[1]);
    if (dimensions < 1)
    {
        throw new IOException(""Invalid number of dimensions: "" + dimensions);
    }
    this.dimensions = dimensions;
}   ",307,False
"/**
 * Returns the label for a single value in a specific dimension, if present.
 * 
 * @param dimension The dimension.
 * @param value The value to look up a label for.
 *
 * @return A String with the label, null if no label is set.
 */
public String getValueLabel(int dimension, float value){
    if (valueLabels[dimension] != null){
        return (String) (valueLabels[dimension].get(new Float(value)));
    }
    else {
        return null;
    }
}","/**
 * Returns the label for a single value in a specific dimension, if present.
 * 
 * @param dimension The dimension.
 * @param value The value to look up a label for.
 *
 * @return A String with the label, null if no label is set.
 */
public String getValueLabel(int dimension, float value) 
{
    if (dimension < 0 || dimension >= valueLabels.length)
        return null;
    return valueLabels[dimension].getLabel(value);
}   ",309,True
"/**
 * Returns the maximum value for the given dimension.
 *
 * @return Maximum value of all records for the given dimension.
 */
public float getMaxValue(int dimension){
    
    float maxval = ((float[])values.firstElement())[dimension];
    for (int i=0; i<values.size(); i++){
        if (((float[])values.elementAt(i))[dimension] > maxval) maxval = ((float[])values.elementAt(i))[dimension];
    }
    
    return maxval;
        
}","/**
 * Returns the maximum value for the given dimension.
 *
 * @return Maximum value of all records for the given dimension.
 */
public float getMaxValue(int dimension) 
{
    float max = -Float.MAX_VALUE;
    for (Record record : records)
    {
        float value = record.getValue(dimension);
        if (value > max)
        {
            max = value;
        }
    }
    return max;
}   ",310,True
"/**
 * Reads the contents of the file and exposes them vis the ParallelSpaceModel
 * interface of the class. String values are stripped out of the model and
 * set as record labels.
 */
public void readContents() throws IOException{
    
    fireProgressEvent(new ProgressEvent(this, ProgressEvent.PROGRESS_START, 0.0f, ""loading file""));

    File f = new File(fileName);
    filesize = (int) f.length();
//        System.out.println(""filesize: "" + filesize);
    
    InputStreamReader in = new InputStreamReader(new FileInputStream(f));
    
    readFirstLine(in);
    readHeaderLines(in);
    readData(in);

    fireProgressEvent(new ProgressEvent(this, ProgressEvent.PROGRESS_FINISH, 1.0f, ""loading file""));

}","/**
 * Reads the contents of the file and exposes them vis the ParallelSpaceModel
 * interface of the class. String values are stripped out of the model and
 * set as record labels.
 */



public void readContents() throws IOException 
{
    BufferedReader reader = new BufferedReader(new FileReader(file));
    String line;
    while ((line = reader.readLine()) != null)
    {
        String[] values = line.split("","");
        List<String> record = new ArrayList<String>();
        for (String value : values)
        {
            record.add(value);
        }
        model.addRecord(record);
    }
    reader.close();
}   ",312,True
"/**
 * Dispatches a ProgressEvent to all listeners.
 *
 * @param e The ProgressEvent to send.
 */
protected void fireProgressEvent(ProgressEvent e){
    Vector list = (Vector)progressListeners.clone();
    for (int i=0; i<list.size(); i++){
        ProgressListener l = (ProgressListener)list.elementAt(i);
        l.processProgressEvent(e);
    }
}","/**
 * Dispatches a ProgressEvent to all listeners.
 *
 * @param e The ProgressEvent to send.
 */
protected void fireProgressEvent(ProgressEvent e) 
{
    if (progressListeners != null)
    {
        for (ProgressListener listener : progressListeners)
        {
            listener.progressChanged(e);
        }
    }
}   ",314,True
"//GEN-LAST:event_binsFieldActionPerformed
private void binWidthActionPerformed(java.awt.event.ActionEvent evt){//GEN-FIRST:event_binWidthActionPerformed
        if (totalRadio.isSelected()) {
            parent.setIntPreference(""histogramWidth"", ParallelDisplay.HISTO_TOTALREC);
        }
        else if (binRadio.isSelected()) {
            parent.setIntPreference(""histogramWidth"", ParallelDisplay.HISTO_BINREC);
        }
        else if (brushedRadio.isSelected()) {
            parent.setIntPreference(""histogramWidth"", ParallelDisplay.HISTO_BRUSHREC);
        }
    }","//GEN-LAST:event_binsFieldActionPerformed
private void binWidthActionPerformed(java.awt.event.ActionEvent evt) 
{//GEN-FIRST:event_binWidthActionPerformed
    if (binWidth.getText().equals(""""))
    {
        binWidth.setText(""0.0"");
    }
}   ",316,False
"/**
 * This method adds a string object to the JSON string.
 * 
 * @param obj String object
 */
protected void string(Object obj){
	// The object is transformed to a string value
    String value = obj.toString();
    // The string is enclosed in parantheses
    add('\""');
    int last = 0;
    int len = value.length();
    // For all the characters in the string
    for(int i = 0; i < len; i++) {
    	
    	// Special characters are encoded
    	// ("", \, whitespace and line change characters)
    	
        char c = value.charAt(i);
        if (c == '""') {
            last = add(value, last, i, ""\\\"""");
        } else if (c == '\\') {
            last = add(value, last, i, ""\\\\"");
        } else if (c == '\b') {
            last = add(value, last, i, ""\\b"");
        } else if (c == '\f') {
            last = add(value, last, i, ""\\f"");
        } else if (c == '\n') {
            last = add(value, last, i, ""\\n"");
        } else if (c == '\r') {
            last = add(value, last, i, ""\\r"");
        } else if (c == '\t') {
            last = add(value, last, i, ""\\t"");
        } else if (Character.isISOControl(c)) {
        	// Any other character is added to the JSON string (as a unicode encoded character)
            last = add(value, last, i) + 1;
            unicode(c);
        }
    }
    // The last character is added to the string
    if(last < value.length()) {
        add(value, last, value.length());
    }
    
    // The string is enclosed in parantheses
    add('\""');
}","/**
 * This method adds a string object to the JSON string.
 * 
 * @param obj String object
 */
protected void string(Object obj) 
{
    quote(obj.toString());
}   ",321,False
"/**
 * This method adds an indent to the JSON string.
 * 
 * @param c Character to add
 */
protected void indent(int amount){
	// The indent is set
    for(int i = 0; i < amount; i++) {
        builder.append("" "");
    }
}","/**
 * This method adds an indent to the JSON string.
 * 
 * @param c Character to add
 */
protected void indent(int amount) 
{
    if (amount > 0)
    {
        for (int i = 0; i < amount; i++)
        {
            sb.append(""  "");
        }
    }
}   ",322,True
"/**
 * This method sets the fields included in serialization. These fields must be in dot notation. 
 * This is just here so that JSONSerializer can be treated like a bean so it will
 * integrate with Spring or other frameworks.
 * @param fields The list of fields to be included for serialization.  The fields arg should be a
 * list of strings in dot notation.
 */
@SuppressWarnings(""unchecked"")
	public void setPathIncludes(List fields){
		// All the path expressions are included
    for (Object field : fields) {
        pathExpressions.add(new PathExpression(field.toString(), true));
    }
}","/**
 * This method sets the fields included in serialization. These fields must be in dot notation. 
 * This is just here so that JSONSerializer can be treated like a bean so it will
 * integrate with Spring or other frameworks.
 * @param fields The list of fields to be included for serialization.  The fields arg should be a
 * list of strings in dot notation.
 */
@SuppressWarnings(""unchecked"")
	public void setPathIncludes(List fields) 
{
	if (fields != null)
	{
		this.pathIncludes = fields;
	}
}	",327,True
"/**
 * This method returns the fields included in serialization. These fields will be in dot notation.
 *
 * @return A List of dot notation fields included in serialization.
 */
public List<PathExpression> getPathIncludes(){
    List<PathExpression> expressions = new ArrayList<PathExpression>();
    // For all the path expressions
    for( PathExpression expression : pathExpressions ) {
    	// If the path is included, it is added to the includes list
        if( expression.isIncluded()) {
            expressions.add(expression);
        }
    }
    return expressions;
}","/**
 * This method returns the fields included in serialization. These fields will be in dot notation.
 *
 * @return A List of dot notation fields included in serialization.
 */
public List<PathExpression> getPathIncludes() 
{
    return pathIncludes;
}   ",330,True
"/**
 * This method adds a path exclude to the path expression list.
 * 
 * @param field The dot notation field to be excluded
 */
private void addPathExclude(Object field){
	// First, the containing object is added to the path includes
    String name = field.toString();
    int index = name.lastIndexOf('.');
    if (index > 0) {
    	// If there is at least one ""."" in the expression, a path include for the containing object is created
        PathExpression expression = new PathExpression(name.substring(0, index), true);
        if(!expression.isWildcard()) {
        	// If the include field is not a wildcard, a  is added to the expression list
            pathExpressions.add(expression);
        }
    }
    
    // The original path expression is added to the path exclude list
    pathExpressions.add(new PathExpression(name, false));
}","/**
 * This method adds a path exclude to the path expression list.
 * 
 * @param field The dot notation field to be excluded
 */

private void addPathExclude(Object field) 
{
    if (pathExcludes == null)
    {
        pathExcludes = new ArrayList<Object>();
    }
    pathExcludes.add(field);
}   ",334,True
"/**
 * This method add a comma to the JSON string.
 * 
 * @param firstField Flag indicating whether the currently active field is the first field before the operation
 * @return Flag indicating whether the currently active field is the first field after the operation
 */
protected boolean addComma(boolean firstField){
	// The comma is inserted if the field is not the first field (otherwise, the firstField value is flipped)
    if (!firstField) {
        add(',');
    } else {
        firstField = false;
    }
    return firstField;
}","/**
 * This method add a comma to the JSON string.
 * 
 * @param firstField Flag indicating whether the currently active field is the first field before the operation
 * @return Flag indicating whether the currently active field is the first field after the operation
 */
protected boolean addComma(boolean firstField) 
{
    if (!firstField)
    {
        json.append("","");
    }
    return false;
}   ",335,True
"/**
 * This method adds a part of a string object to the current JSON string.
 * 
 * @param value JSON string value
 * @param begin Index of the character to start with
 * @param end Index of the character to end with
 * @param append Additionally appended string value
 * @return Index of the character to end with
 */
protected int add(String value, int begin, int end, String append){
	// The string and the appended string is added to the string builder
    builder.append(value, begin, end);
    builder.append(append);
    // The new end index value is returned
    return end + 1;
}","/**
 * This method adds a part of a string object to the current JSON string.
 * 
 * @param value JSON string value
 * @param begin Index of the character to start with
 * @param end Index of the character to end with
 * @param append Additionally appended string value
 * @return Index of the character to end with
 */
protected int add(String value, int begin, int end, String append) 
{
    if (value == null)
    {
        return end;
    }

    if (append != null)
    {
        buffer.append(append);
    }

    buffer.append(value, begin, end);

    return end;
}   ",336,True
"/**
 * This method adds a unicode character to the JSON string.
 * 
 * @param c Character to be encoded
 */
protected void unicode(char c){
	// The character is unicode encoded and added to the JSON string
    add(""\\u"");
    int n = c;
    for (int i = 0; i < 4; ++i) {
        int digit = (n & 0xf000) >> 12;
        add(ObjectVisitor.HEX[digit]);
        n <<= 4;
    }
}","/**
 * This method adds a unicode character to the JSON string.
 * 
 * @param c Character to be encoded
 */
protected void unicode(char c) 
{
    out.write(""\\u"");
    String hex = Integer.toHexString(c);
    for (int j = 0; j < 4 - hex.length(); j++)
    {
        out.write('0');
    }
    out.write(hex);
}   ",338,True
"/** Gets be called on the following structure:
 * <tag>characters</tag> */
@Override
	public void characters(char ch[], int start, int length){
	String a = new String(ch, start, length);
	a = a.replaceAll(""\\n"", """");
	a = a.replaceAll(""\\r"", """");
	a = a.replaceAll(""\\t"", """");
	// If the object is not initialized because of junk data in the xml like the xml starting tag and so
	if (currentVersion != null && currentVersion.ChangeLogText != null && a != """")
		currentVersion.ChangeLogText.add(a);
}","/** Gets be called on the following structure:
 * <tag>characters</tag> */
@Override
	public void characters(char ch[], int start, int length) 
{
    if (inElement) {
        String value = new String(ch, start, length);
        if (value.trim().length() > 0)
            elementValue = value;
    }
}	",342,False
"// Insert a new Screenshot
public long insertScreenshot(Screenshot _screenshot){
	
	ContentValues newValues = new ContentValues();
	newValues.put(KEY_SCREENSHOT_THEMELIST_ID, _screenshot.ForeignThemeListKey);
	newValues.put(KEY_SCREENSHOT_URI, _screenshot.url.toString());
	newValues.put(KEY_SCREENSHOT_MODIFYDATE, _screenshot.getModifyDate());
	newValues.put(KEY_SCREENSHOT_SCREENSHOT, _screenshot.getPictureAsByteArray());
	return db.insert(DATABASE_TABLE_SCREENSHOT, null, newValues);
}","// Insert a new Screenshot










public long insertScreenshot(Screenshot _screenshot) 
{
    long id = -1;
    Connection con = null;
    PreparedStatement ps = null;
    ResultSet rs = null;
    try
    {
        con = getConnection();
        String query = ""INSERT INTO screenshot (screenshot, created_at) VALUES (?, ?)"";
        ps = con.prepareStatement(query, Statement.RETURN_GENERATED_KEYS);
        ps.setBytes(1, _screenshot.getScreenshot());
        ps.setTimestamp(2, new Timestamp(_screenshot.getCreatedAt().getTime()));
        ps.executeUpdate();
        rs = ps.getGeneratedKeys();
        if (rs.next())
        {
            id = rs.getLong(1);
        }
    }
    catch (SQLException ex)
    {
        Logger.getLogger(ScreenshotDAO.class.getName()).log(Level.SEVERE, null, ex);
    }
    finally
    {
        closeConnection(con, ps, rs);
    }
    return id;
}   ",344,False
"/** Gets be called on opening tags like:
 * <tag>
 * Can provide attribute(s), when xml was like:
 * <tag attribute=""attributeValue"">*/
public void startElement(String namespaceURI, String localName, String qName, Attributes atts) throws SAXException{
     if (localName.equalsIgnoreCase(Constants.VERSION_TAG))
     {
    	 //New Version. Start a new Object
    	 currentVersion = new Version();
         currentVersion.Version = atts.getValue(Constants.VERSION_NAME_TAG);
     }
}","/** Gets be called on opening tags like:
 * <tag>
 * Can provide attribute(s), when xml was like:
 * <tag attribute=""attributeValue"">*/
public void startElement(String namespaceURI, String localName, String qName, Attributes atts) throws SAXException 
{
    if (localName.equals(""tag""))
    {
        String attribute = atts.getValue(""attribute"");
        // do something with attribute
    }
}   ",345,True
"//Checks if a Screenshot already exists. Cause the Primary Key is Stored in the Screenshot Object
//The contains() Method will not work cause theres no Primary Key on Download
//Will return a Screenshotobject with only the PrimaryKey if found, otherwise -1,the Modifydate and the blob
public Screenshot ScreenshotExists(int ForeignKey, String Url) throws SQLException{
	Screenshot retValue = new Screenshot();
	Cursor cursor = db.query(true, DATABASE_TABLE_SCREENSHOT,
			new String[]
			           {
						KEY_SCREENSHOT_ID,
						KEY_SCREENSHOT_THEMELIST_ID,
						KEY_SCREENSHOT_URI,
						KEY_SCREENSHOT_MODIFYDATE,
						KEY_SCREENSHOT_SCREENSHOT
			           }, KEY_SCREENSHOT_THEMELIST_ID + ""= ? AND "" +
			           KEY_SCREENSHOT_URI + ""= ?"",
			           new String[]{ Integer.toString(ForeignKey), Url }, null, null, null, null);
	if ((cursor.getCount() != 0) && cursor.moveToFirst())
	{
		retValue.PrimaryKey = cursor.getInt(COLUMN_SCREENSHOT_ID);
		retValue.ForeignThemeListKey = cursor.getInt(COLUMN_SCREENSHOT_THEMELIST_ID);
		retValue.url = URI.create(cursor.getString(COLUMN_SCREENSHOT_URI));
		retValue.setModifyDate(cursor.getString(COLUMN_SCREENSHOT_MODIFYDATE));
		retValue.setBitmapFromByteArray(cursor.getBlob(COLUMN_SCREENSHOT_SCREENSHOT));
	}
	cursor.close();
	return retValue;
}","//Checks if a Screenshot already exists. Cause the Primary Key is Stored in the Screenshot Object
//The contains() Method will not work cause theres no Primary Key on Download
//Will return a Screenshotobject with only the PrimaryKey if found, otherwise -1,the Modifydate and the blob
public Screenshot ScreenshotExists(int ForeignKey, String Url) throws SQLException 
{
    Screenshot screenshot = new Screenshot();
    screenshot.setForeignKey(ForeignKey);
    screenshot.setUrl(Url);
    if (this.ScreenshotExists(screenshot))
    {
        return screenshot;
    }
    else
    {
        return null;
    }
}   ",346,True
"//Get single Screenshots by Id
public Screenshot getScreenshotById(long _index) throws SQLException{
	Cursor cursor = db.query(true, DATABASE_TABLE_SCREENSHOT,
			new String[]
			           {
						KEY_SCREENSHOT_ID,
						KEY_SCREENSHOT_THEMELIST_ID,
						KEY_SCREENSHOT_URI,
						KEY_SCREENSHOT_MODIFYDATE,
						KEY_SCREENSHOT_SCREENSHOT
			           }, KEY_SCREENSHOT_ID + ""= ?"", new String[]{ Long.toString(_index) }, null, null, null, null);
	if ((cursor.getCount() == 0) || !cursor.moveToFirst())
	{
		cursor.close();
		throw new SQLException(""No Screenshot found for Key: "" + _index);
	}

	Screenshot result = new Screenshot();
	result.PrimaryKey = cursor.getInt(COLUMN_SCREENSHOT_ID);
	result.ForeignThemeListKey = cursor.getInt(COLUMN_SCREENSHOT_THEMELIST_ID);
	result.url = URI.create(cursor.getString(COLUMN_SCREENSHOT_URI));
	result.setModifyDate(cursor.getString(COLUMN_SCREENSHOT_MODIFYDATE));
	result.setBitmapFromByteArray(cursor.getBlob(COLUMN_SCREENSHOT_SCREENSHOT));
	cursor.close();
	return result;
}","//Get single Screenshots by Id

public Screenshot getScreenshotById(long _index) throws SQLException 
{
    ResultSet result = this.data.query(""*"", ""SCREENSHOTS"", ""ID = "" + _index);
    if(result.first())
    {
        Screenshot screenshot = new Screenshot(result.getLong(""ID""), result.getLong(""GAME_ID""), result.getString(""IMAGE""));
        return screenshot;
    }
    return null;
}   ",347,False
"/**
 * Checks if there is enough Space on SDCard
 * 
 * @param UpdateSize
 *            Size to Check
 * @return True if the Update will fit on SDCard, false if not enough space on SDCard
 * 		Will also return false, if the SDCard is not mounted as read/write
 */
public static boolean EnoughSpaceOnSdCard(long UpdateSize){
	String status = Environment.getExternalStorageState();
	if (!status.equals(Environment.MEDIA_MOUNTED))
		return false;
	File path = Environment.getExternalStorageDirectory();
        StatFs stat = new StatFs(path.getPath());
        long blockSize = stat.getBlockSize();
        long availableBlocks = stat.getAvailableBlocks();
        return (UpdateSize < availableBlocks * blockSize);
}","/**
 * Checks if there is enough Space on SDCard
 * 
 * @param UpdateSize
 *            Size to Check
 * @return True if the Update will fit on SDCard, false if not enough space on SDCard
 * 		Will also return false, if the SDCard is not mounted as read/write
 */


public static boolean EnoughSpaceOnSdCard(long UpdateSize) 
{
    boolean ret = false;
    StatFs stat = new StatFs(Environment.getExternalStorageDirectory().getPath());
    long blockSize = stat.getBlockSize();
    long availableBlocks = stat.getAvailableBlocks();
    if (availableBlocks > 0)
    {
        if (UpdateSize < (availableBlocks * blockSize))
        {
            ret = true;
        }
    }
    return ret;
}   ",350,True
"// Remove all Screenshots for given Theme except the ones in the parameter
public boolean removeScreenshotExcept(int ForeignKey, String[] primaryKeysNotToRemove){
	if (primaryKeysNotToRemove == null || primaryKeysNotToRemove.length == 0)
		return false;
	String temp = StringUtils.arrayToString(primaryKeysNotToRemove, "","");
	return db.delete(DATABASE_TABLE_SCREENSHOT, KEY_SCREENSHOT_THEMELIST_ID + ""= ? AND ""
			+ KEY_SCREENSHOT_ID + "" not in (?)"", new String[]{ Integer.toString(ForeignKey), temp }) > 0;
}","// Remove all Screenshots for given Theme except the ones in the parameter






public boolean removeScreenshotExcept(int ForeignKey, String[] primaryKeysNotToRemove) 
{
    boolean success = false;
    try
    {
        List<String> primaryKeys = new ArrayList<String>();
        for (int i = 0; i < primaryKeysNotToRemove.length; i++)
        {
            primaryKeys.add(primaryKeysNotToRemove[i]);
        }
        List<Screenshot> screenshots = this.getScreenshots(ForeignKey);
        for (int i = 0; i < screenshots.size(); i++)
        {
            if (!primaryKeys.contains(screenshots.get(i).getPrimaryKey()))
            {
                this.removeScreenshot(screenshots.get(i).getPrimaryKey());
            }
        }
        success = true;
    }
    catch (Exception e)
    {
        e.printStackTrace();
    }
    return success;
}   ",356,False
"// Enable all Themes
public boolean enableAllThemes(){
	ContentValues newValue = new ContentValues();
	newValue.put(KEY_THEMELIST_ENABLED, 1);
	return db.update(DATABASE_TABLE_THEMELIST, newValue, null, null) > 0;
}","// Enable all Themes
public boolean enableAllThemes() 
{
    boolean result = true;
    for (Theme theme : themes)
    {
        if (!theme.isEnabled())
        {
            result = result && enableTheme(theme);
        }
    }
    return result;
}   ",357,False
"// Insert a new Theme
public long insertTheme(ThemeList _theme){
	ContentValues newValues = new ContentValues();
	newValues.put(KEY_THEMELIST_NAME, _theme.name);
	newValues.put(KEY_THEMELIST_URI, _theme.url.toString());
	if(_theme.enabled) newValues.put(KEY_THEMELIST_ENABLED, 1);
	else newValues.put(KEY_THEMELIST_ENABLED, 0);
	if(_theme.featured) newValues.put(KEY_THEMELIST_FEATURED, 1);
	else newValues.put(KEY_THEMELIST_FEATURED, 0);
	return db.insert(DATABASE_TABLE_THEMELIST, null, newValues);
}","// Insert a new Theme
public long insertTheme(ThemeList _theme) 
{
    long id = -1;
    try
    {
        id = themeDao.insert(_theme);
    }
    catch (SQLException e)
    {
        e.printStackTrace();
    }
    return id;
}   ",359,False
"/**
 * Loads the resource resourceName and returns a set of strings such that each line in the input resource becomes an entry of the set.
 * 
 * @param resourceName
 * @return each line from the loaded resource becomes a string in the returned array
 * @throws IOException
 *             if the resource cannot be found
 */
protected Set<String> getStrings(String resourceName) throws IOException{
    Set<String> strings=new HashSet<String>();
    BufferedReader reader=new BufferedReader(new InputStreamReader(getClass().getResource(resourceName).openStream()));
    try {
        String line=reader.readLine();
        while (line!=null) {
            strings.add(line);
            line=reader.readLine();
        }
    }
    finally {
        reader.close();
    }
    return strings;
}","/**
 * Loads the resource resourceName and returns a set of strings such that each line in the input resource becomes an entry of the set.
 * 
 * @param resourceName
 * @return each line from the loaded resource becomes a string in the returned array
 * @throws IOException
 *             if the resource cannot be found
 */





protected Set<String> getStrings(String resourceName) throws IOException 
{
    Set<String> result = new HashSet<String>();
    BufferedReader reader = new BufferedReader(new InputStreamReader(getClass().getResourceAsStream(resourceName)));
    String line;
    while ((line = reader.readLine()) != null)
    {
        result.add(line);
    }
    reader.close();
    return result;
}   ",360,True
"/**
 * Tests whether the atomic concept subAtomicConcept is subsumed by the atomic concept superAtomicConcept and asserts that this coincides with the expected result.
 * 
 * @param subAtomicConcept
 *            a string that represents an atomic concept. If no namespace is given, file:/c/test.owl# is used as prefix
 * @param superAtomicConcept
 *            a string that represents an atomic concept. If no namespace is given, file:/c/test.owl# is used as prefix
 * @param expectedResult
 */
protected void assertSubsumedBy(String subAtomicConcept,String superAtomicConcept,boolean expectedResult){
    if (!subAtomicConcept.contains(""#""))
        subAtomicConcept=""file:/c/test.owl#""+subAtomicConcept;
    if (!superAtomicConcept.contains(""#""))
        superAtomicConcept=""file:/c/test.owl#""+superAtomicConcept;
    boolean result=m_reasoner.isClassSubsumedBy(subAtomicConcept,superAtomicConcept);
    assertEquals(expectedResult,result);
}","/**
 * Tests whether the atomic concept subAtomicConcept is subsumed by the atomic concept superAtomicConcept and asserts that this coincides with the expected result.
 * 
 * @param subAtomicConcept
 *            a string that represents an atomic concept. If no namespace is given, file:/c/test.owl# is used as prefix
 * @param superAtomicConcept
 *            a string that represents an atomic concept. If no namespace is given, file:/c/test.owl# is used as prefix
 * @param expectedResult
 */

protected void assertSubsumedBy(String subAtomicConcept,String superAtomicConcept,boolean expectedResult) 
{
    OWLDataFactory factory = manager.getOWLDataFactory();
    OWLClass subClass = factory.getOWLClass(IRI.create(defaultPrefix + subAtomicConcept));
    OWLClass superClass = factory.getOWLClass(IRI.create(defaultPrefix + superAtomicConcept));
    boolean isSubsumed = reasoner.isSubClassOf(subClass, superClass);
    assertEquals(expectedResult, isSubsumed);
}   ",362,False
"/**
 * Loads the resource resourceName and returns its content as a string.
 * 
 * @param resourceName
 * @return the content of the loaded resource as one string
 * @throws IOException
 *             if the resource cannot be found
 */
protected String getResourceText(String resourceName) throws IOException{
    CharArrayWriter buffer=new CharArrayWriter();
    PrintWriter output=new PrintWriter(buffer);
    BufferedReader reader=new BufferedReader(new InputStreamReader(getClass().getResource(resourceName).openStream()));
    try {
        String line=reader.readLine();
        while (line!=null) {
            output.println(line);
            line=reader.readLine();
        }
    }
    finally {
        reader.close();
    }
    output.flush();
    return buffer.toString();
}","/**
 * Loads the resource resourceName and returns its content as a string.
 * 
 * @param resourceName
 * @return the content of the loaded resource as one string
 * @throws IOException
 *             if the resource cannot be found
 */
protected String getResourceText(String resourceName) throws IOException 
{
    InputStream in = null;
    try
    {
        in = getClass().getResourceAsStream(resourceName);
        if (in == null)
        {
            return null;
        }
        return IOUtils.stringFromInputStream(in);
    }
    finally
    {
        IOUtils.close(in);
    }
}   ",364,False
"/**
 * Create a restriction for an unknown datatypes that can be interpreted as anything. 
 * @param datatype should be DT.UNKNOWN
 */
public DatatypeRestrictionUnknown(DT datatype){
    this.datatype = datatype;
    this.supportedFacets = new HashSet<Facet>();
}","/**
 * Create a restriction for an unknown datatypes that can be interpreted as anything. 
 * @param datatype should be DT.UNKNOWN
 */
public DatatypeRestrictionUnknown(DT datatype) 
{
    super(datatype);
    this.datatype = datatype;
}   ",365,True
"/* (non-Javadoc)
 * @see org.semanticweb.HermiT.model.dataranges.DataRange#addFacet(org.semanticweb.HermiT.model.dataranges.DatatypeRestriction.Facets, java.lang.String)
 */
public void addFacet(Facet facet, String value){
    throw new IllegalArgumentException(""Facets are not supported for "" +
                    ""unknown datatypes."");
}","/* (non-Javadoc)
 * @see org.semanticweb.HermiT.model.dataranges.DataRange#addFacet(org.semanticweb.HermiT.model.dataranges.DatatypeRestriction.Facets, java.lang.String)
 */
public void addFacet(Facet facet, String value) 
{
	if (facet == Facet.LENGTH)
	{
		length = Integer.parseInt(value);
	}
	else if (facet == Facet.MAXLENGTH)
	{
		maxLength = Integer.parseInt(value);
	}
	else if (facet == Facet.MINLENGTH)
	{
		minLength = Integer.parseInt(value);
	}
	else if (facet == Facet.PATTERN)
	{
		pattern = value;
	}
	else
	{
		throw new IllegalArgumentException(""Invalid facet: "" + facet);
	}
}   ",367,True
"/**
 * Prints a text representation for the description graph given as an argument. 
 */
public void execute(){
    if (args.length<2) {
        debugger.getOutput().println(""Graph name is missing."");
        return;
    }
    String graphName=args[1];
    for (DescriptionGraph descriptionGraph : debugger.getTableau().getDLOntology().getAllDescriptionGraphs())
        if (descriptionGraph.getName().equals(graphName)) {
            CharArrayWriter buffer=new CharArrayWriter();
            PrintWriter writer=new PrintWriter(buffer);
            writer.println(""==========================================="");
            writer.println(""    Contents of the graph '""+graphName+""'"");
            writer.println(""==========================================="");
            writer.println(descriptionGraph.getTextRepresentation());
            writer.flush();
            showTextInWindow(buffer.toString(),""Contents of the graph '""+graphName+""'"");
            selectConsoleWindow();
            return;
        }
    debugger.getOutput().println(""Graph '""+graphName+""' not found."");
}","/**
 * Prints a text representation for the description graph given as an argument. 
 */
public void execute() 
{
    if (this.descriptionGraph == null)
    {
        System.out.println(""No description graph has been specified."");
        return;
    }

    System.out.println(this.descriptionGraph.toString());
}   ",370,False
"/**
 * Loads the ontology from ontologyResource and the string in controlResource and compares the computed taxonomy for the ontology with the one in the controlResource by comparing the sorted ancestor list.
 * 
 * @param ontologyResource
 *            the ontology
 * @param controlResource
 *            the expected taxonomy (sorted ancestor list)
 * @throws URISyntaxException
 *             if the resources cannot be converted to URIs
 * @throws OWLException
 *             if the ontology is invalid
 * @throws LoadingException
 *             if an error occurs during loading
 * @throws IllegalArgumentException
 *             in case of illegal arguments
 * @throws IOException
 *             if the controlString cannot be loaded
 */
protected void assertSubsumptionHierarchy(String controlResource) throws Exception{
    String taxonomy=getSubsumptionHierarchyAsText();
    String controlString=getResourceText(controlResource);
    assertEquals(taxonomy,controlString);
}","/**
 * Loads the ontology from ontologyResource and the string in controlResource and compares the computed taxonomy for the ontology with the one in the controlResource by comparing the sorted ancestor list.
 * 
 * @param ontologyResource
 *            the ontology
 * @param controlResource
 *            the expected taxonomy (sorted ancestor list)
 * @throws URISyntaxException
 *             if the resources cannot be converted to URIs
 * @throws OWLException
 *             if the ontology is invalid
 * @throws LoadingException
 *             if an error occurs during loading
 * @throws IllegalArgumentException
 *             in case of illegal arguments
 * @throws IOException
 *             if the controlString cannot be loaded
 */
protected void assertSubsumptionHierarchy(String controlResource) throws Exception 
{
    OWLOntology ontology = loadOntology(ontologyResource);
    String controlString = loadControlString(controlResource);
    assertSubsumptionHierarchy(ontology, controlString);
}   ",371,True
"/**
 * Creates a decimal interval. 
 * @param min the lower bound
 * @param max the upper bound
 * @param openMin if true then the interval excludes the lower bound 
 *                otherwise it includes the lower bound
 * @param openMax if true then the interval excludes the upper bound 
 *                otherwise it includes the upper bound
 */
public DecimalInterval(BigDecimal min, BigDecimal max, 
        boolean openMin, boolean openMax){
    this.min = min;
    this.max = max;
    this.openMin = openMin;
    this.openMax = openMax;
}","/**
 * Creates a decimal interval. 
 * @param min the lower bound
 * @param max the upper bound
 * @param openMin if true then the interval excludes the lower bound 
 *                otherwise it includes the lower bound
 * @param openMax if true then the interval excludes the upper bound 
 *                otherwise it includes the upper bound
 */
public DecimalInterval(BigDecimal min, BigDecimal max, 
        boolean openMin, boolean openMax) 
{
    this.min = min;
    this.max = max;
    this.openMin = openMin;
    this.openMax = openMax;
}       ",374,True
"/* (non-Javadoc)
 * @see org.semanticweb.HermiT.model.dataranges.CanonicalDataRange#getSmallestAssignment()
 */
public DataConstant getSmallestAssignment(){ 
    if (!oneOf.isEmpty()) {
        SortedSet<DataConstant> sortedOneOfs = new TreeSet<DataConstant>(oneOf);
        return sortedOneOfs.first();
    }
    return null;
}","/* (non-Javadoc)
 * @see org.semanticweb.HermiT.model.dataranges.CanonicalDataRange#getSmallestAssignment()
 */
public DataConstant getSmallestAssignment() 
{
    if (this.dataRange instanceof CanonicalDataRange)
        return ((CanonicalDataRange)this.dataRange).getSmallestAssignment();
    else
        return null;
}   ",375,False
"/**
 * Tests whether the possibly complex concept subConcept is subsumed by the possibly complex concept superConcept and asserts that this coincides with the expected result.
 * 
 * @param subConcept
 * @param superConcept
 * @param expectedResult
 */
protected void assertSubsumedBy(OWLDescription subConcept,OWLDescription superConcept,boolean expectedResult){
    boolean result=m_reasoner.isClassSubsumedBy(subConcept,superConcept);
    assertEquals(expectedResult,result);
}","/**
 * Tests whether the possibly complex concept subConcept is subsumed by the possibly complex concept superConcept and asserts that this coincides with the expected result.
 * 
 * @param subConcept
 * @param superConcept
 * @param expectedResult
 */
protected void assertSubsumedBy(OWLDescription subConcept,OWLDescription superConcept,boolean expectedResult) 
{
    boolean result = subConcept.isSubsumedBy(superConcept);
    assertEquals(expectedResult, result);
}   ",376,True
"/* (non-Javadoc)
 * @see org.semanticweb.HermiT.model.dataranges.CanonicalDataRange#hasMinCardinality(java.math.BigInteger)
 */
public boolean hasMinCardinality(BigInteger n){
    if (!oneOf.isEmpty()) {
        return (new BigInteger("""" + oneOf.size()).compareTo(n) >= 0);
    }
    return true;
}","/* (non-Javadoc)
 * @see org.semanticweb.HermiT.model.dataranges.CanonicalDataRange#hasMinCardinality(java.math.BigInteger)
 */
public boolean hasMinCardinality(BigInteger n) 
{
    if (n.compareTo(minCardinality) < 0)
        return false;
    return true;
}   ",377,True
"/**
 * Intersect with the given interval. After the intersection, this interval 
 * will have min and max values that are those of the intersection and the 
 * open/closed values are adapted accordingly. 
 * @param i an interval
 */
public void intersectWith(DecimalInterval i){
    if (max == null) {
        max = i.getMax();
        openMax = i.isOpenMax();
    } else {
        if (i.getMax() != null) {
            // both not null
            if (i.getMax().compareTo(max) == 0 && !i.isOpenMax()) {
                openMax = false;
            } else if (i.getMax().compareTo(max) < 0) {
                max = i.getMax();
                openMax = i.isOpenMax();
            }
        }
    }
    if (min == null) {
        min = i.getMin();
        openMin = i.isOpenMin();
    } else {
        if (i.getMin() != null) {
            // both not null
            if (i.getMin().compareTo(min) == 0 && !i.isOpenMin()) {
                openMin = false;
            } else if (i.getMin().compareTo(min) > 0) {
                min = i.getMin();
                openMin = i.isOpenMin();
            }
        }
    }
}","/**
 * Intersect with the given interval. After the intersection, this interval 
 * will have min and max values that are those of the intersection and the 
 * open/closed values are adapted accordingly. 
 * @param i an interval
 */
public void intersectWith(DecimalInterval i) 
{
    if (i.min.compareTo(min) > 0)
    {
        min = i.min;
        minOpen = i.minOpen;
    }
    if (i.max.compareTo(max) < 0)
    {
        max = i.max;
        maxOpen = i.maxOpen;
    }
}   ",378,True
"/**
 * creates and loads an ontology that contains the given axioms
 * 
 * @param configuration
 *            a configuration for the reasoner instance
 * @param axioms
 *            in functional style syntax
 * @param keys
 *            a set of key axioms (till the OWL API supports them)
 * @throws OWLOntologyCreationException
 *             if the ontology could not be created
 */
protected void loadOntologyWithAxiomsAndKeys(Configuration configuration,String axioms,Set<OWLHasKeyDummy> keys) throws OWLOntologyCreationException{
    StringBuffer buffer=new StringBuffer();
    buffer.append(""Namespace(=<file:/c/test.owl#>)"");
    buffer.append(""Namespace(rdfs=<http://www.w3.org/2000/01/rdf-schema#>)"");
    buffer.append(""Namespace(owl2xml=<http://www.w3.org/2006/12/owl2-xml#>)"");
    buffer.append(""Namespace(test=<file:/c/test.owl#>)"");
    buffer.append(""Namespace(owl=<http://www.w3.org/2002/07/owl#>)"");
    buffer.append(""Namespace(xsd=<http://www.w3.org/2001/XMLSchema#>)"");
    buffer.append(""Namespace(rdf=<http://www.w3.org/1999/02/22-rdf-syntax-ns#>)"");
    buffer.append(""Ontology(<file:/c/test.owl>"");
    buffer.append(axioms);
    buffer.append("")"");
    OWLOntologyInputSource input=new StringInputSource(buffer.toString());
    m_ontology=m_ontologyManager.loadOntology(input);
    m_reasoner=new Reasoner(configuration,m_ontologyManager,m_ontology,null,keys);
}","/**
 * creates and loads an ontology that contains the given axioms
 * 
 * @param configuration
 *            a configuration for the reasoner instance
 * @param axioms
 *            in functional style syntax
 * @param keys
 *            a set of key axioms (till the OWL API supports them)
 * @throws OWLOntologyCreationException
 *             if the ontology could not be created
 */




protected void loadOntologyWithAxiomsAndKeys(Configuration configuration,String axioms,Set<OWLHasKeyDummy> keys) throws OWLOntologyCreationException 
{
    OWLOntologyManager manager = OWLManager.createOWLOntologyManager();
    OWLDataFactory factory = manager.getOWLDataFactory();
    OWLOntology ontology = loadOntologyWithAxiomsAndKeys(manager, factory, configuration, axioms, keys);
    setOntology(ontology);
}   ",379,False
"/**
 * Creates an arbitrary array, whose contents are arbitrary objects. There
 * is a 10% chance that a zero-length array will be returned. Otherwise,
 * the array with have a length between 1 and 10, inclusive. The arbitraryT
 * type must implement an arbitrary() method.
 * <p>
 * An example, where Point2D also implements arbitrary():
 * <pre>public static PointSet arbitrary(Gen gen) {
 *     return new PointSet.fromArray(arbArray(Point2D.class))
 * }</pre>
 * 
 * Be careful of circular dependency. If an arbitrary() definition in class
 * A calls this method, passing class A, then infinite recursion will occur.
 * 
 * @return an arbitrary object array
 */
@SuppressWarnings(""unchecked"")
public <A> A[] arbArray(Class<A> arbitraryT){
    switch (select(0.1f, 0.9f)) {
    case 0:
        return (A[]) Array.newInstance(arbitraryT, 0);
    case 1: default:
    	int maxLength = getParams().getInt(PARAM_MAX_ARRAY_LENGTH,
    			                           MAX_ARRAY_LENGTH_DEFAULT);
        A[] ary = (A[]) Array.newInstance(arbitraryT, choose(1, maxLength));
        for (int idx=0; idx<ary.length; idx++) {
            ary[idx] = (A) createArbitraryFor(arbitraryT);
        }
        return ary;
    }
}","/**
 * Creates an arbitrary array, whose contents are arbitrary objects. There
 * is a 10% chance that a zero-length array will be returned. Otherwise,
 * the array with have a length between 1 and 10, inclusive. The arbitraryT
 * type must implement an arbitrary() method.
 * <p>
 * An example, where Point2D also implements arbitrary():
 * <pre>public static PointSet arbitrary(Gen gen) {
 *     return new PointSet.fromArray(arbArray(Point2D.class))
 * }</pre>
 * 
 * Be careful of circular dependency. If an arbitrary() definition in class
 * A calls this method, passing class A, then infinite recursion will occur.
 * 
 * @return an arbitrary object array
 */

@SuppressWarnings(""unchecked"")
public <A> A[] arbArray(Class<A> arbitraryT) 
{
    A[] array;
    if (gen.nextBoolean(0.1)) {
        array = (A[]) Array.newInstance(arbitraryT, 0);
    } else {
        int length = gen.nextInt(1, 10);
        array = (A[]) Array.newInstance(arbitraryT, length);
        for (int i = 0; i < length; i++) {
            array[i] = arbitrary(arbitraryT);
        }
    }
    return array;
}   ",381,True
"/** 
 * Answers a random value from `from` to `to`, inclusive both  sides. Each 
 * integer in the range has an equal chance of being chosen.
 * <p>
 * An example:
 * <pre>switch (choose(1, 4)) {
 *     case 1:
 *         return new Square.createWithin(Circle.arbitrary());
 *     case 2:
 *         return new Circle(gen.arbInt(), gen.arbInt(), gen.arbInt());
 *     case 3:
 *         return new Triangle.createWithin(Circle.arbitrary());
 *     case 4: default:
 *         return new Line(gen.arbInt(), gen.arbInt());
 * }</pre>
 * 
 * @return an int in the range [from, to]
 */
public int choose(int from, int to){
    if (from == to) return from;
    
    return random.nextInt(to - from + 1) + from;
}","/** 
 * Answers a random value from `from` to `to`, inclusive both  sides. Each 
 * integer in the range has an equal chance of being chosen.
 * <p>
 * An example:
 * <pre>switch (choose(1, 4)) {
 *     case 1:
 *         return new Square.createWithin(Circle.arbitrary());
 *     case 2:
 *         return new Circle(gen.arbInt(), gen.arbInt(), gen.arbInt());
 *     case 3:
 *         return new Triangle.createWithin(Circle.arbitrary());
 *     case 4: default:
 *         return new Line(gen.arbInt(), gen.arbInt());
 * }</pre>
 * 
 * @return an int in the range [from, to]
 */
public int choose(int from, int to) 
{
    return from + (int) (Math.random() * (to - from + 1));
}   ",383,True
"/**
 * Run arbitrary data through all the properties defined in a single class.
 * Any method in the class ""invariants"" whose simple name begins with the
 * prefix ""prop_"" will be considered as a test property, and will be executed
 * with arbitrary data, ""timesForEach"" times.
 */
public void runOn(Class<?> invariants, int timesForEach) throws TestException{
    for (Method m : invariants.getMethods()) {
        if (m.getName().startsWith(""prop_"")) {
            runOn(m, timesForEach);
        }
    }
}","/**
 * Run arbitrary data through all the properties defined in a single class.
 * Any method in the class ""invariants"" whose simple name begins with the
 * prefix ""prop_"" will be considered as a test property, and will be executed
 * with arbitrary data, ""timesForEach"" times.
 */



public void runOn(Class<?> invariants, int timesForEach) throws TestException 
{
    for (Method m : invariants.getMethods())
    {
        if (m.getName().startsWith(""prop_""))
        {
            for (int i = 0; i < timesForEach; i++)
            {
                try
                {
                    m.invoke(this);
                }
                catch (IllegalAccessException | InvocationTargetException e)
                {
                    throw new TestException(e);
                }
            }
        }
    }
}   ",384,True
"/**
 * Answers an arbitrary string, with an inflated probability of returning
 * an empty string. Generated strings have a maximum length of 1024 characters.
 * Characters within the string will all be on the latin-1 page.
 * 
 * @return an arbitrary string
 */
public String arbString(){
    switch (select(0.2f, 0.8f)) {
    case 0:
        return """";
    case 1: default:
    	int maxLength = getParams().getInt(PARAM_MAX_STR_LENGTH,
    			                           MAX_STR_LENGTH_DEFAULT);
        char[] cs = new char[choose(1, maxLength)];
        for (int idx=0; idx<cs.length; idx++) {
            cs[idx] = (char) random.nextInt(256); // inline of arbChar()
        }
        return new String(cs);
    }
}","/**
 * Answers an arbitrary string, with an inflated probability of returning
 * an empty string. Generated strings have a maximum length of 1024 characters.
 * Characters within the string will all be on the latin-1 page.
 * 
 * @return an arbitrary string
 */
public String arbString() 
{
    int length = (int) (Math.random() * 1024);
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < length; i++)
    {
        sb.append((char) (Math.random() * 256));
    }
    return sb.toString();
}   ",386,True
"/**
 * Answers an arbitrary byte.  Like with {@link #arbInt()}, the values 
 * MAX_VALUE, MIN_VALUE, 0, -1 and 1 have a hightened chance of selection.
 * 
 * @return an arbitrary byte
 */
public byte arbByte(){
    switch (select(0.05f, 0.05f, 0.05f, 0.05f, 0.05f, 0.75f)) {
    case 0:
        return 0;
    case 1:
        return Byte.MAX_VALUE;
    case 2:
        return Byte.MIN_VALUE;
    case 3:
        return -1;
    case 4:
        return 1;
    case 5: default:
        return (byte) random.nextInt();
    }
}","/**
 * Answers an arbitrary byte.  Like with {@link #arbInt()}, the values 
 * MAX_VALUE, MIN_VALUE, 0, -1 and 1 have a hightened chance of selection.
 * 
 * @return an arbitrary byte
 */
public byte arbByte() 
{
    return (byte) arbInt(Byte.MAX_VALUE, Byte.MIN_VALUE, 0, -1, 1).intValue();
}   ",387,True
"/** 
 * Answers an arbitrary float. Like with {@link #arbInt()}, the  values NaN, 
 * POSITIVE_INFINITY, NEGATIVE_INFINITY, MAX_VALUE, MIN_VALUE and 0.0f (though 
 * not -1 and 1) have a hightened chance of selection.
 * 
 * @return an arbitrary float
 */
public float arbNastyFloat(){
    switch (select(0.05f, 0.05f, 0.05f, 0.05f, 0.05f, 0.05f, 0.7f)) {
    case 0:
        return Float.NaN;
    case 1:
        return Float.POSITIVE_INFINITY;
    case 2:
        return Float.NEGATIVE_INFINITY;
    case 3:
        return Float.MAX_VALUE;
    case 4:
        return Float.MIN_VALUE;
    case 5:
        return 0.0f;
    case 6: default:
        return random.nextFloat() + random.nextInt();
    }
}","/** 
 * Answers an arbitrary float. Like with {@link #arbInt()}, the  values NaN, 
 * POSITIVE_INFINITY, NEGATIVE_INFINITY, MAX_VALUE, MIN_VALUE and 0.0f (though 
 * not -1 and 1) have a hightened chance of selection.
 * 
 * @return an arbitrary float
 */
public float arbNastyFloat() 
{
    return arbNastyFloat(0.0f, 1.0f);
}   ",389,True
"/** 
 * Answers an arbitrary double, but never NaN, POSITIVE_INFINITY or 
 * NEGATIVE_INFINITY.
 * 
 * @return an arbitrary double
 */
public double arbDouble(){
    switch (select(0.05f, 0.05f, 0.05f, 0.85f)) {
    case 0:
        return Double.MAX_VALUE;
    case 1:
        return Double.MIN_VALUE;
    case 2:
        return 0.0d;
    case 3: default:
        return random.nextDouble() + random.nextInt();
    }
}","/** 
 * Answers an arbitrary double, but never NaN, POSITIVE_INFINITY or 
 * NEGATIVE_INFINITY.
 * 
 * @return an arbitrary double
 */
public double arbDouble() 
{
    Random random = new Random();
    double d = random.nextDouble();
    while (Double.isNaN(d) || Double.isInfinite(d))
    {
        d = random.nextDouble();
    }
    return d;
}   ",390,True
"/**
 * Set to true to make TestRun print out details of successful property 
 * tests, not just those that fail. E.g.:
 * 
 * <pre>new TestRun().setVerbose(true).runOn(SomeInvariants.class, 1000);</pre>
 */
public TestRun setVerbose(boolean b){
    printSuccessRuns = b;
    return this;
}","/**
 * Set to true to make TestRun print out details of successful property 
 * tests, not just those that fail. E.g.:
 * 
 * <pre>new TestRun().setVerbose(true).runOn(SomeInvariants.class, 1000);</pre>
 */
public TestRun setVerbose(boolean b) 
{
    verbose = b;
    return this;
}   ",391,True
"/** 
 * Answers an arbitrary integer, with an inflated probability of returing 
 * the values MAX_VALUE, MIN_VALUE, 0, -1 and 1. That is, the probability of 
 * receiving these values is higher than with a call to Random.nextInt(), but 
 * is still low in comparison to the probability of receiving an integer that 
 * is not of these values. This is intended to improve the testing of corner 
 * cases.
 * 
 * @return an arbitrary int
 */
public int arbInt(){
    switch (select(0.05f, 0.05f, 0.05f, 0.05f, 0.05f, 0.75f)) {
    case 0:
        return 0;
    case 1:
        return Integer.MAX_VALUE;
    case 2:
        return Integer.MIN_VALUE;
    case 3:
        return -1;
    case 4:
        return 1;
    case 5: default:
        return random.nextInt();
    }
}","/** 
 * Answers an arbitrary integer, with an inflated probability of returing 
 * the values MAX_VALUE, MIN_VALUE, 0, -1 and 1. That is, the probability of 
 * receiving these values is higher than with a call to Random.nextInt(), but 
 * is still low in comparison to the probability of receiving an integer that 
 * is not of these values. This is intended to improve the testing of corner 
 * cases.
 * 
 * @return an arbitrary int
 */
public int arbInt() 
{
    int[] values = {Integer.MAX_VALUE, Integer.MIN_VALUE, 0, -1, 1};
    return values[random.nextInt(values.length)];
}   ",394,True
"/** 
 * Answers an arbitrary long. Like with {@link #arbInt()}, the values 
 * MAX_VALUE, MIN_VALUE, 0, -1 and 1 have a hightened chance of selection.
 * 
 * @return an arbitrary long
 */
public long arbLong(){
    switch (select(0.05f, 0.05f, 0.05f, 0.05f, 0.05f, 0.75f)) {
    case 0:
        return 0l;
    case 1:
        return Long.MAX_VALUE;
    case 2:
        return Long.MIN_VALUE;
    case 3:
        return -1l;
    case 4:
        return 1l;
    case 5: default:
        return random.nextLong();
    }
}","/** 
 * Answers an arbitrary long. Like with {@link #arbInt()}, the values 
 * MAX_VALUE, MIN_VALUE, 0, -1 and 1 have a hightened chance of selection.
 * 
 * @return an arbitrary long
 */
public long arbLong() 
{
    return arbInt().longValue();
}   ",395,True
"/**
 * Run arbitrary data through a particular property. The property name
 * specified should be the full simple name of the method that represents 
 * the property (including the ""prop_"" prefix). For example:
 * 
 * <pre>runOn(QuickSortInvariants.class, ""prop_idempotent"", 10000);</pre>
 */
public void runOn(Class<?> invariants, String propName, int times) throws TestException{
    Method[] ms = invariants.getDeclaredMethods();
    for (Method m : ms) {
        if (m.getName().equals(propName)) {
            runOn(m, times);
        }
    }
}","/**
 * Run arbitrary data through a particular property. The property name
 * specified should be the full simple name of the method that represents 
 * the property (including the ""prop_"" prefix). For example:
 * 
 * <pre>runOn(QuickSortInvariants.class, ""prop_idempotent"", 10000);</pre>
 */

public void runOn(Class<?> invariants, String propName, int times) throws TestException 
{
    try {
        Method m = invariants.getMethod(propName);
        for (int i = 0; i < times; i++) {
            m.invoke(this);
        }
    } catch (Exception e) {
        throw new TestException(e);
    }
}   ",396,True
"/** 
 * Run the next tests with the set of parameters passed in here. The next 
 * call, and only the next call, to a runOn() method will use these 
 * parameters. For example:
 * 
 * <pre>new TestRun().with(params).runOn(Invariants.class, 10000);</pre>
 */
public TestRun with(ParameterBunch pb){
	nextParams = pb;
	return this;
}","/** 
 * Run the next tests with the set of parameters passed in here. The next 
 * call, and only the next call, to a runOn() method will use these 
 * parameters. For example:
 * 
 * <pre>new TestRun().with(params).runOn(Invariants.class, 10000);</pre>
 */
public TestRun with(ParameterBunch pb) 
{
    this.params = pb;
    return this;
}   ",397,True
"/** 
 * Answers an arbitrary float, but never NaN, POSITIVE_INFINITY or
 * NEGATIVE_INFINITY.
 * 
 * @return an arbitrary float
 */
public float arbFloat(){
    switch (select(0.05f, 0.05f, 0.05f, 0.85f)) {
    case 0:
        return Float.MAX_VALUE;
    case 1:
        return Float.MIN_VALUE;
    case 2:
        return 0.0f;
    case 3: default:
        return random.nextFloat() + random.nextInt();
    }
}","/** 
 * Answers an arbitrary float, but never NaN, POSITIVE_INFINITY or
 * NEGATIVE_INFINITY.
 * 
 * @return an arbitrary float
 */
public float arbFloat() 
{
    float ret;
    do
    {
        ret = (float) (Math.random() * Float.MAX_VALUE);
    } while (Float.isNaN(ret) || ret == Float.POSITIVE_INFINITY || ret == Float.NEGATIVE_INFINITY);
    return ret;
}   ",399,True
"/**
 * Overloaded to remove relation with RSSSource
 */
public void remove() throws RemoveException{
	System.out.println(""Removing headline: "" + getHeadline());
	try {
		System.out.println(""Removing RSSSource relation"");
		idoRemoveFrom(RSSSource.class);
	} catch(IDORelationshipException e) {
		e.printStackTrace();
		throw new RemoveException(""Could not remove relationship with RSSSource"");
	}
	super.remove();
}","/**
 * Overloaded to remove relation with RSSSource
 */
public void remove() throws RemoveException 
{
    if (this.source == null)
    {
        throw new RemoveException(""No source to remove."");
    }
    else
    {
        this.source = null;
    }
}   ",400,True
"/* (non-Javadoc)
 * @see com.idega.data.IDOLegacyEntity#initializeAttributes()
 */
public void initializeAttributes(){
    // Skapa tabellkolumner i db fr bnan
        //  Kolumnnamn fr primrnyckel
        addAttribute(getIDColumnName());
        //      kolumnnamn, kolumnbesk, Kolumntyp(Varchar 255)
        addAttribute(""LINK_URL"", ""Link url"", String.class);
        //setUnique(""LINK_URL"", true); // got keysize to big for index using interbase
        addAttribute(""HEADLINE"", ""Link text"", String.class);
	addManyToManyRelationShip(RSSSource.class);
}","/* (non-Javadoc)
 * @see com.idega.data.IDOLegacyEntity#initializeAttributes()
 */

public void initializeAttributes() 
{
	if (attributes == null)
	{
		attributes = new HashMap();
	}
}   ",401,False
"/* (non-Javadoc)
	 * @see com.idega.data.GenericEntity#equals(java.lang.Object)
	 */
public boolean equals(Object obj){
		if(obj instanceof RSSHeadline) {
			return getLink().equals(((RSSHeadline)obj).getLink());
		} else {
			return false;
		}
	}","/* (non-Javadoc)
	 * @see com.idega.data.GenericEntity#equals(java.lang.Object)
	 */

public boolean equals(Object obj) 
{
	if (obj == null)
	{
		return false;
	}
	if (obj == this)
	{
		return true;
	}
	if (obj.getClass() != getClass())
	{
		return false;
	}
	GenericEntity other = (GenericEntity) obj;
	if (getId() == null || other.getId() == null)
	{
		return false;
	}
	return getId().equals(other.getId());
}	",403,False
"/**
 * Gets an instance of RSSBusiness
 * @return An instance of RSSBusiness
 */
private RSSBusiness getBusiness(){
	if(this._business==null) {
		try {
			RSSBusinessHome businessHome = new RSSBusinessHomeImpl();
			this._business = businessHome.create();
		} catch(Exception e) {
			e.printStackTrace();
		}
	}
	return this._business;
}","/**
 * Gets an instance of RSSBusiness
 * @return An instance of RSSBusiness
 */
private RSSBusiness getBusiness() 
{
    if (business == null)
    {
        business = new RSSBusiness();
    }
    return business;
}   ",407,True
"/**
 * Collects all elements with name ""item"" below an element into a collection 
 * @param element search this element and its descendants
 * @param col The collection to add ""item"" elements into
 */
private void collectItems(Element element, List col){
	if(""item"".equals(element.getName())) {
		col.add(element);
	}
	java.util.List children = element.getChildren();
	Iterator iter = children.iterator();
	while (iter.hasNext()) {
		Element item = (Element) iter.next();
		collectItems(item, col);
	}
}","/**
 * Collects all elements with name ""item"" below an element into a collection 
 * @param element search this element and its descendants
 * @param col The collection to add ""item"" elements into
 */
private void collectItems(Element element, List col) 
{
    if (element.getName().equals(""item""))
    {
        col.add(element);
    }
    List children = element.getChildren();
    for (int i = 0; i < children.size(); i++)
    {
        collectItems((Element) children.get(i), col);
    }
}   ",408,True
"/**
 * @param string
 */
public void setMaxLinks(String string){
	try {
		this.maxLinks = Integer.parseInt(string);
	} catch(Exception e) {
		System.err.println(""Couldn't save new max link value"");
		e.printStackTrace();
	}
}","/**
 * @param string
 */
public void setMaxLinks(String string) 
{
    this.maxLinks = Integer.parseInt(string);
}   ",409,True
"/**
 * This is where everything happens.
 */
public void main(IWContext iwc) throws Exception{
	IWResourceBundle iwrb = this.getResourceBundle(iwc);
	//if no selected rss source display an error message
	if(this.sourceId == -1) {
		Text msg = new Text(iwrb.getLocalizedString(""no.rss.source.selected"",""No RSS source selected, please select one in the property window.""));
		msg.setBold();
		add(msg);
		return;
	}
	else {
		try {
			//get the data with the business bean
			RSSBusiness business = getRSSBusiness(iwc);
			RSSSource rssSource = business.getRSSSourceBySourceId(this.sourceId);
			Collection headlines = business.getRSSHeadlinesByRSSSource(rssSource);
			
			//add stuff to the block
			if (this.description!=null && this.description.length()>0) {
				Text text = new Text(this.description);
				add(text);
			}
			
			Table table = new Table();
			//it does not really matter if this is done here or after adding to the table
			add(table);
			
			int row = 1;
			int maxLinksTmp = this.maxLinks;
			if(maxLinksTmp<1)  {
				// if maxLinks is zero (or negative), no limit
				maxLinksTmp = 10000;
			}
			for (Iterator loop = headlines.iterator(); row<=maxLinksTmp && loop.hasNext();) {
				RSSHeadline rssHeadline = (RSSHeadline) loop.next();
				String headLine = rssHeadline.getHeadline();
				Link link = new Link(headLine, rssHeadline.getLink());
				if(this.style!=null) {
					link.setFontStyle(this.style);
				}
				link.setTarget(this.linkTargetType);
				table.add(link, 1, row++);
			}
		} catch (RemoteException e) {
			e.printStackTrace();
		}
	}
}","/**
 * This is where everything happens.
 */
public void main(IWContext iwc) throws Exception 
{
    // Get the user object from the context
    IUser user = iwc.getCurrentUser();

    // Get the request object from the context
    IRequest request = iwc.getRequest();

    // Get the response object from the context
    IResponse response = iwc.getResponse();

    // Get the user's email address
    String email = user.getEmail();

    // Check if the user is logged in
    if (user.isLoggedIn())
    {
        // If the user is logged in, display a welcome message
        response.write(""Welcome, "" + email + ""!"");
    }
    else
    {
        // If the user is not logged in, display a login prompt
        response.write(""Please log in to access this page."");
    }
}   ",410,False
"/**
 * Gets all RSSHeadlines for a given RSSSource
 * @param rssSource The RSSSource
 * @return A Collection of RSSHeadlines for the given RSSSource
 */
public Collection getRSSHeadlinesByRSSSource(RSSSource rssSource){
	Collection headlines = Collections.EMPTY_LIST;
	if(rssSource!=null) {
		try {
			headlines = getHeadlinesByRSSSource(rssSource);                    
		} catch (RemoteException re) {
			re.printStackTrace();
			headlines = ListUtil.getEmptyList();
		} catch (FinderException fe) {
			fe.printStackTrace();
			headlines = ListUtil.getEmptyList();            
		}
	}
	return headlines;
}","/**
 * Gets all RSSHeadlines for a given RSSSource
 * @param rssSource The RSSSource
 * @return A Collection of RSSHeadlines for the given RSSSource
 */
public Collection getRSSHeadlinesByRSSSource(RSSSource rssSource) 
{
    return rssHeadlineDAO.getRSSHeadlinesByRSSSource(rssSource);
}   ",413,True
"/**
 * Gets an RSSSource by its Id
 * @param sourceId The Id of the RSSSource
 * @return The RSSSource
 */
public RSSSource getRSSSourceBySourceId(int sourceId){
	RSSSource source = null;
	try {
		RSSSourceHome sHome = (RSSSourceHome) getIDOHome(RSSSource.class);
		Collection sources = sHome.findSourceById(sourceId);
		if(sources.size()>0) {
			source = (RSSSource) sources.iterator().next();
		}
	} catch (Exception e) {
		//String msg = e.getMessage();
		e.printStackTrace();
	}
	return source;
}","/**
 * Gets an RSSSource by its Id
 * @param sourceId The Id of the RSSSource
 * @return The RSSSource
 */
public RSSSource getRSSSourceBySourceId(int sourceId) 
{
    RSSSource rssSource = null;
    try
    {
        rssSource = (RSSSource) session.get(RSSSource.class, sourceId);
    }
    catch (Exception e)
    {
        e.printStackTrace();
    }
    return rssSource;
}   ",414,True
"/**
 * Retrieves the latest RSSHeadlines for a given RSSSource by making a 
 * request to the RSS server. Note: The headlines in the list have not
 * been stored persistently.
 * @param rssSource The RSSSource to retrieve latest RSSHeadline from
 * @return A List of latest RSSHeadlines
 */
public List getLatestHeadlinesFromRSSByRSSSource(RSSSource rssSource){
	SAXBuilder builder = new SAXBuilder();
	ArrayList theReturn = new ArrayList();
	try {
		URL url = new URL(rssSource.getSourceURL());
		Document doc = builder.build(url);
		ArrayList items = new ArrayList(8);
		collectItems(doc.getRootElement(), items);
		int numItems = items.size();
		for(int i=0; i<numItems; i++) {
			Element item = (Element) items.get(i);
			Element eTitle = item.getChild(""title"", item.getNamespace());
			Element eLink = item.getChild(""link"", item.getNamespace());
			if(eTitle==null || eLink==null) {
				continue;
			}
			String sTitle = eTitle.getText();
			String sLink = eLink.getText();
			if(sTitle==null || sLink==null) {
				continue;
			}
			RSSHeadlineHome hHome = new RSSHeadlineHomeImpl();
			RSSHeadline h = hHome.create();
			h.setHeadline(sTitle);
			h.setLink(sLink);
			theReturn.add(h);
		}
	} catch (MalformedURLException e) {
		e.printStackTrace();
	} catch (Exception e) {
		//String msg = e.getMessage();
		e.printStackTrace();
	}
	return theReturn;
}","/**
 * Retrieves the latest RSSHeadlines for a given RSSSource by making a 
 * request to the RSS server. Note: The headlines in the list have not
 * been stored persistently.
 * @param rssSource The RSSSource to retrieve latest RSSHeadline from
 * @return A List of latest RSSHeadlines
 */
public List getLatestHeadlinesFromRSSByRSSSource(RSSSource rssSource) 
{
    List<RSSHeadline> headlines = new ArrayList<RSSHeadline>();
    try
    {
        // Create a new RSSReader instance
        RSSReader reader = new RSSReader();
        // Get the RSS feed URL from the RSSSource
        String rssFeedUrl = rssSource.getRssFeedUrl();
        // Read the RSS feed and get the latest headlines
        headlines = reader.readRSSFeed(rssFeedUrl);
    }
    catch (Exception e)
    {
        // Handle any exceptions that may occur during the RSS reading process
        e.printStackTrace();
    }
    return headlines;
}   ",417,False
"/**
 * Gets all defined RSSSources
 * @return A List of all defined RSSSources  
 */
public List getAllRSSSources(){
	List sources = null;
	try {
		RSSSourceHome sHome = (RSSSourceHome) getIDOHome(RSSSource.class);
		sources = new ArrayList(sHome.findSources());
	} catch(Exception e) {
		e.printStackTrace();
	}
	return sources;
}","/**
 * Gets all defined RSSSources
 * @return A List of all defined RSSSources  
 */

public List getAllRSSSources() 
{
    List<RSSSource> rssSources = new ArrayList<RSSSource>();
    for (RSSSource rssSource : this.rssSources)
    {
        rssSources.add(rssSource);
    }
    return rssSources;
}   ",419,True
"/**
 * Removes the attribute with the given name.
 * 
 * @param attributeName the name of the attribute to remove
 * @return the removed attribute, or null if there wasn't one
 */
public XML.Attr remove(String attributeName){
  XML.Attr attribute = getAttr(attributeName);
  if (attribute != null) {
    remove(attribute);
  }
  return attribute;
}","/**
 * Removes the attribute with the given name.
 * 
 * @param attributeName the name of the attribute to remove
 * @return the removed attribute, or null if there wasn't one
 */
public XML.Attr remove(String attributeName) 
{
    XML.Attr attr = attributes.get(attributeName);
    if (attr != null)
    {
        attributes.remove(attributeName);
    }
    return attr;
}   ",420,True
"/**
 * Creates and return a document parsed from the given file.
 * 
 * @param file the file to parse from
 * @return a new parsed document
 */
public static XML.Doc doc(File file){
  try {
    Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(file);
    return XML.doc(document);
  }
  catch (Throwable t) {
    throw new IllegalArgumentException(""Failed to parse a document from the provided file."", t);
  }
}","/**
 * Creates and return a document parsed from the given file.
 * 
 * @param file the file to parse from
 * @return a new parsed document
 */
public static XML.Doc doc(File file) 
{
    return new XML.Doc(new XML.FileSource(file));
}   ",421,False
"/**
 * Returns the child element with the given name from this element, or null if there isn't one.
 * 
 * @param name the name of the element to look up
 * @return the child element with the given name from this element, or null if there isn't one
 */
public XML.E child(String name){
  XML.E matchingElement = null;
  if (_children != null) {
    for (XML.Node node : _children) {
      if (node instanceof XML.E && ((XML.E) node)._name.equals(name)) {
        if (matchingElement == null) {
          matchingElement = (XML.E) node;
        }
        else {
          throw new IllegalStateException(""There was more than one child named '"" + name + ""'."");
        }
      }
    }
  }
  return matchingElement;
}","/**
 * Returns the child element with the given name from this element, or null if there isn't one.
 * 
 * @param name the name of the element to look up
 * @return the child element with the given name from this element, or null if there isn't one
 */
public XML.E child(String name) 
{
    for (XML.E child : children)
    {
        if (child.name.equals(name))
        {
            return child;
        }
    }
    return null;
}   ",422,True
"/**
 * Converts a W3C Document into an XML.Doc.
 * 
 * @param w3cDocument the W3C Document
 * @return the equivalent XML.Doc
 */
public static XML.Doc doc(org.w3c.dom.Document w3cDocument){
  org.w3c.dom.Element w3cElement = w3cDocument.getDocumentElement();
  Doc doc = XML.doc();
  doc.setRoot(XML.e(w3cElement));
  return doc;
}","/**
 * Converts a W3C Document into an XML.Doc.
 * 
 * @param w3cDocument the W3C Document
 * @return the equivalent XML.Doc
 */
public static XML.Doc doc(org.w3c.dom.Document w3cDocument) 
{
    return new XML.Doc(w3cDocument);
}   ",423,True
"/**
 * Sets the attribute of the given name to the given value. If there is
 * already an attribute with this name, it is replaced.
 * 
 * @param name the name of the attribute
 * @param value the value of the attribute
 * @return this element
 */
public XML.E set(String name, String value){
  remove(name);
  add(new XML.Attr(name, value));
  return this;
}","/**
 * Sets the attribute of the given name to the given value. If there is
 * already an attribute with this name, it is replaced.
 * 
 * @param name the name of the attribute
 * @param value the value of the attribute
 * @return this element
 */

public XML.E set(String name, String value) 
{
    if (name == null)
    {
        throw new NullPointerException(""name is null"");
    }
    if (value == null)
    {
        throw new NullPointerException(""value is null"");
    }
    if (attributes == null)
    {
        attributes = new LinkedHashMap<String, String>();
    }
    attributes.put(name, value);
    return this;
}   ",425,True
"/**
 * Returns the text of the child element with the given name from this element, or null if there isn't one.
 * 
 * @param name the name of the element to look up
 * @return the text of the child element with the given name from this element, or null if there isn't one
 */
public String childText(String name){
  XML.E child = child(name);
  return (child != null) ? child.text() : null;
}","/**
 * Returns the text of the child element with the given name from this element, or null if there isn't one.
 * 
 * @param name the name of the element to look up
 * @return the text of the child element with the given name from this element, or null if there isn't one
 */
public String childText(String name) 
{
    Element child = child(name);
    return child != null ? child.getText() : null;
}   ",426,True
"/**
 * Sets the declaration for this document.
 * 
 * @param declaration the declaration for this document
 */
public void setDeclaration(XML.Declaration declaration){
  if (_declaration != null) {
    remove(_declaration);
  }
  _declaration = declaration;
  if (_declaration != null) {
    _declaration.setParent(this);
    _children.add(0, _declaration);
  }
}","/**
 * Sets the declaration for this document.
 * 
 * @param declaration the declaration for this document
 */
public void setDeclaration(XML.Declaration declaration) 
{
    if (declaration == null)
    {
        throw new IllegalArgumentException(""Declaration cannot be null"");
    }
    this.declaration = declaration;
}   ",427,False
"/**
 * Returns the int variant of the value of the attribute with the given name, or null if there isn't one.
 * 
 * @param attributeName the name of the attribute to lookup
 * @param defaultValue the default value to return if there is no attribute, or if the attribute value is null
 * @return the int variant of the value of the attribute with the given name, or null if there isn't one.
 */
public int getInt(String attributeName, int defaultValue){
  int value = defaultValue;
  String text = get(attributeName);
	if (text != null) {
		value = Integer.parseInt(text);
	}
  return value;
}","/**
 * Returns the int variant of the value of the attribute with the given name, or null if there isn't one.
 * 
 * @param attributeName the name of the attribute to lookup
 * @param defaultValue the default value to return if there is no attribute, or if the attribute value is null
 * @return the int variant of the value of the attribute with the given name, or null if there isn't one.
 */
public int getInt(String attributeName, int defaultValue) 
{
    String value = get(attributeName);
    if (value == null)
    {
        return defaultValue;
    }
    return Integer.parseInt(value);
}   ",429,True
"/**
 * Removes the given attribute from this element.
 * 
 * @param attribute the attribute to remove
 */
public void remove(XML.Attr attribute){
  _attributes.remove(attribute);
  if (_attributes.size() == 0) {
    _attributes = null;
  }
}","/**
 * Removes the given attribute from this element.
 * 
 * @param attribute the attribute to remove
 */
public void remove(XML.Attr attribute) 
{
    int index = attributes.indexOf(attribute);
    if (index >= 0)
    {
        attributes.remove(index);
    }
}   ",430,True
"/**
 * Returns a list of direct children of this element that have the given name, or an empty
 * list if there aren't any.
 *  
 * @param name the name of the children elements to look up
 * @return a list of direct children of this element that have the given name, or an empty
 * list if there aren't any
 */
public List<XML.E> children(String name){
  List<XML.E> children = new LinkedList<XML.E>();
  if (_children != null) {
    for (XML.Node node : _children) {
      if (node instanceof XML.E && ((XML.E) node)._name.equals(name)) {
        children.add((XML.E) node);
      }
    }
  }
  return children;
}","/**
 * Returns a list of direct children of this element that have the given name, or an empty
 * list if there aren't any.
 *  
 * @param name the name of the children elements to look up
 * @return a list of direct children of this element that have the given name, or an empty
 * list if there aren't any
 */


public List<XML.E> children(String name) 
{
    List<XML.E> result = new ArrayList<>();
    for (XML.E child : children)
    {
        if (child.getName().equals(name))
        {
            result.add(child);
        }
    }
    return result;
}   ",431,True
"/**
 * Returns the enum variant of the child element with the given name from this element, or defaultValue if there isn't one.
 * 
 * @param name the name of the element to look up
 * @param enumClass the class of the enum to return
 * @param defaultValue the default value to return if there is no child node, or if the child node is empty
 * @return the enum variant of the child element with the given name from this element, or defaultValue if there isn't one.
 */
public <T extends Enum<T>> T childEnum(String name, Class<T> enumClass, T defaultValue){
	T value = defaultValue;
  XML.E child = child(name);
  if (child != null) {
  	String text = child.text();
  	if (text != null) {
  		value = Enum.valueOf(enumClass, text);
  	}
  }
  return value;
}","/**
 * Returns the enum variant of the child element with the given name from this element, or defaultValue if there isn't one.
 * 
 * @param name the name of the element to look up
 * @param enumClass the class of the enum to return
 * @param defaultValue the default value to return if there is no child node, or if the child node is empty
 * @return the enum variant of the child element with the given name from this element, or defaultValue if there isn't one.
 */
public <T extends Enum<T>> T childEnum(String name, Class<T> enumClass, T defaultValue) 
{
    Element child = getChild(name);
    if (child == null)
    {
        return defaultValue;
    }
    String value = child.getTextNormalize();
    if (value.isEmpty())
    {
        return defaultValue;
    }
    return Enum.valueOf(enumClass, value);
}   ",432,True
"/**
 * Returns the boolean variant of the child element with the given name from this element, or defaultValue if there isn't one.
 * 
 * @param name the name of the element to look up
 * @param defaultValue the default value to return if there is no child node, or if the child node is empty
 * @return the boolean variant of the child element with the given name from this element, or defaultValue if there isn't one.
 */
public boolean childBoolean(String name, boolean defaultValue){
	boolean value = defaultValue;
  XML.E child = child(name);
  if (child != null) {
  	String text = child.text();
  	if (text != null) {
  		value = Boolean.parseBoolean(text);
  	}
  }
  return value;
}","/**
 * Returns the boolean variant of the child element with the given name from this element, or defaultValue if there isn't one.
 * 
 * @param name the name of the element to look up
 * @param defaultValue the default value to return if there is no child node, or if the child node is empty
 * @return the boolean variant of the child element with the given name from this element, or defaultValue if there isn't one.
 */
public boolean childBoolean(String name, boolean defaultValue) 
{
    try
    {
        return childBoolean(name);
    }
    catch (Exception e)
    {
        return defaultValue;
    }
}   ",433,True
"/**
 * Sets the text value of this element. This will replace an existing Text child with
 * the provided string, or create a new one if one doesn't exist. If there is already
 * a child in this element that is not a Text node, this will throw an exception.
 * 
 * @param text the new text value for this node
 * @return this element
 */
public XML.E setText(String text){
  if (_children != null) {
    if (_children.size() == 1) {
      XML.Node node = _children.get(0);
      if (node instanceof XML.Text) {
        ((XML.Text) node).setText(text);
      }
      else {
        throw new IllegalStateException(""There was already a non-text child of this element: "" + node);
      }
    }
    else {
      throw new IllegalStateException(""There was more than one child of this element: "" + this);
    }
  }
  else {
    text(text);
  }
  return this;
}","/**
 * Sets the text value of this element. This will replace an existing Text child with
 * the provided string, or create a new one if one doesn't exist. If there is already
 * a child in this element that is not a Text node, this will throw an exception.
 * 
 * @param text the new text value for this node
 * @return this element
 */
public XML.E setText(String text) 
{
    XML.Text child = text();
    if (child == null)
    {
        return add(new XML.Text(text));
    }
    else
    {
        child.setText(text);
        return this;
    }
}   ",434,True
"/**
 * Returns the int variant of the child element with the given name from this element, or defaultValue if there isn't one.
 * 
 * @param name the name of the element to look up
 * @param defaultValue the default value to return if there is no child node, or if the child node is empty
 * @return the int variant of the child element with the given name from this element, or defaultValue if there isn't one.
 */
public int childInt(String name, int defaultValue){
  int value = defaultValue;
  XML.E child = child(name);
  if (child != null) {
  	String text = child.text();
  	if (text != null) {
  		value = Integer.parseInt(text);
  	}
  }
  return value;
}","/**
 * Returns the int variant of the child element with the given name from this element, or defaultValue if there isn't one.
 * 
 * @param name the name of the element to look up
 * @param defaultValue the default value to return if there is no child node, or if the child node is empty
 * @return the int variant of the child element with the given name from this element, or defaultValue if there isn't one.
 */
public int childInt(String name, int defaultValue) 
{
    Element child = getChild(name);
    if (child == null)
    {
        return defaultValue;
    }
    String text = child.getText();
    if (text == null)
    {
        return defaultValue;
    }
    return Integer.parseInt(text);
}   ",436,True
"//
// PRIVATE METHODS
//
private Double findMaximumValue(){
	Set<Pair<STATE_TYPE, ACTION_TYPE>> keys = table.keySet();
	if (keys.size() > 0) {
		Double maxValue = table.get(keys.toArray()[0]);
		for (Pair<STATE_TYPE, ACTION_TYPE> key : keys) {
			Double v = table.get(key);
			if (v > maxValue) {
				maxValue = v;
			}
		}
		return maxValue;

	} else {
		return 0.0;
	}
}","//
// PRIVATE METHODS
//
private Double findMaximumValue() 
{
    Double maxValue = Double.MIN_VALUE;
    for (Double value : values)
    {
        if (value > maxValue)
        {
            maxValue = value;
        }
    }
    return maxValue;
}   ",440,False
"//
// START-InferenceProcedure
public InferenceResult ask(FOLKnowledgeBase KB, Sentence alpha){

	// clauses <- the set of clauses in CNF representation of KB ^ ~alpha
	Set<Clause> clauses = new LinkedHashSet<Clause>();
	for (Clause c : KB.getAllClauses()) {
		c = KB.standardizeApart(c);
		c.setStandardizedApartCheckNotRequired();
		clauses.addAll(c.getFactors());
	}
	Sentence notAlpha = new NotSentence(alpha);
	// Want to use an answer literal to pull
	// query variables where necessary
	Literal answerLiteral = KB.createAnswerLiteral(notAlpha);
	Set<Variable> answerLiteralVariables = KB
			.collectAllVariables(answerLiteral.getAtomicSentence());
	Clause answerClause = new Clause();

	if (answerLiteralVariables.size() > 0) {
		Sentence notAlphaWithAnswer = new ConnectedSentence(Connectors.OR,
				notAlpha, answerLiteral.getAtomicSentence());
		for (Clause c : KB.convertToClauses(notAlphaWithAnswer)) {
			c = KB.standardizeApart(c);
			c.setProofStep(new ProofStepGoal(c));
			c.setStandardizedApartCheckNotRequired();
			clauses.addAll(c.getFactors());
		}

		answerClause.addLiteral(answerLiteral);
	} else {
		for (Clause c : KB.convertToClauses(notAlpha)) {
			c = KB.standardizeApart(c);
			c.setProofStep(new ProofStepGoal(c));
			c.setStandardizedApartCheckNotRequired();
			clauses.addAll(c.getFactors());
		}
	}

	TFMAnswerHandler ansHandler = new TFMAnswerHandler(answerLiteral,
			answerLiteralVariables, answerClause, maxQueryTime);

	// new <- {}
	Set<Clause> newClauses = new LinkedHashSet<Clause>();
	Set<Clause> toAdd = new LinkedHashSet<Clause>();
	// loop do
	int noOfPrevClauses = clauses.size();
	do {
		if (null != tracer) {
			tracer.stepStartWhile(clauses, clauses.size(), newClauses
					.size());
		}

		newClauses.clear();

		// for each Ci, Cj in clauses do
		Clause[] clausesA = new Clause[clauses.size()];
		clauses.toArray(clausesA);
		// Basically, using the simple T)wo F)inger M)ethod here.
		for (int i = 0; i < clausesA.length; i++) {
			Clause cI = clausesA[i];
			if (null != tracer) {
				tracer.stepOuterFor(cI);
			}
			for (int j = i; j < clausesA.length; j++) {
				Clause cJ = clausesA[j];

				if (null != tracer) {
					tracer.stepInnerFor(cI, cJ);
				}

				// resolvent <- FOL-RESOLVE(Ci, Cj)
				Set<Clause> resolvents = cI.binaryResolvents(cJ);

				if (resolvents.size() > 0) {
					toAdd.clear();
					// new <- new <UNION> resolvent
					for (Clause rc : resolvents) {
						toAdd.addAll(rc.getFactors());
					}

					if (null != tracer) {
						tracer.stepResolved(cI, cJ, toAdd);
					}

					ansHandler.checkForPossibleAnswers(toAdd);

					if (ansHandler.isComplete()) {
						break;
					}

					newClauses.addAll(toAdd);
				}

				if (ansHandler.isComplete()) {
					break;
				}
			}
			if (ansHandler.isComplete()) {
				break;
			}
		}

		noOfPrevClauses = clauses.size();

		// clauses <- clauses <UNION> new
		clauses.addAll(newClauses);

		if (ansHandler.isComplete()) {
			break;
		}

		// if new is a <SUBSET> of clauses then finished
		// searching for an answer
		// (i.e. when they were added the # clauses
		// did not increase).
	} while (noOfPrevClauses < clauses.size());

	if (null != tracer) {
		tracer.stepFinished(clauses, ansHandler);
	}

	return ansHandler;
}","//
// START-InferenceProcedure

public InferenceResult ask(FOLKnowledgeBase KB, Sentence alpha) 
{
    InferenceResult result = new InferenceResult();

    for (Sentence sentence : KB.getSentences())
    {
        if (sentence.isFact())
        {
            if (sentence.isUnifiableWith(alpha))
            {
                result.addSentence(sentence);
            }
        }
    }

    return result;
}   ",441,False
"// END-AtomicSentence
//
@Override
public boolean equals(Object o){

	if (this == o) {
		return true;
	}
	if ((o == null) || (this.getClass() != o.getClass())) {
		return false;
	}
	TermEquality te = (TermEquality) o;

	return te.getTerm1().equals(term1) && te.getTerm2().equals(term2);
}","// END-AtomicSentence
//
@Override
public boolean equals(Object o) 
{
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    AtomicSentence that = (AtomicSentence) o;
    return Objects.equals(predicate, that.predicate) &&
            Objects.equals(arguments, that.arguments);
}   ",443,True
"/** Constructor for general use. */
public DefaultEntityViewInfo(float minScale, float minNameScale, Color nameColor,
		EntityIcon icon, boolean isWayIcon, Color wayColor, float wayWidth, boolean wayDashed,
		Color wayFillColor, boolean fillAreasOnly, int printOrder){
	this.minVisibleScale = minScale;
	this.minNameScale = minNameScale;
	this.nameColor = nameColor;
	this.icon = icon;
	this.isWayIcon = isWayIcon;
	this.wayColor = wayColor;
	this.wayWidth = wayWidth;
	this.wayDashed = wayDashed;
	this.wayFillColor = wayFillColor;
	this.fillAreasOnly = fillAreasOnly;
	this.printOrder = printOrder;
}","/** Constructor for general use. */
public DefaultEntityViewInfo(float minScale, float minNameScale, Color nameColor,
		EntityIcon icon, boolean isWayIcon, Color wayColor, float wayWidth, boolean wayDashed,
		Color wayFillColor, boolean fillAreasOnly, int printOrder) 
{
	super(minScale, minNameScale, nameColor, icon, isWayIcon, wayColor, wayWidth, wayDashed,
		wayFillColor, fillAreasOnly, printOrder);
}	",444,True
"/** Starts the demo. */
public static void main(String[] args){
	AimaDemoFrame frame = new AimaDemoFrame();
	registerDemos(frame);
	frame.setSize(1000, 600);
	frame.setVisible(true);
}","/** Starts the demo. */
public static void main(String[] args) 
{
    final Demo demo = new Demo();
    final JFrame frame = new JFrame(""Demo"");
    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    frame.getContentPane().add(demo);
    frame.pack();
    frame.setVisible(true);
}   ",445,True
"/** Clears the default classification result and all rules. */
public void clear(){
	rules.clear();
	defaultEntityClass = null;
}","/** Clears the default classification result and all rules. */
public void clear() 
{
    this.defaultClassificationResult = null;
    this.rules.clear();
}   ",449,True
"/** Prints a node entity. */
protected void printNode(MapNode node, DefaultEntityViewInfo pInfo){
	int x = transformer.x(node.getLon());
	int y = transformer.y(node.getLat());
	int width = 0;
	
	if (pInfo.icon != null) {
		width = Math.round(pInfo.icon.size * displayFactor);
		pInfo.icon.draw(g2, x, y, displayFactor);
	}
	
	if (transformer.getScale() >= pInfo.minNameScale * displayFactor) {
		String name = node.getName();
		if (name != null && pInfo.nameColor != null) {
			NameInfo info = new NameInfo(name, pInfo.nameColor);
			info.x = x + width;
			info.y = y + width/4;
			nameInfoBuffer.add(info);
		}
	}
}","/** Prints a node entity. */
protected void printNode(MapNode node, DefaultEntityViewInfo pInfo) 
{
    if (node == null)
    {
        return;
    }

    if (node instanceof MapNode)
    {
        MapNode mapNode = (MapNode) node;
        printNode(mapNode, pInfo);
    }
    else if (node instanceof MapEdge)
    {
        MapEdge mapEdge = (MapEdge) node;
        printEdge(mapEdge, pInfo);
    }
}   ",451,False
"/** Prints all buffered entities according to their rendering informations. */
public void printBufferedObjects(){
	Comparator<MapEntity> comp = new MapEntityComparator();
	Collections.sort(areaBuffer, comp);
	if (wayBuffer.size() < 10000)
		Collections.sort(wayBuffer, comp);
	if (nodeBuffer.size() < 10000)
		Collections.sort(nodeBuffer, comp);
	for (MapWay area: areaBuffer)
		printWay(area, (DefaultEntityViewInfo) area.getViewInfo(), true);
	for (MapWay way: wayBuffer)
		printWay(way, (DefaultEntityViewInfo) way.getViewInfo(), false);
	for (MapEntity node: nodeBuffer) {
		MapNode n;
		if (node instanceof MapWay)
			n = ((MapWay) node).getNodes().get(0);
		else
			n = (MapNode) node;
		printNode(n, (DefaultEntityViewInfo) node.getViewInfo());
	}
	for (Track track: trackBuffer)
		printTrack(track);

	// remove identical names at the same place...
	Hashtable<String, NameInfo> hash = new Hashtable<String, NameInfo>();
	for (int i = nameInfoBuffer.size()-1; i>=0; i--) {
		NameInfo iNew = nameInfoBuffer.get(i);
		NameInfo iOld = hash.get(iNew.name);
		if (iOld == null)
			hash.put(iNew.name, iNew);
		else if (Math.abs(iNew.x-iOld.x)+Math.abs(iNew.y-iOld.y)
				< 4*fontSize*displayFactor)
			nameInfoBuffer.remove(i);
	}
	for (NameInfo textInfo : nameInfoBuffer) {
		g2.setColor(textInfo.color);
		g2.drawString(textInfo.name, textInfo.x, textInfo.y);
	}
}","/** Prints all buffered entities according to their rendering informations. */
public void printBufferedObjects() 
{
    for (int i = 0; i < bufferedObjects.size(); i++)
    {
        Entity entity = bufferedObjects.get(i);
        entity.print();
    }
}   ",456,False
"/**
 * Calculates the MD5 checksum of an array of data
 * 
 * @param data The data to checksum
 * @return The checksum, represented as a base 16 encoded string.
 * @throws IOException
  */
public static String md5Sum (byte[] data) throws IOException{
	try {
		MessageDigest digest = MessageDigest.getInstance(""MD5"");
    	byte[] md5sum = digest.digest(data);
    	BigInteger bigInt = new BigInteger(1, md5sum);

    	// Front load any zeros cut off by BigInteger
    	String md5 = bigInt.toString(16);
    	while (md5.length() != 32) {
    		md5 = ""0"" + md5;
    	}
    	return md5;
	}
	catch (NoSuchAlgorithmException nsae) {
		logger.fatal(""Major problems with your Java configuration"", nsae);
		return null;
	}

}","/**
 * Calculates the MD5 checksum of an array of data
 * 
 * @param data The data to checksum
 * @return The checksum, represented as a base 16 encoded string.
 * @throws IOException
  */



public static String md5Sum (byte[] data) throws IOException 
{
    MessageDigest md5 = MessageDigest.getInstance(""MD5"");
    md5.update(data);
    byte[] digest = md5.digest();
    return new String(Hex.encodeHex(digest));
} ",462,True
"/**
 * Get's the given object's content as a stream
 * 
 * @param container  The name of the container
 * @param objName    The name of the object
 * @return An input stream that will give the objects content when read from.
 * @throws IOException   There was an IO error doing network communication
 * @throws HttpException There was an error with the http protocol
 * @throws FilesAuthorizationException 
 * @throws FilesInvalidNameException 
 */
public InputStream getObjectAsStream (String container, String objName) throws IOException, HttpException, FilesAuthorizationException, FilesInvalidNameException{
	if (this.isLoggedin())
	{
		if (isValidContianerName(container) && isValidObjectName(objName))
		{
			if (objName.length() > FilesConstants.OBJECT_NAME_LENGTH)
			{
				logger.warn (""Object Name supplied was truncated to Max allowed of "" + FilesConstants.OBJECT_NAME_LENGTH + "" characters !"");
				objName = objName.substring(0, FilesConstants.OBJECT_NAME_LENGTH);
				logger.warn (""Truncated Object Name is: "" + objName);
			}

			GetMethod method = new GetMethod(storageURL+""/""+sanitizeForURI(container)+""/""+sanitizeForURI(objName));
			method.getParams().setSoTimeout(connectionTimeOut);
			method.setRequestHeader(FilesConstants.X_AUTH_TOKEN, authToken);

			client.executeMethod(method);

			FilesResponse response = new FilesResponse(method);

			if (response.getStatusCode() == HttpStatus.SC_OK)
			{
				logger.info (""Object data retreived  : ""+objName);
				return response.getResponseBodyAsStream();
			}
			else if (response.getStatusCode() == HttpStatus.SC_NOT_FOUND)
			{
				logger.info (""Object "" + objName + "" was not found  !"");
				return null;
			}

			method.releaseConnection();
		}
		else
		{
			if (!isValidObjectName(objName)) {
				throw new FilesInvalidNameException(objName);
			}
			else {
				throw new FilesInvalidNameException(container);
			}
		}
	}
	else {
   		throw new FilesAuthorizationException(""You must be logged in"", null, null);
	}
	return null;
}","/**
 * Get's the given object's content as a stream
 * 
 * @param container  The name of the container
 * @param objName    The name of the object
 * @return An input stream that will give the objects content when read from.
 * @throws IOException   There was an IO error doing network communication
 * @throws HttpException There was an error with the http protocol
 * @throws FilesAuthorizationException 
 * @throws FilesInvalidNameException 
 */
public InputStream getObjectAsStream (String container, String objName) throws IOException, HttpException, FilesAuthorizationException, FilesInvalidNameException 
{
    return getObjectAsStream(container, objName, null);
}   ",464,False
"/**
 * Gets list of all of the containers associated with this account.
 * 
 * @param limit The maximum number of container names to return
 * @param marker All of the names will come after <code>marker</code> lexicographically.
 * @return A list of containers
 * 
 * @throws IOException   There was an IO error doing network communication
 * @throws HttpException There was an error with the http protocol
 * @throws FilesException 
 */
public List<FilesCDNContainer> listCdnContainerInfo(int limit, String marker) throws IOException, HttpException, FilesException{
	if (this.isLoggedin())
	{
		GetMethod method = null;
		try {
			method = new GetMethod(cdnManagementURL);
			method.getParams().setSoTimeout(connectionTimeOut);
			method.setRequestHeader(FilesConstants.X_AUTH_TOKEN, authToken);
			LinkedList<NameValuePair> params = new LinkedList<NameValuePair>();
			params.add(new NameValuePair(""format"", ""xml""));
			if (limit > 0) {
				params.add(new NameValuePair(""limit"", String.valueOf(limit)));
			}
			if (marker != null) {
				params.add(new NameValuePair(""marker"", marker));
			}
			method.setQueryString(params.toArray(new NameValuePair[params.size()]));
		
			client.executeMethod(method);
			FilesResponse response = new FilesResponse(method);

			if (response.getStatusCode() == HttpStatus.SC_UNAUTHORIZED) {
				method.releaseConnection();
				if(login()) {
					method = new GetMethod(cdnManagementURL);
					method.getParams().setSoTimeout(connectionTimeOut);
					method.setRequestHeader(FilesConstants.X_AUTH_TOKEN, authToken);
					method.setQueryString(params.toArray(new NameValuePair[params.size()]));
	    			
					client.executeMethod(method);
					response = new FilesResponse(method);
				}
				else {
					throw new FilesAuthorizationException(""Re-login failed"", response.getResponseHeaders(), response.getStatusLine());
				}
			}

			if (response.getStatusCode() == HttpStatus.SC_OK)
			{
 				DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
 				DocumentBuilder builder = factory.newDocumentBuilder();
 				Document document = builder.parse(response.getResponseBodyAsStream());

 	    		NodeList nodes = document.getChildNodes();
 	    		Node accountNode = nodes.item(0);
 	    		if (! ""account"".equals(accountNode.getNodeName())) {
 	    			logger.error(""Got unexpected type of XML"");
 	    			return null;
 	    		}
 	    		ArrayList <FilesCDNContainer> containerList = new ArrayList<FilesCDNContainer>();
 	    		NodeList containerNodes = accountNode.getChildNodes();
 	    		for(int i=0; i < containerNodes.getLength(); ++i) {
 	    			Node containerNode = containerNodes.item(i);
 	    			if(!""container"".equals(containerNode.getNodeName())) continue;
 	    			FilesCDNContainer container = new FilesCDNContainer();
 	    			NodeList objectData = containerNode.getChildNodes(); 
 	    			for(int j=0; j < objectData.getLength(); ++j) {   					
 	    				Node data = objectData.item(j);
 	    				if (""name"".equals(data.getNodeName())) {
 	    					container.setName(data.getTextContent());
 	    				}
 	    				else if (""cdn_url"".equals(data.getNodeName())) {
 	    					container.setCdnURL(data.getTextContent());
 	    				}
 	    				else if (""cdn_enabled"".equals(data.getNodeName())) {
 	    					container.setEnabled(Boolean.parseBoolean(data.getTextContent()));
 	    				}
 	    				else if (""ttl"".equals(data.getNodeName())) {
 	    					container.setTtl(Integer.parseInt(data.getTextContent()));
 	    				}
 	    				else {
 	    					//logger.warn(""Unexpected container-info tag:"" + data.getNodeName());
 	    				}
 	    			}	
 	    			if (container.getName() != null) {
 	    				containerList.add(container);
 	    			}
 	    		}
 	    		return containerList;
			}	
			else if (response.getStatusCode() == HttpStatus.SC_UNAUTHORIZED) {
				logger.warn(""Unauthorized access"");
				throw new FilesAuthorizationException(""User not Authorized!"",response.getResponseHeaders(), response.getStatusLine());
			}
			else {
				throw new FilesException(""Unexpected server response"",response.getResponseHeaders(), response.getStatusLine());
			}
		}
		catch (SAXException ex) {
			// probably a problem parsing the XML
			throw new FilesException(""Problem parsing XML"", ex);
		}
		catch (ParserConfigurationException ex) {
			// probably a problem parsing the XML
			throw new FilesException(""Problem parsing XML"", ex);
		}
		finally {
			if (method != null) method.releaseConnection();
		}
	}
	else {
		throw new FilesAuthorizationException(""You must be logged in"", null, null);
	}
}","/**
 * Gets list of all of the containers associated with this account.
 * 
 * @param limit The maximum number of container names to return
 * @param marker All of the names will come after <code>marker</code> lexicographically.
 * @return A list of containers
 * 
 * @throws IOException   There was an IO error doing network communication
 * @throws HttpException There was an error with the http protocol
 * @throws FilesException 
 */
public List<FilesCDNContainer> listCdnContainerInfo(int limit, String marker) throws IOException, HttpException, FilesException 
{
    FilesCDNContainerListResponse response = new FilesCDNContainerListResponse();
    response = (FilesCDNContainerListResponse) authedGetResponse(response, buildCdnContainerInfoUri(limit, marker));
    return response.getContainers();
}   ",466,True
"/**
 * Store a file on the server, including metadata
 * 
 * @param container   The name of the container
 * @param obj         The File containing the file to copy over
 * @param contentType The MIME type of the file
 * @param name        The name of the file on the server
 * @param metadata    A map with the metadata as key names and values as the metadata values
 * @param callback    The object to which any callbacks will be sent (null if you don't want callbacks)
 * @throws IOException   There was an IO error doing network communication
 * @throws HttpException There was an error with the http protocol
 * @throws FilesException 
 */
public boolean storeObject(String container, byte obj[], String contentType, String name, Map<String,String> metadata, IFilesTransferCallback callback) throws IOException, HttpException, FilesException{
	if (this.isLoggedin())
	{
		String objName	 =  name;
		if (isValidContianerName(container) && isValidObjectName(objName))
		{

			PutMethod method = null;
			try {
				method = new PutMethod(storageURL+""/""+sanitizeForURI(container)+""/""+sanitizeForURI(objName));
				method.getParams().setSoTimeout(connectionTimeOut);
				method.setRequestHeader(FilesConstants.X_AUTH_TOKEN, authToken);
				if (useETag) {
					method.setRequestHeader(FilesConstants.E_TAG, md5Sum (obj));
				}
				method.setRequestEntity(new RequestEntityWrapper(new ByteArrayRequestEntity (obj, contentType), callback));
				for(String key : metadata.keySet()) {
					// logger.warn(""Key:"" + key + "":"" + sanitizeForURI(metadata.get(key)));
					method.setRequestHeader(FilesConstants.X_OBJECT_META + key, sanitizeForURI(metadata.get(key)));
				}
				client.executeMethod(method);
				FilesResponse response = new FilesResponse(method);

				if (response.getStatusCode() == HttpStatus.SC_UNAUTHORIZED) {
					method.releaseConnection();
					if(login()) {
						method = new PutMethod(storageURL+""/""+sanitizeForURI(container)+""/""+sanitizeForURI(objName));
						method.getParams().setSoTimeout(connectionTimeOut);
						method.setRequestHeader(FilesConstants.X_AUTH_TOKEN, authToken);
						if (useETag) {
							method.setRequestHeader(FilesConstants.E_TAG, md5Sum (obj));
						}
						method.setRequestEntity(new RequestEntityWrapper(new ByteArrayRequestEntity (obj, contentType), callback));
						for(String key : metadata.keySet()) {
							method.setRequestHeader(FilesConstants.X_OBJECT_META + key, sanitizeForURI(metadata.get(key)));
						}
						client.executeMethod(method);
						response = new FilesResponse(method);
					}
					else {
						throw new FilesAuthorizationException(""Re-login failed"", response.getResponseHeaders(), response.getStatusLine());
					}
				}

				if (response.getStatusCode() == HttpStatus.SC_CREATED)
				{
					return true;
				}
				else if (response.getStatusCode() == HttpStatus.SC_PRECONDITION_FAILED)
				{
					throw new FilesException(""Etag missmatch"", response.getResponseHeaders(), response.getStatusLine());
				}
				else if (response.getStatusCode() == HttpStatus.SC_LENGTH_REQUIRED)
				{
					throw new FilesException(""Length miss-match"", response.getResponseHeaders(), response.getStatusLine());
				}
				else 
				{
					throw new FilesException(""Unexpected Server Response"", response.getResponseHeaders(), response.getStatusLine());
				}
			}
			finally{
				if (method != null) method.releaseConnection();
			}
		}
		else
		{
			if (!isValidObjectName(objName)) {
				throw new FilesInvalidNameException(objName);
			}
			else {
				throw new FilesInvalidNameException(container);
			}
		}
	}
	else {       		
		throw new FilesAuthorizationException(""You must be logged in"", null, null);
	}
}","/**
 * Store a file on the server, including metadata
 * 
 * @param container   The name of the container
 * @param obj         The File containing the file to copy over
 * @param contentType The MIME type of the file
 * @param name        The name of the file on the server
 * @param metadata    A map with the metadata as key names and values as the metadata values
 * @param callback    The object to which any callbacks will be sent (null if you don't want callbacks)
 * @throws IOException   There was an IO error doing network communication
 * @throws HttpException There was an error with the http protocol
 * @throws FilesException 
 */
public boolean storeObject(String container, byte obj[], String contentType, String name, Map<String,String> metadata, IFilesTransferCallback callback) throws IOException, HttpException, FilesException 
{
    if (obj == null)
    {
        throw new FilesException(""Object to store was null"");
    }

    if (name == null || name.length() == 0)
    {
        throw new FilesException(""Name to store was null or empty"");
    }

    if (contentType == null || contentType.length() == 0)
    {
        throw new FilesException(""Content type to store was null or empty"");
    }

    String path = container + ""/"" + name;
    return this.storeObject(path, obj, contentType, metadata, callback);
}   ",467,False
"/**
 * Returns the size of the object, in bytes
 * 
 * @return The size of the object in bytes
 * @throws HttpException
 * @throws IOException
 * @throws FilesAuthorizationException 
 * @throws FilesInvalidNameException 
 */
public long getSize() throws HttpException, IOException, FilesAuthorizationException, FilesInvalidNameException{
    if (size == -1) {
    	getMetaData();
    }
    return size;
}","/**
 * Returns the size of the object, in bytes
 * 
 * @return The size of the object in bytes
 * @throws HttpException
 * @throws IOException
 * @throws FilesAuthorizationException 
 * @throws FilesInvalidNameException 
 */
public long getSize() throws HttpException, IOException, FilesAuthorizationException, FilesInvalidNameException 
{
    if (this.size == null) {
        this.size = this.getMetadata().getSize();
    }
    return this.size;
}   ",469,True
"/**
 * Set's the objects name (up to a maximum of 128 characters)
 * 
 * @param name The new name
 */
public void setName(String name){
    if (name.length() > FilesConstants.OBJECT_NAME_LENGTH)
    {
        logger.warn(""Object name larger than "" + FilesConstants.OBJECT_NAME_LENGTH + "" characters truncating from: ""+name);
        this.name = name.substring(0, FilesConstants.OBJECT_NAME_LENGTH);
        logger.warn(""Object name truncated to : ""+name);
    }
    this.name = name;
}","/**
 * Set's the objects name (up to a maximum of 128 characters)
 * 
 * @param name The new name
 */
public void setName(String name) 
{
    if (name.length() > 128)
    {
        throw new IllegalArgumentException(""Name cannot be longer than 128 characters"");
    }
    this.name = name;
}   ",470,True
"/**
 * Gets current CDN sharing status of the container
 * 
 * @param name The name of the container to enable
 * @return Information on the container
 * @throws IOException   There was an IO error doing network communication
 * @throws HttpException There was an error with the http protocol
 * @throws FilesException There was an error talking to the CloudFiles Server
 */
public FilesCDNContainer getCDNContainerInfo(String container) throws IOException, HttpException, FilesException{
	if (isLoggedin()) {
		if (isValidContianerName(container))
		{
			HeadMethod method = null;
			try {
				method= new HeadMethod(cdnManagementURL+""/""+sanitizeForURI(container));
				method.getParams().setSoTimeout(connectionTimeOut);
				method.setRequestHeader(FilesConstants.X_AUTH_TOKEN, authToken);
				client.executeMethod(method);

				FilesResponse response = new FilesResponse(method);

				if (response.getStatusCode() == HttpStatus.SC_UNAUTHORIZED) {
					method.releaseConnection();
					if(login()) {
						method= new HeadMethod(cdnManagementURL+""/""+sanitizeForURI(container));
						method.getParams().setSoTimeout(connectionTimeOut);
						method.setRequestHeader(FilesConstants.X_AUTH_TOKEN, authToken);
						client.executeMethod(method);
						response = new FilesResponse(method);
					}
					else {
						throw new FilesAuthorizationException(""Re-login failed"", response.getResponseHeaders(), response.getStatusLine());
					}
				}

				if (response.getStatusCode() == HttpStatus.SC_NO_CONTENT)
				{
					FilesCDNContainer result = new FilesCDNContainer(response.getCdnUrl());
					result.setName(container);
					for (Header hdr : response.getResponseHeaders()) { 
						String name = hdr.getName().toLowerCase();
						if (""x-cdn-enabled"".equals(name)) {
							result.setEnabled(Boolean.valueOf(hdr.getValue()));
						}
						else if (""x-ttl"".equals(name)) {
							result.setTtl(Integer.parseInt(hdr.getValue()));
						}
					}
					return result;
				}
				else if (response.getStatusCode() == HttpStatus.SC_UNAUTHORIZED) {
					logger.warn(""Unauthorized access"");
					throw new FilesAuthorizationException(""User not Authorized!"",response.getResponseHeaders(), response.getStatusLine());
				}
				else {
					throw new FilesException(""Unexpected result from server: "", response.getResponseHeaders(), response.getStatusLine());
				}
			}
			finally {
				if (method != null) {
					method.releaseConnection();
				}
			}
		}
		else
		{
			throw new FilesInvalidNameException(container);
		}
	}
	else {
		throw new FilesAuthorizationException(""You must be logged in"", null, null);
	}
}","/**
 * Gets current CDN sharing status of the container
 * 
 * @param name The name of the container to enable
 * @return Information on the container
 * @throws IOException   There was an IO error doing network communication
 * @throws HttpException There was an error with the http protocol
 * @throws FilesException There was an error talking to the CloudFiles Server
 */
public FilesCDNContainer getCDNContainerInfo(String container) throws IOException, HttpException, FilesException 
{
    return getCDNContainerInfo(container, null);
}   ",472,False
"/**
 * Get an object's metadata
 * 
 * @param container The name of the container
 * @param objName   The name of the object
 * @return The object's metadata
 * @throws IOException   There was an IO error doing network communication
 * @throws HttpException There was an error with the http protocol
 * @throws FilesAuthorizationException The Client's Login was invalid.  
 * @throws FilesInvalidNameException The container or object name was not valid
 */
public FilesObjectMetaData getObjectMetaData (String container, String objName) throws IOException, HttpException, FilesAuthorizationException, FilesInvalidNameException{
	FilesObjectMetaData metaData;
	if (this.isLoggedin())
	{
		if (isValidContianerName(container) && isValidObjectName(objName))
		{
			HeadMethod method = new HeadMethod(storageURL+""/""+sanitizeForURI(container)+""/""+sanitizeForURI(objName));
			method.getParams().setSoTimeout(connectionTimeOut);
			method.setRequestHeader(FilesConstants.X_AUTH_TOKEN, authToken);

			client.executeMethod(method);

			FilesResponse response = new FilesResponse(method);

			if (response.getStatusCode() == HttpStatus.SC_NO_CONTENT)
			{
				logger.debug (""Object metadata retreived  : ""+objName);
				String mimeType = response.getContentType();
				String lastModified = response.getLastModified();
				String eTag = response.getETag();
				String contentLength = response.getContentLength();

				metaData = new FilesObjectMetaData(mimeType, contentLength, eTag, lastModified);

				Header [] headers = response.getResponseHeaders();
				HashMap<String,String> headerMap = new HashMap<String,String>();

				for (Header h: headers)
				{
					if ( h.getName().startsWith(FilesConstants.X_OBJECT_META) )
					{
						headerMap.put(h.getName().substring(FilesConstants.X_OBJECT_META.length()), unencodeURI(h.getValue()));
					}
				}
				if (headerMap.size() > 0)
					metaData.setMetaData(headerMap);

				return metaData;
			}
			else if (response.getStatusCode() == HttpStatus.SC_NOT_FOUND)
			{
				logger.info (""Object "" + objName + "" was not found  !"");
				return null;
			}

			method.releaseConnection();
		}
		else
		{
			if (!isValidObjectName(objName)) {
				throw new FilesInvalidNameException(objName);
			}
			else {
				throw new FilesInvalidNameException(container);
			}
		}
	}
	else {
   		throw new FilesAuthorizationException(""You must be logged in"", null, null);
	}
	return null;
}","/**
 * Get an object's metadata
 * 
 * @param container The name of the container
 * @param objName   The name of the object
 * @return The object's metadata
 * @throws IOException   There was an IO error doing network communication
 * @throws HttpException There was an error with the http protocol
 * @throws FilesAuthorizationException The Client's Login was invalid.  
 * @throws FilesInvalidNameException The container or object name was not valid
 */





public FilesObjectMetaData getObjectMetaData (String container, String objName) throws IOException, HttpException, FilesAuthorizationException, FilesInvalidNameException 
{
    FilesObjectMetaData metaData = null;
    String path = ""/"" + container + ""/"" + objName;
    HttpGet method = new HttpGet(path);
    try {
        HttpResponse response = restClient.execute(method);
        if (response.getStatusLine().getStatusCode() == 200) {
            metaData = new FilesObjectMetaData(response);
        } else {
            handleNonSuccessResponse(response);
        }
    } finally {
        method.releaseConnection();
    }
    return metaData;
}   ",473,False
"/**
 * Deletes a container
 * 
 * @param name  The name of the container
 * @throws IOException   There was an IO error doing network communication
 * @throws HttpException There was an error with the http protocol
 * @throws FilesAuthorizationException The user is not Logged in
 * @throws FilesInvalidNameException   The container name is invalid
 * @throws FilesNotFoundException      The container doesn't exist
 * @throws FilesContainerNotEmptyException The container was not empty
 */
public boolean deleteContainer(String name) throws IOException, HttpException, FilesAuthorizationException, FilesInvalidNameException, FilesNotFoundException, FilesContainerNotEmptyException{
	if (this.isLoggedin())
	{
		if (isValidContianerName(name))
		{
			DeleteMethod method = new DeleteMethod(storageURL+""/""+sanitizeForURI(name));
			try {
				method.getParams().setSoTimeout(connectionTimeOut);
	   			method.setRequestHeader(FilesConstants.X_AUTH_TOKEN, authToken);
    			client.executeMethod(method);
    			FilesResponse response = new FilesResponse(method);

	       		if (response.getStatusCode() == HttpStatus.SC_UNAUTHORIZED) {
	       			method.releaseConnection();
	    			if(login()) {
	    	   			method = new DeleteMethod(storageURL+""/""+sanitizeForURI(name));
	    				method.getParams().setSoTimeout(connectionTimeOut);
	    	   			method.setRequestHeader(FilesConstants.X_AUTH_TOKEN, authToken);
	        			client.executeMethod(method);
	    				response = new FilesResponse(method);
	    			}
	    			else {
	    				throw new FilesAuthorizationException(""Re-login failed"", response.getResponseHeaders(), response.getStatusLine());
	    			}
	    		}

	       		if (response.getStatusCode() == HttpStatus.SC_NO_CONTENT)
    			{
    				logger.debug (""Container Deleted : ""+name);
    				return true;
    			}
    			else if (response.getStatusCode() == HttpStatus.SC_NOT_FOUND)
    			{
    				logger.debug (""Container does not exist !"");
       				throw new FilesNotFoundException(""You can't delete an non-empty container"", response.getResponseHeaders(), response.getStatusLine());
    			}
    			else if (response.getStatusCode() == HttpStatus.SC_CONFLICT)
    			{
    				logger.debug (""Container is not empty, can not delete a none empty container !"");
    				throw new FilesContainerNotEmptyException(""You can't delete an non-empty container"", response.getResponseHeaders(), response.getStatusLine());
    			}
			}
			finally {
				method.releaseConnection();
			}
		}
		else
		{
       		throw new FilesInvalidNameException(name);
		}
	}
		else
		{
   		throw new FilesAuthorizationException(""You must be logged in"", null, null);
		}
	return false;
}","/**
 * Deletes a container
 * 
 * @param name  The name of the container
 * @throws IOException   There was an IO error doing network communication
 * @throws HttpException There was an error with the http protocol
 * @throws FilesAuthorizationException The user is not Logged in
 * @throws FilesInvalidNameException   The container name is invalid
 * @throws FilesNotFoundException      The container doesn't exist
 * @throws FilesContainerNotEmptyException The container was not empty
 */
public boolean deleteContainer(String name) throws IOException, HttpException, FilesAuthorizationException, FilesInvalidNameException, FilesNotFoundException, FilesContainerNotEmptyException 
{
    if (!isValidName(name)) {
        throw new FilesInvalidNameException();
    }

    String path = ""/v1/containers/"" + name;

    return delete(path);
}   ",476,False
"/**
 * Convenience method to test for the existence of a container in Cloud Files.
 * 
 * @param container
 * @return true if the container exists.  false otherwise.
 * @throws IOException
 * @throws IOException   There was an IO error doing network communication
 * @throws HttpException There was an error with the http protocol
 */
public boolean containerExists (String container) throws IOException, HttpException{
    try {
    	this.getContainerInfo(container);
    	return true;
    }
    catch(FilesException fnfe) {
    	return false;
    }
 }","/**
 * Convenience method to test for the existence of a container in Cloud Files.
 * 
 * @param container
 * @return true if the container exists.  false otherwise.
 * @throws IOException
 * @throws IOException   There was an IO error doing network communication
 * @throws HttpException There was an error with the http protocol
 */

public boolean containerExists (String container) throws IOException, HttpException 
{
    try
    {
        getContainerInfo(container);
        return true;
    }
    catch (NoSuchContainerException e)
    {
        return false;
    }
}   ",478,False
"/**
 * Encode any unicode characters that will cause us problems.
 * 
 * @param str
 * @return The string encoded for a URI
 */
public static String sanitizeForURI(String str){
	URLCodec codec= new URLCodec();
	try {
		return codec.encode(str).replaceAll(""\\+"", ""%20"").replaceAll(""%2F"", ""/"");
	}
	catch (EncoderException ee) {
		logger.warn(""Error trying to encode string for URI"", ee);
		return str;
	}
}","/**
 * Encode any unicode characters that will cause us problems.
 * 
 * @param str
 * @return The string encoded for a URI
 */
public static String sanitizeForURI(String str) 
{
    StringBuilder sb = new StringBuilder();
    for (char c : str.toCharArray()) {
        if (isSafe(c)) {
            sb.append(c);
        } else {
            sb.append('%');
            sb.append(Integer.toHexString((int)c));
        }
    }
    return sb.toString();
}   ",479,False
"/**
 * Surface created.
 *
 * @param holder the holder
 */
public void surfaceCreated(SurfaceHolder holder){
    mHolder = holder;
    synchronized (sGLThreadManager) {
        if (LOG_THREADS) {
            Log.i(""GLThread"", ""surfaceCreated tid="" + getId());
        }
        mHasSurface = true;
        sGLThreadManager.notifyAll();
    }
}","/**
 * Surface created.
 *
 * @param holder the holder
 */

public void surfaceCreated(SurfaceHolder holder) 
{
    if (mCamera != null)
    {
        try
        {
            mCamera.setPreviewDisplay(holder);
        }
        catch (IOException e)
        {
            e.printStackTrace();
        }
    }
}   ",483,False
"/* (non-Javadoc)
 * @see android.service.wallpaper.WallpaperService.Engine#onSurfaceDestroyed(android.view.SurfaceHolder)
 */
@Override
public void onSurfaceDestroyed(SurfaceHolder holder){
    Log.d(TAG, ""onSurfaceDestroyed()"");
    mGLThread.surfaceDestroyed();
    super.onSurfaceDestroyed(holder);
}","/* (non-Javadoc)
 * @see android.service.wallpaper.WallpaperService.Engine#onSurfaceDestroyed(android.view.SurfaceHolder)
 */
@Override
public void onSurfaceDestroyed(SurfaceHolder holder) 
{
    super.onSurfaceDestroyed(holder);
    if (mEngine != null)
    {
        mEngine.onSurfaceDestroyed(holder);
    }
}   ",485,True
"/**
 * Request exit and wait.
 */
public void requestExitAndWait(){
    // don't call this from GLThread thread or it is a guaranteed
    // deadlock!
    synchronized (sGLThreadManager) {
        mDone = true;
        sGLThreadManager.notifyAll();
    }
    try {
        join();
    } catch (InterruptedException ex) {
        Thread.currentThread().interrupt();
    }
}","/**
 * Request exit and wait.
 */
public void requestExitAndWait() 
{
    exit = true;
    try
    {
        join();
    }
    catch (InterruptedException e)
    {
        e.printStackTrace();
    }
}   ",486,False
"/**
 * Creates a new DefaultWindowSurface object.
 *
 * @param egl the egl
 * @param display the display
 * @param config the config
 * @param nativeWindow the native window
 * @return the EGL surface
 * @see com.mobilebytes.drwholivewallpaper.EGLWindowSurfaceFactory#createWindowSurface(javax.microedition.khronos.egl.EGL10, javax.microedition.khronos.egl.EGLDisplay, javax.microedition.khronos.egl.EGLConfig, java.lang.Object)
 */
public EGLSurface createWindowSurface(EGL10 egl, EGLDisplay display,
            EGLConfig config, Object nativeWindow){
        // this is a bit of a hack to work around Droid init problems - if you
        // don't have this, it'll get hung up on orientation changes
        EGLSurface eglSurface = null;
        while (eglSurface == null) {
            try {
                eglSurface = egl.eglCreateWindowSurface(display, config,
                        nativeWindow, null);
            } catch (Throwable t) {
            } finally {
                if (eglSurface == null) {
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException t) {
                    }
                }
            }
        }
        return eglSurface;
    }","/**
 * Creates a new DefaultWindowSurface object.
 *
 * @param egl the egl
 * @param display the display
 * @param config the config
 * @param nativeWindow the native window
 * @return the EGL surface
 * @see com.mobilebytes.drwholivewallpaper.EGLWindowSurfaceFactory#createWindowSurface(javax.microedition.khronos.egl.EGL10, javax.microedition.khronos.egl.EGLDisplay, javax.microedition.khronos.egl.EGLConfig, java.lang.Object)
 */
public EGLSurface createWindowSurface(EGL10 egl, EGLDisplay display,
            EGLConfig config, Object nativeWindow) 
{
    EGLSurface surface = egl.eglCreateWindowSurface(display, config, nativeWindow, null);
    return surface;
}   ",487,True
"/**
 * Sets the renderer.
 *
 * @param renderer the new renderer
 */
public void setRenderer(Renderer renderer){
    checkRenderThreadState();
    if (mEGLConfigChooser == null) {
        mEGLConfigChooser = new SimpleEGLConfigChooser(true);
    }
    if (mEGLContextFactory == null) {
        mEGLContextFactory = new DefaultContextFactory();
    }
    if (mEGLWindowSurfaceFactory == null) {
        mEGLWindowSurfaceFactory = new DefaultWindowSurfaceFactory();
    }
    mGLThread = new GLThread(renderer, mEGLConfigChooser,
            mEGLContextFactory, mEGLWindowSurfaceFactory, mGLWrapper);
    mGLThread.start();
}","/**
 * Sets the renderer.
 *
 * @param renderer the new renderer
 */
public void setRenderer(Renderer renderer) 
{
    if (renderer == null)
    {
        throw new IllegalArgumentException(""Renderer cannot be null"");
    }

    this.renderer = renderer;
}   ",489,False
"//
// Blit vertex data in garbage memory into direct memory heap (buffers)...
//
/**
 * Fill vertex.
 */
private void fillVertex(){
    vertices_buffer.clear();
    vertices_buffer.put(vertices);
    vertices_buffer.position(0);
}","//
// Blit vertex data in garbage memory into direct memory heap (buffers)...
//
/**
 * Fill vertex.
 */
private void fillVertex() 
{
    // Fill vertex data.
    vertexData = BufferUtils.createVector3Buffer(3);
    vertexData.put(0, 0.0f);
    vertexData.put(1, 0.0f);
    vertexData.put(2, 0.0f);
    vertexData.flip();
}   ",490,True
"/**
 * Destroy surface.
 */
public void destroySurface(){
    if ((mEglSurface != null) && (mEglSurface != EGL10.EGL_NO_SURFACE)) {
        mEgl.eglMakeCurrent(mEglDisplay, EGL10.EGL_NO_SURFACE,
                EGL10.EGL_NO_SURFACE, EGL10.EGL_NO_CONTEXT);
        mEGLWindowSurfaceFactory.destroySurface(mEgl, mEglDisplay,
                mEglSurface);
        mEglSurface = null;
    }
}","/**
 * Destroy surface.
 */
public void destroySurface() 
{
    if (surface != null)
    {
        surface.destroy();
        surface = null;
    }
}   ",493,True
"/* (non-Javadoc)
 * @see android.service.wallpaper.WallpaperService.Engine#onSurfaceCreated(android.view.SurfaceHolder)
 */
@Override
public void onSurfaceCreated(SurfaceHolder holder){
    Log.d(TAG, ""onSurfaceCreated()"");
    mGLThread.surfaceCreated(holder);
    super.onSurfaceCreated(holder);
}","/* (non-Javadoc)
 * @see android.service.wallpaper.WallpaperService.Engine#onSurfaceCreated(android.view.SurfaceHolder)
 */
@Override
public void onSurfaceCreated(SurfaceHolder holder) 
{
    super.onSurfaceCreated(holder);
    if (mEngine != null)
    {
        mEngine.onSurfaceCreated(holder);
    }
}   ",494,True
"/**
 * Find config attrib.
 *
 * @param egl the egl
 * @param display the display
 * @param config the config
 * @param attribute the attribute
 * @param defaultValue the default value
 * @return the int
 */
private int findConfigAttrib(EGL10 egl, EGLDisplay display,
        EGLConfig config, int attribute, int defaultValue){

    if (egl.eglGetConfigAttrib(display, config, attribute, mValue)) {
        return mValue[0];
    }
    return defaultValue;
}","/**
 * Find config attrib.
 *
 * @param egl the egl
 * @param display the display
 * @param config the config
 * @param attribute the attribute
 * @param defaultValue the default value
 * @return the int
 */
private int findConfigAttrib(EGL10 egl, EGLDisplay display,
        EGLConfig config, int attribute, int defaultValue) 
{
    if (egl.eglGetConfigAttrib(display, config, attribute, mValue))
    {
        return mValue[0];
    }
    return defaultValue;
}   ",497,True
"/**
 * On resume.
 */
public void onResume(){
    synchronized (sGLThreadManager) {
        mPaused = false;
        mRequestRender = true;
        sGLThreadManager.notifyAll();
    }
}","/**
 * On resume.
 */
public void onResume() 
{
    super.onResume();
    if (this.mGLView != null)
    {
        this.mGLView.onResume();
    }
}   ",498,True
"/**
 * Tries once to acquire the right to use an EGL surface. Does not
 * block.
 *
 * @param thread the thread
 * @return true if the right to use an EGL surface was acquired.
 */
public synchronized boolean tryAcquireEglSurface(GLThread thread){
    if ((mEglOwner == thread) || (mEglOwner == null)) {
        mEglOwner = thread;
        notifyAll();
        return true;
    }
    return false;
}","/**
 * Tries once to acquire the right to use an EGL surface. Does not
 * block.
 *
 * @param thread the thread
 * @return true if the right to use an EGL surface was acquired.
 */
public synchronized boolean tryAcquireEglSurface(GLThread thread) 
{
    if (mEglSurface == null)
    {
        mEglSurface = thread.createEglSurface(this);
    }
    if (mEglSurface != null)
    {
        mEglSurface.acquire();
        return true;
    }
    return false;
}   ",499,True
"/**
 * Append a value.
 * @param s A string value.
 * @return this
 * @throws JSONException If the value is out of sequence.
 */
private JSONWriter append(String s) throws JSONException{
    if (s == null) {
        throw new JSONException(""Null pointer"");
    }
    if (this.mode == 'o' || this.mode == 'a') {
        try {
            if (this.comma && this.mode == 'a') {
                this.writer.write(',');
            }
            this.writer.write(s);
        } catch (IOException e) {
            throw new JSONException(e);
        }
        if (this.mode == 'o') {
            this.mode = 'k';
        }
        this.comma = true;
        return this;
    }
    throw new JSONException(""Value out of sequence."");
}","/**
 * Append a value.
 * @param s A string value.
 * @return this
 * @throws JSONException If the value is out of sequence.
 */
private JSONWriter append(String s) throws JSONException 
{
  if (s == null)
  {
    throw new JSONException(""JSONWriter value out of sequence."");
  }
  put(s);
  return this;
}   ",500,True
"/**
 * Convert a JSONObject into a cookie list. A cookie list is a sequence
 * of name/value pairs. The names are separated from the values by '='.
 * The pairs are separated by ';'. The characters '%', '+', '=', and ';'
 * in the names and values are replaced by ""%hh"".
 * @param o A JSONObject
 * @return A cookie list string
 * @throws JSONException
 */
public static String toString(JSONObject o) throws JSONException{
    boolean      b = false;
    Iterator     keys = o.keys();
    String       s;
    StringBuffer sb = new StringBuffer();
    while (keys.hasNext()) {
        s = keys.next().toString();
        if (!o.isNull(s)) {
            if (b) {
                sb.append(';');
            }
            sb.append(Cookie.escape(s));
            sb.append(""="");
            sb.append(Cookie.escape(o.getString(s)));
            b = true;
        }
    }
    return sb.toString();
}","/**
 * Convert a JSONObject into a cookie list. A cookie list is a sequence
 * of name/value pairs. The names are separated from the values by '='.
 * The pairs are separated by ';'. The characters '%', '+', '=', and ';'
 * in the names and values are replaced by ""%hh"".
 * @param o A JSONObject
 * @return A cookie list string
 * @throws JSONException
 */

public static String toString(JSONObject o) throws JSONException 
{
    StringBuilder sb = new StringBuilder();
    boolean b = false;
    Iterator<String> keys = o.keys();
    while (keys.hasNext())
    {
        String key = keys.next();
        Object value = o.get(key);
        if (!JSONObject.NULL.equals(value))
        {
            if (b)
            {
                sb.append(';');
            }
            sb.append(JSONObject.quote(key));
            sb.append('=');
            sb.append(JSONObject.quote(value.toString()));
            b = true;
        }
    }
    return sb.toString();
}   ",502,True
"/**
 * Make a fresh JSONWriter. It can be used to build one JSON text.
 */
public JSONWriter(Writer w){
    this.comma = false;
    this.mode = 'i';
    this.stack = new JSONObject[maxdepth];
    this.top = 0;
    this.writer = w;
}","/**
 * Make a fresh JSONWriter. It can be used to build one JSON text.
 */
public JSONWriter(Writer w) 
{
    this.w = w;
    try
    {
        this.out = new PrintWriter(w);
    }
    catch(Exception e)
    {
        e.printStackTrace();
    }
}   ",503,True
"/**
 * Convert a cookie list into a JSONObject. A cookie list is a sequence
 * of name/value pairs. The names are separated from the values by '='.
 * The pairs are separated by ';'. The names and the values
 * will be unescaped, possibly converting '+' and '%' sequences.
 *
 * To add a cookie to a cooklist,
 * cookielistJSONObject.put(cookieJSONObject.getString(""name""),
 *     cookieJSONObject.getString(""value""));
 * @param string  A cookie list string
 * @return A JSONObject
 * @throws JSONException
 */
public static JSONObject toJSONObject(String string) throws JSONException{
    JSONObject o = new JSONObject();
    JSONTokener x = new JSONTokener(string);
    while (x.more()) {
        String name = Cookie.unescape(x.nextTo('='));
        x.next('=');
        o.put(name, Cookie.unescape(x.nextTo(';')));
        x.next();
    }
    return o;
}","/**
 * Convert a cookie list into a JSONObject. A cookie list is a sequence
 * of name/value pairs. The names are separated from the values by '='.
 * The pairs are separated by ';'. The names and the values
 * will be unescaped, possibly converting '+' and '%' sequences.
 *
 * To add a cookie to a cooklist,
 * cookielistJSONObject.put(cookieJSONObject.getString(""name""),
 *     cookieJSONObject.getString(""value""));
 * @param string  A cookie list string
 * @return A JSONObject
 * @throws JSONException
 */
public static JSONObject toJSONObject(String string) throws JSONException 
{
    JSONObject jo = new JSONObject();
    JSONTokener x = new JSONTokener(string);
    while (x.more()) {
        String name = x.nextTo('=');
        x.next('=');
        jo.put(name, x.nextTo(';'));
        x.next();
    }
    return jo;
}   ",508,True
"//
// CONVERT UTILS
//
public static String toString(Object o){

  if (o.getClass() == String.class) {
    return (String)o;
  }
  if (o.getClass() == Integer.class) {
    return Integer.toString((Integer)o);
  }
  if (o.getClass() == Long.class) {
    return Long.toString((Long)o);
  }
  if (o.getClass() == Double.class) {
    return Double.toString((Double)o);
  }
  if (o.getClass() == Float.class) {
    return Float.toString((Float)o);
  }

  return null;
}","//
// CONVERT UTILS
//
public static String toString(Object o) 
{
    if (o == null)
        return """";
    else
        return o.toString();
}   ",509,True
"/**
 * Convert a cookie specification string into a JSONObject. The string
 * will contain a name value pair separated by '='. The name and the value
 * will be unescaped, possibly converting '+' and '%' sequences. The
 * cookie properties may follow, separated by ';', also represented as
 * name=value (except the secure property, which does not have a value).
 * The name will be stored under the key ""name"", and the value will be
 * stored under the key ""value"". This method does not do checking or
 * validation of the parameters. It only converts the cookie string into
 * a JSONObject.
 * @param string The cookie specification string.
 * @return A JSONObject containing ""name"", ""value"", and possibly other
 *  members.
 * @throws JSONException
 */
public static JSONObject toJSONObject(String string) throws JSONException{
    String         n;
    JSONObject     o = new JSONObject();
    Object         v;
    JSONTokener x = new JSONTokener(string);
    o.put(""name"", x.nextTo('='));
    x.next('=');
    o.put(""value"", x.nextTo(';'));
    x.next();
    while (x.more()) {
        n = unescape(x.nextTo(""=;""));
        if (x.next() != '=') {
            if (n.equals(""secure"")) {
                v = Boolean.TRUE;
            } else {
                throw x.syntaxError(""Missing '=' in cookie parameter."");
            }
        } else {
            v = unescape(x.nextTo(';'));
            x.next();
        }
        o.put(n, v);
    }
    return o;
}","/**
 * Convert a cookie specification string into a JSONObject. The string
 * will contain a name value pair separated by '='. The name and the value
 * will be unescaped, possibly converting '+' and '%' sequences. The
 * cookie properties may follow, separated by ';', also represented as
 * name=value (except the secure property, which does not have a value).
 * The name will be stored under the key ""name"", and the value will be
 * stored under the key ""value"". This method does not do checking or
 * validation of the parameters. It only converts the cookie string into
 * a JSONObject.
 * @param string The cookie specification string.
 * @return A JSONObject containing ""name"", ""value"", and possibly other
 *  members.
 * @throws JSONException
 */

public static JSONObject toJSONObject(String string) throws JSONException 
{
    JSONObject o = new JSONObject();
    JSONTokener x = new JSONTokener(string);
    o.put(""name"", x.nextTo('='));
    x.next('=');
    o.put(""value"", x.nextTo(';'));
    x.next();
    while (x.more())
    {
        String name = x.nextTo(""=;"");
        if (x.next() != '=')
        {
            if (name.equals(""secure""))
            {
                o.put(name, Boolean.TRUE);
            }
            else
            {
                throw x.syntaxError(""Missing '=' in cookie parameter."");
            }
        }
        else
        {
            o.put(name, x.nextTo(';'));
            x.next();
        }
    }
    return o;
}   ",511,True
"/**
 * Reverse the JSONML transformation, making an XML text from a JSONObject.
 * The JSONObject must contain a ""tagName"" property. If it has children, 
 * then it must have a ""childNodes"" property containing an array of objects. 
 * The other properties are attributes with string values.
 * @param jo A JSONObject.
 * @return An XML string.
 * @throws JSONException
 */
public static String toString(JSONObject jo) throws JSONException{
	    StringBuffer sb = new StringBuffer();
	    Object		 e;
	    int          i;
	    JSONArray    ja;
	    String       k;
	    Iterator     keys;
	    int          len;
	    String       tagName;
	    String       v;
	
//Emit <tagName
	
		tagName = jo.optString(""tagName"");
		if (tagName == null) {
			return XML.escape(jo.toString());
		}
		XML.noSpace(tagName);
		tagName = XML.escape(tagName);
		sb.append('<');
		sb.append(tagName);
	
//Emit the attributes
	
    keys = jo.keys();
    while (keys.hasNext()) {
        k = keys.next().toString();
        if (!k.equals(""tagName"") && !k.equals(""childNodes"")) {
        	XML.noSpace(k);
	            v = jo.optString(k);
	            if (v != null) {
		            sb.append(' ');
		            sb.append(XML.escape(k));
		            sb.append('=');
		            sb.append('""');
		            sb.append(XML.escape(v));
		            sb.append('""');
	            }
        }
    }    
		     	
//Emit content in body
	
		ja = jo.optJSONArray(""childNodes"");
		if (ja == null) {
	        sb.append('/');
	        sb.append('>');
		} else {
	        sb.append('>');
			len = ja.length();
			for (i = 0; i < len; i += 1) {
			    e = ja.get(i);
			    if (e != null) {
			    	if (e instanceof String) {
			    		sb.append(XML.escape(e.toString()));
					} else if (e instanceof JSONObject) {
						sb.append(toString((JSONObject)e));
					} else if (e instanceof JSONArray) {
						sb.append(toString((JSONArray)e));
					}
			    }
			}
			sb.append('<');
	        sb.append('/');
			sb.append(tagName);
	        sb.append('>');
	    }
    return sb.toString();
}","/**
 * Reverse the JSONML transformation, making an XML text from a JSONObject.
 * The JSONObject must contain a ""tagName"" property. If it has children, 
 * then it must have a ""childNodes"" property containing an array of objects. 
 * The other properties are attributes with string values.
 * @param jo A JSONObject.
 * @return An XML string.
 * @throws JSONException
 */
public static String toString(JSONObject jo) throws JSONException 
{
    StringBuffer sb = new StringBuffer();
    int i;
    JSONArray ja;
    String key, value;
    Object object;

    // Emit <tagName

    sb.append(""<"");
    sb.append(jo.getString(""tagName""));

    // Emit the attributes

    ja = jo.optJSONArray(""attributes"");
    if (ja != null)
    {
        for (i = 0; i < ja.length(); i += 1)
        {
            object = ja.get(i);
            if (object instanceof JSONObject)
            {
                JSONObject jo2 = (JSONObject) object;
                key = jo2.keys().next().toString();
                value = jo2.optString(key);
                sb.append("" "");
                sb.append(key);
                sb.append(""=\"""");
                sb.append(XML.escape(value));
                sb.append(""\"""");
            }
        }
    }

    // Emit content in body

    ja = jo.optJSONArray(""childNodes"");
    if (ja != null)
    {
        i = 0;
        for (Object anJa : ja)
        {
            object = ja.get(i);
            if (object instanceof String)
            {
                sb.append(XML.escape(object.toString()));
            } else if (object instanceof JSONObject)
            {
                sb.append(toString((JSONObject) object));
            } else if (object instanceof JSONArray)
            {
                sb.append(toString((JSONArray) object));
            }
            i += 1;
        }
    }
    sb.append("">"");
    return sb.toString();
}   ",517,True
"//
// VALIDATION
//
public static Boolean isEmpty(String s){
  if (s != null && !s.equals("""") && !s.equals(""\\N"") && !s.toLowerCase().equals(""null""))
    return false;

  return true;
}","//
// VALIDATION
//
public static Boolean isEmpty(String s) 
{
    if (s == null)
        return true;
    if (s.trim().length() == 0)
        return true;
    return false;
}   ",518,True
"/**
 * A fixable procedure must subclass one of the following methods
 */
public Value apply() throws ContinuationException{
    throwArgSizeException();
    return VOID;
}","/**
 * A fixable procedure must subclass one of the following methods
 */
public Value apply() throws ContinuationException 
{
    return null;
}   ",520,True
"/**
 * Copies all values from the specified attribute table.
 * If some attribute is exist its value should be overridden.
 *
 * @param table  the attribute table with new values
 */
private void addTable(Hashtable<String, Object> table){
    if ((table != null) && !table.isEmpty()) {
        getTable().putAll(table);
    }
}","/**
 * Copies all values from the specified attribute table.
 * If some attribute is exist its value should be overridden.
 *
 * @param table  the attribute table with new values
 */
private void addTable(Hashtable<String, Object> table) 
{
    if (table != null)
    {
        for (Map.Entry<String, Object> entry : table.entrySet())
        {
            setAttribute(entry.getKey(), entry.getValue());
        }
    }
}   ",521,True
"/// 6.2.5 Numerical operations
public void testNumbers()
    throws Exception{
    check(""(+ 3 4)"", ""7"");
    check(""(+ 3)"", ""3"");
    check(""(+)"", ""0"");
    check(""(* 4)"", ""4"");
    check(""(*)"", ""1"");


    check(""(+)"", ""0"");
    check(""(*)"", ""1"");

    check(""(- 1)"", ""-1"");
    check(""(/ 1)"",  ""1"");

    check(""(+ 3 3)"", ""6"");
    check(""(- 3 3)"", ""0"");
    check(""(* 3 3)"", ""9"");
    check(""(/ 3 3)"", ""1"");

    check(""(+  1 2 3 4)"", ""10"");
    check(""(-  1 2 3 4)"", ""-8"");
    check(""(*  1 2 3 4)"", ""24"");
    check(""(/ 24 2 3 4)"",  ""1"");
}","/// 6.2.5 Numerical operations
public void testNumbers()
    throws Exception 
{
    String[] script = {
        ""<script>"",
        ""var x = 1;"",
        ""var y = 2;"",
        ""var z = x + y;"",
        ""print(z);"",
        ""</script>""
    };

    Object res = evaluateScript(script);
    assertEquals(3, res);
}   ",522,False
"/// 4.2.1 Conditionals
public void no_test4_2_1()
    throws Exception{
    check(
        ""(cond ((> 3 2) 'greater)\n"" +
        ""      ((< 3 2) 'less))"",
        ""greater""
    );
    check(
        ""(cond ((> 3 3) 'greater)\n"" +
        ""      ((< 3 3) 'less))\n"" +
        ""      (else 'equal))"",
        ""equal""
    );
    check(
        ""(cond ((assv 'b '((a 1) (b 2))) => cadr)\n"" +
        ""      (else #f))"",
        ""2""
    );
}","/// 4.2.1 Conditionals
public void no_test4_2_1()
    throws Exception 
{
    String s = ""foo"";
    if (s.equals(""foo""))
    {
        System.out.println(""foo"");
    }
    else
    {
        System.out.println(""not foo"");
    }
}   ",523,False
"/**
 * Retrieve a named attribute with this feature.
 *
 * @param attributeName  The locale-independent name of the attribute
 * @return  The value of the attribute.  May be null if
 *     the attribute is unknown.
 */
public Object getValue(String attributeName){
    return (this.table != null)
            ? this.table.get(attributeName)
            : null;
}","/**
 * Retrieve a named attribute with this feature.
 *
 * @param attributeName  The locale-independent name of the attribute
 * @return  The value of the attribute.  May be null if
 *     the attribute is unknown.
 */
public Object getValue(String attributeName) 
{
    if (attributeName.equals(""name"")) {
        return getName();
    } else if (attributeName.equals(""value"")) {
        return getValue();
    } else {
        return null;
    }
}   ",525,True
"/// 6.1 Equivalence predicates
public void test6_1a()
    throws Exception{
    // eqv?
    check(""(eqv? 'a 'a)"", ""#t"");
    check(""(eqv? 'a 'b)"", ""#f"");
    check(""(eqv? 2 2)"", ""#t"");
    check(""(eqv? '() '())"", ""#t"");
    check(""(eqv? 100000000 100000000)"", ""#t"");
    check(""(eqv? (cons 1 2) (cons 1 2))"", ""#f"");
    check(""(eqv? (lambda () 1) (lambda () 2))"", ""#f"");
    check(""(eqv? #f 'nil)"", ""#f"");
    check(""(let ((p (lambda (x) x))) (eqv? p p))"", ""#t"");

    eval(
        ""(define gen-counter "" +
        ""  (lambda () "" +
        ""    (let ((n 0)) "" +
        ""      (lambda () "" +
        ""        (set! n (+ n 1)) "" +
        ""        n))))""
    );

    check(""(let ((g (gen-counter))) (eqv? g g))"", ""#t"");
    check(""(eqv? (gen-counter) (gen-counter))"", ""#f"");
    
    check(""(let ((x '(a))) (eqv? x x))"", ""#t"");
}","/// 6.1 Equivalence predicates
public void test6_1a()
    throws Exception 
{
    String sql = ""SELECT * FROM t1 WHERE a = b"";
    sql(sql).ok();
}   ",527,False
"/**
 * Returns the initialized attribute table.
 *
 * @return the initialized attribute table
 */
private Hashtable<String, Object> getTable(){
    if (this.table == null) {
        this.table = new Hashtable<String, Object>();
    }
    return this.table;
}","/**
 * Returns the initialized attribute table.
 *
 * @return the initialized attribute table
 */
private Hashtable<String, Object> getTable() 
{
    if (table == null)
    {
        table = new Hashtable<String, Object>();
    }
    return table;
}   ",532,True
"/// 4.1.1 Variable references
public void test4_1_1()
    throws Exception{
    eval(""(define x 28)"");
    check(""x"", ""28"");
}","/// 4.1.1 Variable references
public void test4_1_1()
    throws Exception 
{
    final String script = ""var x = 1; x;"";
    final Object result = evaluateExpression(script);
    assertEquals(1, result);
}   ",537,True
"/// 6.3.6 Vectors
public void test6_3_6()
    throws Exception{
    check(""(vector-ref '#(1 1 2 3 5 8 13 21) 5)"", ""8"");
    check(""(vector 'a 'b 'c)"", ""#(a b c)"");

    check(""(vector-length '#(1 2 3 4))"", ""4"");


}","/// 6.3.6 Vectors
public void test6_3_6()
    throws Exception 
{
    final String TEST_NAME = ""test6_3_6"";
    log.info(""+ "" + TEST_NAME);
    final int[] EXPECTED = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    final int[] RESULT = new int[10];
    int i = 0;
    for (int v : EXPECTED)
    {
        RESULT[i++] = v;
    }
    assertArrayEquals(EXPECTED, RESULT);
    log.info(""- "" + TEST_NAME);
}   ",538,True
"/**
 * Updates the digest using the specified byte.
 * Requires internal buffering, and may be slow.
 *
 * Overrides the protected abstract method of
 * java.security.MessageDigestSpi.
 * @param input  the byte to use for the update.
 */
public void engineUpdate(byte input){
    bytes++;
    if (padding < 63) {
        pad[padding++] = input;
        return;
    }
    pad[63] = input;
    computeBlock(pad, 0);
    padding = 0;
}","/**
 * Updates the digest using the specified byte.
 * Requires internal buffering, and may be slow.
 *
 * Overrides the protected abstract method of
 * java.security.MessageDigestSpi.
 * @param input  the byte to use for the update.
 */
public void engineUpdate(byte input) 
{
    if (bufferPos >= buffer.length)
    {
        digest.update(buffer, 0, bufferPos);
        bufferPos = 0;
    }
    buffer[bufferPos++] = input;
}   ",540,True
"/**
 * Completes the hash computation by performing final operations
 * such as padding. Once engineDigest has been called, the engine
 * will be automatically reset (see engineReset).
 *
 * Overrides the protected abstract method of
 * java.security.MessageDigestSpi.
 * @param hashvalue  the output buffer in which to store the digest.
 * @param offset  offset to start from in the output buffer
 * @param len  number of bytes within buf allotted for the digest.
 *             Both this default implementation and the SUN provider
 *             do not return partial digests.  The presence of this
 *             parameter is solely for consistency in our API's.
 *             If the value of this parameter is less than the
 *             actual digest length, the method will throw a
 *             DigestException.  This parameter is ignored if its
 *             value is greater than or equal to the actual digest
 *             length.
 * @return  the length of the digest stored in the output buffer.
 */
public int engineDigest(byte[] hashvalue, int offset, final int len)
        throws DigestException{
    if (len >= HASH_LENGTH) {
        if (hashvalue.length - offset >= HASH_LENGTH) {
            /* Flush the trailing bytes, adding padding bytes into last
             * blocks. */
            int i;
            /* Add padding null bytes but replace the last 8 padding bytes
             * by the little-endian 64-bit digested message bit-length. */
            pad[i = padding] = (byte)0x80; /* required 1st padding byte */
            /* Check if 8 bytes available in pad to store the total
             * message size */
            switch (i) { /* INVARIANT: i must be in [0..63] */
            case 52: pad[53] = (byte)0x00; /* no break; falls thru */
            case 53: pad[54] = (byte)0x00; /* no break; falls thru */
            case 54: pad[55] = (byte)0x00; /* no break; falls thru */
            case 55: break;
            case 56: pad[57] = (byte)0x00; /* no break; falls thru */
            case 57: pad[58] = (byte)0x00; /* no break; falls thru */
            case 58: pad[59] = (byte)0x00; /* no break; falls thru */
            case 59: pad[60] = (byte)0x00; /* no break; falls thru */
            case 60: pad[61] = (byte)0x00; /* no break; falls thru */
            case 61: pad[62] = (byte)0x00; /* no break; falls thru */
            case 62: pad[63] = (byte)0x00; /* no break; falls thru */
            case 63:
                computeBlock(pad, 0);
                /* Clear the 56 first bytes of pad[]. */
                i = 52;
                do {
                    pad[i    ] = (byte)0x00;
                    pad[i + 1] = (byte)0x00;
                    pad[i + 2] = (byte)0x00;
                    pad[i + 3] = (byte)0x00;
                } while ((i -= 4) >= 0);
                break;
            default:
                /* Clear the rest of 56 first bytes of pad[]. */
                switch (i & 3) {
                case 3: i++;
                        break;
                case 2: pad[(i += 2) - 1] = (byte)0x00;
                        break;
                case 1: pad[(i += 3) - 2] = (byte)0x00;
                        pad[ i       - 1] = (byte)0x00;
                        break;
                case 0: pad[(i += 4) - 3] = (byte)0x00;
                        pad[ i       - 2] = (byte)0x00;
                        pad[ i       - 1] = (byte)0x00;
                }
                do {
                    pad[i    ] = (byte)0x00;
                    pad[i + 1] = (byte)0x00;
                    pad[i + 2] = (byte)0x00;
                    pad[i + 3] = (byte)0x00;
                } while ((i += 4) < 56);
            }
            /* Convert the message size from bytes to big-endian bits. */
            pad[56] = (byte)((i = (int)(bytes >>> 29)) >> 24);
            pad[57] = (byte)(i >>> 16);
            pad[58] = (byte)(i >>> 8);
            pad[59] = (byte)i;
            pad[60] = (byte)((i = (int)bytes << 3) >> 24);
            pad[61] = (byte)(i >>> 16);
            pad[62] = (byte)(i >>> 8);
            pad[63] = (byte)i;
            computeBlock(pad, 0);
            /* Return the computed digest in big-endian byte order. */
            hashvalue[offset     ] = (byte)((i = hA) >>> 24);
            hashvalue[offset +  1] = (byte)(i >>> 16);
            hashvalue[offset +  2] = (byte)(i >>> 8);
            hashvalue[offset +  3] = (byte)i;
            hashvalue[offset +  4] = (byte)((i = hB) >>> 24);
            hashvalue[offset += 5] = (byte)(i >>> 16);
            hashvalue[offset +  1] = (byte)(i >>> 8);
            hashvalue[offset +  2] = (byte)i;
            hashvalue[offset +  3] = (byte)((i = hC) >>> 24);
            hashvalue[offset +  4] = (byte)(i >>> 16);
            hashvalue[offset += 5] = (byte)(i >>> 8);
            hashvalue[offset +  1] = (byte)i;
            hashvalue[offset +  2] = (byte)((i = hD) >>> 24);
            hashvalue[offset +  3] = (byte)(i >>> 16);
            hashvalue[offset +  4] = (byte)(i >>> 8);
            hashvalue[offset += 5] = (byte)i;
            hashvalue[offset +  1] = (byte)((i = hE) >>> 24);
            hashvalue[offset +  2] = (byte)(i >>> 16);
            hashvalue[offset +  3] = (byte)(i >>> 8);
            hashvalue[offset +  4] = (byte)i;
            engineReset(); /* clear the evidence */
            return HASH_LENGTH;
        }
        throw new DigestException(
            ""insufficient space in output buffer to store the digest"");
    }
    throw new DigestException(""partial digests not returned"");
}","/**
 * Completes the hash computation by performing final operations
 * such as padding. Once engineDigest has been called, the engine
 * will be automatically reset (see engineReset).
 *
 * Overrides the protected abstract method of
 * java.security.MessageDigestSpi.
 * @param hashvalue  the output buffer in which to store the digest.
 * @param offset  offset to start from in the output buffer
 * @param len  number of bytes within buf allotted for the digest.
 *             Both this default implementation and the SUN provider
 *             do not return partial digests.  The presence of this
 *             parameter is solely for consistency in our API's.
 *             If the value of this parameter is less than the
 *             actual digest length, the method will throw a
 *             DigestException.  This parameter is ignored if its
 *             value is greater than or equal to the actual digest
 *             length.
 * @return  the length of the digest stored in the output buffer.
 */
public int engineDigest(byte[] hashvalue, int offset, final int len)
        throws DigestException 
{
    if (len < 20)
        throw new DigestException(""partial digests not returned"");
    if (offset < 0 || len < 0 || offset + len > hashvalue.length)
        throw new ArrayIndexOutOfBoundsException(""offset or len out of range"");
    System.arraycopy(digest, 0, hashvalue, offset, 20);
    engineReset();
    return 20;
}       ",541,True
"/*
 * Read the specified number of bytes as a little-endian (least significant
 * byte first) integer. Note: bytes must be less than the byte width of
 * ""unsigned long int"" on your platform (e.g. 8 for 32-bit systems).
 */
public static int readLE(RandomAccessFile stm, int bytes) throws IOException{

	int x, res = 0;

	for (x = 0; x < bytes; x++) {
		res |= stm.read() << (x * 8);
	}
	return res;
}","/*
 * Read the specified number of bytes as a little-endian (least significant
 * byte first) integer. Note: bytes must be less than the byte width of
 * ""unsigned long int"" on your platform (e.g. 8 for 32-bit systems).
 */
public static int readLE(RandomAccessFile stm, int bytes) throws IOException 
{
    int num = 0;
    for (int i = 0; i < bytes; i++)
    {
        num |= (stm.read() & 0xFF) << (i * 8);
    }
    return num;
}   ",542,True
"/* A full KZTREE_BLOCKSIZE bytes have become available; 
 * hash those, and possibly composite together siblings. */
private void kztreeBlock(){

  byte[] md5 = Md5Handler.md5(leaf, index);
  System.arraycopy(md5, 0, nodes, topIndex, md5.length);
  topIndex += MD5_SIZE;
  
  ++count;
  gen = count; 
  while(gen == ((gen >> 1)<<1)) { // while evenly divisible by 2...
    kztreeCompose();
    gen = gen >> 1;
  }
}","/* A full KZTREE_BLOCKSIZE bytes have become available; 
 * hash those, and possibly composite together siblings. */
private void kztreeBlock() 
{
    if (kztreeBlockHashing) {
        kztreeBlockHashing = false;
        kztreeBlockHash();
    } else {
        kztreeBlockComposite();
    }
}   ",545,False
"/** For testing, take a command-line argument in Base32, decode, print in hex,
 * encode, print
 *
 * @param args
 */
static public void main(String[] args){
    if (args.length == 0) {
        System.out.println(""Supply a Base32-encoded argument."");
        return;
    }
    System.out.println("" Original: "" + args[0]);
    byte[] decoded = Base32.decode(args[0]);
    System.out.print(""      Hex: "");
    for (int i = 0; i < decoded.length; i++) {
        int b = decoded[i];
        if (b < 0) {
            b += 256;
        }
        System.out.print((Integer.toHexString(b + 256)).substring(1));
    }
    System.out.println();
    System.out.println(""Reencoded: "" + Base32.encode(decoded));
}","/** For testing, take a command-line argument in Base32, decode, print in hex,
 * encode, print
 *
 * @param args
 */
static public void main(String[] args) 
{
    if (args.length != 1)
    {
        System.out.println(""Usage: java Base32 <base32>"");
        return;
    }

    byte[] decoded = Base32.decode(args[0]);
    System.out.println(Hex.toHexString(decoded));

    String encoded = Base32.encode(decoded);
    System.out.println(encoded);
}   ",547,True
"/**
 * Update the internal state with a single block of size 1024 (or less, in
 * final block) from the internal buffer.
 */
protected void blockUpdate(){
    tiger.reset();
    tiger.update((byte) 0); // leaf prefix
    tiger.update(buffer, 0, bufferOffset);
    if ((bufferOffset == 0) & (nodes.size() > 0))
        return; // don't remember a zero-size hash except at very beginning
    nodes.add(tiger.digest());
    blockCount++;
    long interimNode = blockCount; 
    while((interimNode % 2)==0) { // even
        composeNodes();
        interimNode >>= 1;
    }
}","/**
 * Update the internal state with a single block of size 1024 (or less, in
 * final block) from the internal buffer.
 */
protected void blockUpdate() 
{
    compress();

    /*
     * update the internal MD buffer.
     */
    for (int i = 0; i < 8; i++)
    {
        state[i] += digest[i];
    }
}   ",550,True
"/* Encodes input (int[]) into output (byte[]). 
 * Assumes len is a multiple of 4. */
private static void encode(byte[] output, int[] input, int len){
	
	ByteBuffer buf = ByteBuffer.allocate(len);
	buf.order(ByteOrder.LITTLE_ENDIAN);
	IntBuffer intBuf = buf.asIntBuffer();
	intBuf.put(input, 0, len / 4);
	buf.get(output, 0, len);
}","/* Encodes input (int[]) into output (byte[]). 
 * Assumes len is a multiple of 4. */
private static void encode(byte[] output, int[] input, int len) 
{
    int i, j;
    for (i = 0, j = 0; j < len; i++, j += 4)
    {
        output[j] = (byte)(input[i] & 0xff);
        output[j+1] = (byte)((input[i] >> 8) & 0xff);
        output[j+2] = (byte)((input[i] >> 16) & 0xff);
        output[j+3] = (byte)((input[i] >> 24) & 0xff);
    }
}   ",552,False
"/**
 * Encodes byte array to Base32 String.
 *
 * @param bytes Bytes to encode.
 * @return Encoded byte array <code>bytes</code> as a String.
 *
 */
static public String encode(final byte[] bytes){
    int i = 0, index = 0, digit = 0;
    int currByte, nextByte;
    StringBuffer base32 = new StringBuffer((bytes.length + 7) * 8 / 5);

    while (i < bytes.length) {
        currByte = (bytes[i] >= 0) ? bytes[i] : (bytes[i] + 256); // unsign

        /* Is the current digit going to span a byte boundary? */
        if (index > 3) {
            if ((i + 1) < bytes.length) {
                nextByte =
                    (bytes[i + 1] >= 0) ? bytes[i + 1] : (bytes[i + 1] + 256);
            } else {
                nextByte = 0;
            }

            digit = currByte & (0xFF >> index);
            index = (index + 5) % 8;
            digit <<= index;
            digit |= nextByte >> (8 - index);
            i++;
        } else {
            digit = (currByte >> (8 - (index + 5))) & 0x1F;
            index = (index + 5) % 8;
            if (index == 0)
                i++;
        }
        base32.append(base32Chars.charAt(digit));
    }

    return base32.toString();
}","/**
 * Encodes byte array to Base32 String.
 *
 * @param bytes Bytes to encode.
 * @return Encoded byte array <code>bytes</code> as a String.
 *
 */
static public String encode(final byte[] bytes) 
{
    int i = 0, index = 0, digit = 0;
    int currByte, nextByte;
    StringBuffer result = new StringBuffer();

    while (i < bytes.length)
    {
        currByte = (bytes[i] >= 0) ? bytes[i] : (bytes[i] + 256);

        /* Is the current digit going to span a byte boundary? */
        if (index > 3)
        {
            if ((i + 1) < bytes.length)
                nextByte = (bytes[i + 1] >= 0) ? bytes[i + 1] : (bytes[i + 1] + 256);
            else
                nextByte = 0;

            digit = currByte & (0xFF >> index);
            index = (index + 5) % 8;
            digit <<= index;
            digit |= nextByte >> (8 - index);
            i++;
        }
        else
        {
            digit = (currByte >> (8 - (index + 5))) & 0x1F;
            index = (index + 5) % 8;
            if (index == 0)
                i++;
        }
        result.append(base32Chars.charAt(digit));
    }

    return result.toString();
}   ",553,False
"/* Decodes input (unsigned char) into output (w32). 
 * Assumes len is a multiple of 4. */
private static void decode(int[] output, byte[] input, int ofs, int len){
	
	ByteBuffer buf = ByteBuffer.wrap(input, ofs, len);
	buf.order(ByteOrder.LITTLE_ENDIAN);
	IntBuffer intBuf = buf.asIntBuffer();
	intBuf.get(output, 0, len / 4);
}","/* Decodes input (unsigned char) into output (w32). 
 * Assumes len is a multiple of 4. */
private static void decode(int[] output, byte[] input, int ofs, int len) 
{
  int end = ofs + len;
  int i, j;

  for (i = 0, j = 0; j < len; i++, j += 4)
  {
    output[i] = ((input[j] & 0xff)) |
                ((input[j+1] & 0xff) << 8) |
                ((input[j+2] & 0xff) << 16) |
                ((input[j+3] & 0xff) << 24);
  }
}   ",554,True
"/**
 * Completes the hash computation by performing final operations
 * such as padding. Computes the final hash and returns the final
 * value as a byte[20] array. Once engineDigest has been called,
 * the engine will be automatically reset as specified in the
 * JavaSecurity MessageDigest specification.
 *
 * For faster operations with multiple digests, allocate your own
 * array and use engineDigest(byte[], int offset, int len).
 *
 * Overrides the protected abstract method of
 * java.security.MessageDigestSpi.
 * @return the length of the digest stored in the output buffer.
 */
public byte[] engineDigest(){
    try {
        final byte hashvalue[] = new byte[HASH_LENGTH];
        engineDigest(hashvalue, 0, HASH_LENGTH);
        return hashvalue;
    } catch (DigestException e) {
        return null;
    }
}","/**
 * Completes the hash computation by performing final operations
 * such as padding. Computes the final hash and returns the final
 * value as a byte[20] array. Once engineDigest has been called,
 * the engine will be automatically reset as specified in the
 * JavaSecurity MessageDigest specification.
 *
 * For faster operations with multiple digests, allocate your own
 * array and use engineDigest(byte[], int offset, int len).
 *
 * Overrides the protected abstract method of
 * java.security.MessageDigestSpi.
 * @return the length of the digest stored in the output buffer.
 */
public byte[] engineDigest() 
{
    byte[] result = new byte[20];
    int    offset = 0;

    engineDigest(result, offset, 20);
    return result;
}   ",556,True
"/* Same as above, but big-endian (most significant byte first) ordering */
public static int readBE(RandomAccessFile stm, int bytes) throws IOException{

	int x, res = 0;

	for (x = bytes - 1; x >= 0; x--) {
		res |= stm.read() << (x * 8);
	}

	return res;
}","/* Same as above, but big-endian (most significant byte first) ordering */
public static int readBE(RandomAccessFile stm, int bytes) throws IOException 
{
    int result = 0;
    for (int i = 0; i < bytes; i++)
    {
        result = (result << 8) + stm.read();
    }
    return result;
}   ",557,True
"/**
 * Draws the outline of the specified rectangle using the current color. Use drawRect(x, y, width-1, height-1) to
 * draw the outline inside the specified rectangle.
 *
 * @param x      the x coordinate
 * @param y      the y coordinate
 * @param width  the width of the rectangle
 * @param height the height of the rectangle
 * @see #fillRect
 * @see #clearRect
 */
public void drawRect(int x, int y, int width, int height){
    prt(""%drawRect"");
    doRect(x, y, width, height, false);
}","/**
 * Draws the outline of the specified rectangle using the current color. Use drawRect(x, y, width-1, height-1) to
 * draw the outline inside the specified rectangle.
 *
 * @param x      the x coordinate
 * @param y      the y coordinate
 * @param width  the width of the rectangle
 * @param height the height of the rectangle
 * @see #fillRect
 * @see #clearRect
 */
public void drawRect(int x, int y, int width, int height) 
{
    drawLine(x, y, x + width, y); // Top line
    drawLine(x, y + height, x + width, y + height); // Bottom line
    drawLine(x, y, x, y + height); // Left line
    drawLine(x + width, y, x + width, y + height); // Right line
}   ",560,True
"/**
 * Draws the specified image at the specified coordinate (x, y). If the image is incomplete the image observer will
 * be notified later.
 *
 * @param img      the specified image to be drawn
 * @param x        the x coordinate
 * @param y        the y coordinate
 * @param observer notifies if the image is complete or not
 * @see Image
 * @see ImageObserver
 */
public boolean drawImage(Image img, int x, int y, ImageObserver observer){
    prt(""%drawImage-1"");

    return doImage(img, x, y, 0, 0, observer, null);

}","/**
 * Draws the specified image at the specified coordinate (x, y). If the image is incomplete the image observer will
 * be notified later.
 *
 * @param img      the specified image to be drawn
 * @param x        the x coordinate
 * @param y        the y coordinate
 * @param observer notifies if the image is complete or not
 * @see Image
 * @see ImageObserver
 */
public boolean drawImage(Image img, int x, int y, ImageObserver observer) 
{
    if (img == null)
    {
        return true;
    }

    return drawImage(img, x, y, img.getWidth(observer), img.getHeight(observer), observer);
}   ",561,True
"/**
 * Fills the specified rectangle with the current color.
 *
 * @param x      the x coordinate
 * @param y      the y coordinate
 * @param width  the width of the rectangle
 * @param height the height of the rectangle
 * @see #drawRect
 * @see #clearRect
 */
public void fillRect(int x, int y, int width, int height){
    prt(""%fillRect"");
    doRect(x, y, width, height, true);
}","/**
 * Fills the specified rectangle with the current color.
 *
 * @param x      the x coordinate
 * @param y      the y coordinate
 * @param width  the width of the rectangle
 * @param height the height of the rectangle
 * @see #drawRect
 * @see #clearRect
 */
public void fillRect(int x, int y, int width, int height) 
{
    fillRect(x, y, width, height, false);
}   ",562,True
"/**
 * Draws the specified image inside the specified rectangle. The image is scaled if necessary. If the image is
 * incomplete the image observer will be notified later.
 *
 * @param img      the specified image to be drawn
 * @param x        the x coordinate
 * @param y        the y coordinate
 * @param width    the width of the rectangle
 * @param height   the height of the rectangle
 * @param bgcolor  the background color
 * @param observer notifies if the image is complete or not
 * @see Image
 * @see ImageObserver NOTE: PSGr ignores the background color.
 */
public boolean drawImage(Image img, int x, int y,
                         int width, int height, Color bgcolor,
                         ImageObserver observer){
    prt(""%drawImage-4"");
    return doImage(img, x, y, width, height, observer, bgcolor);
}","/**
 * Draws the specified image inside the specified rectangle. The image is scaled if necessary. If the image is
 * incomplete the image observer will be notified later.
 *
 * @param img      the specified image to be drawn
 * @param x        the x coordinate
 * @param y        the y coordinate
 * @param width    the width of the rectangle
 * @param height   the height of the rectangle
 * @param bgcolor  the background color
 * @param observer notifies if the image is complete or not
 * @see Image
 * @see ImageObserver NOTE: PSGr ignores the background color.
 */
public boolean drawImage(Image img, int x, int y,
                         int width, int height, Color bgcolor,
                         ImageObserver observer) 
{
    if (img == null)
    {
        throw new NullPointerException(""Null image"");
    }
    if (width < 0 || height < 0)
    {
        throw new IllegalArgumentException(""image dimensions can't be negative"");
    }
    if (x < 0 || y < 0)
    {
        throw new IllegalArgumentException(""image coordinates can't be negative"");
    }
    if (width == 0 || height == 0)
    {
        return true;
    }
    return drawImageNative(img, x, y, width, height, bgcolor, observer);
}   ",564,True
"/**
 * Draws an oval inside the specified rectangle using the current color.
 *
 * @param x      the x coordinate
 * @param y      the y coordinate
 * @param width  the width of the rectangle
 * @param height the height of the rectangle
 * @see #fillOval
 */
public void drawOval(int x, int y, int width, int height){
    prt(""%drawOval"");
    doArc(x, y, width, height, 0, 360, false);
}","/**
 * Draws an oval inside the specified rectangle using the current color.
 *
 * @param x      the x coordinate
 * @param y      the y coordinate
 * @param width  the width of the rectangle
 * @param height the height of the rectangle
 * @see #fillOval
 */
public void drawOval(int x, int y, int width, int height) 
{
    if (g != null)
    {
        g.drawOval(x, y, width, height);
    }
}   ",566,True
"/**
 * Draws a polygon defined by the specified point.
 *
 * @param p the specified polygon
 * @see #fillPolygon
 */
public void drawPolygon(Polygon p){
    prt(""%drawPoly"");
    doPoly(p.xpoints, p.ypoints, p.npoints, false);
}","/**
 * Draws a polygon defined by the specified point.
 *
 * @param p the specified polygon
 * @see #fillPolygon
 */
public void drawPolygon(Polygon p) 
{
    drawPolygon(p.xpoints, p.ypoints, p.npoints);
}   ",567,True
"/**
 * check whether Rserve is currently running (on local machine and default port).
 *
 * @return <code>true</code> if local Rserve instance is running, <code>false</code> otherwise
 */
public static boolean isRserveRunning(){
    try {
        RConnection c = new RConnection();
        System.out.println(""Rserve is running."");
        c.close();

        hasR = true;

        return true;
    } catch (Exception e) {
        System.out.println(""First connect try failed with: "" + e.getMessage());
    }
    return false;
}","/**
 * check whether Rserve is currently running (on local machine and default port).
 *
 * @return <code>true</code> if local Rserve instance is running, <code>false</code> otherwise
 */
public static boolean isRserveRunning() 
{
    return isRserveRunning(""localhost"", RserveConfiguration.DEFAULT_RSERVE_PORT);
}   ",570,True
"// This constructor added by David Binger.
public PSGr(OutputStream o, Graphics g, Dimension s, Point origin, String[] extras){
    os = new PrintWriter(o);
    this.g = g;
    int bbax = origin.x;
    int bbay = PAGEHEIGHT - origin.y - s.height;
    int bbbx = bbax + s.width;
    int bbby = bbay + s.height;
    prt(""%!PS-Adobe-2.0 EPSF-1.2"");
    prt(""%%BoundingBox: "" + bbax + "" "" + bbay + "" "" + bbbx + "" "" + bbby);
    if (extras != null)
        for (int j = 0; j < extras.length; j++)
            prt(""%"" + extras[j]);
    prt(""% Output Generated by PSGr Java PostScript Context"");
    //    translate(tx,ty);
    setFont(font);
    // cliprect(bbax,bbay,s.width,s.height);
}","// This constructor added by David Binger.
public PSGr(OutputStream o, Graphics g, Dimension s, Point origin, String[] extras) 
{
    super(o, g, s, origin, extras);
    this.g = g;
    this.o = o;
    this.s = s;
    this.origin = origin;
    this.extras = extras;
}   ",571,True
"/**
 * Clips to a rectangle. The resulting clipping area is the intersection of the current clipping area and the
 * specified rectangle. Graphic operations have no effect outside of the clipping area.
 *
 * @param x      the x coordinate
 * @param y      the y coordinate
 * @param width  the width of the rectangle
 * @param height the height of the rectangle
 * @see #getClipBounds()
 */
public void clipRect(int x, int y, int width, int height){
    prt(""%clipRect"");
    y = transformY(y);
    clippingRect = new Rectangle(x, y, width, height);
    prt(""initclip"");
    prt(x, y, ""moveto"");
    prt(x + width, y, ""lineto"");
    prt(x + width, y - height, ""lineto"");
    prt(x, y - height, ""lineto"");
    prt(""closepath eoclip newpath"");
}","/**
 * Clips to a rectangle. The resulting clipping area is the intersection of the current clipping area and the
 * specified rectangle. Graphic operations have no effect outside of the clipping area.
 *
 * @param x      the x coordinate
 * @param y      the y coordinate
 * @param width  the width of the rectangle
 * @param height the height of the rectangle
 * @see #getClipBounds()
 */
public void clipRect(int x, int y, int width, int height) 
{
    int rect[] = new int[4];
    rect[0] = x;
    rect[1] = y;
    rect[2] = width;
    rect[3] = height;
    clipRect(rect);
}   ",572,True
"/**
 * Constructs a new PSGr Object. Unlike regular Graphics objects, PSGr contexts can be created directly.
 *
 * @param o Output stream for PostScript output
 * @see #create
 */
public PSGr(OutputStream o, Graphics g){
    os = new PrintWriter(o);
    this.g = g;
    emitProlog();
}","/**
 * Constructs a new PSGr Object. Unlike regular Graphics objects, PSGr contexts can be created directly.
 *
 * @param o Output stream for PostScript output
 * @see #create
 */
public PSGr(OutputStream o, Graphics g) 
{
    this.outputStream = o;
    this.graphics = g;
}   ",574,True
"/**
 * attempt to start Rserve. Note: parameters are <b>not</b> quoted, so avoid using any quotes in arguments
 *
 * @param cmd      command necessary to start R
 * @param rargs    arguments are are to be passed to R
 * @param rsrvargs arguments to be passed to Rserve
 * @return <code>true</code> if Rserve is running or was successfully started, <code>false</code> otherwise.
 */
public static boolean launchRserve(String cmd, String rargs, String rsrvargs, boolean debug){
    try {
        Process p;
        boolean isWindows = false;
        String osname = System.getProperty(""os.name"");
        if (osname != null && osname.length() >= 7 && osname.substring(0, 7).equals(""Windows"")) {
            isWindows = true; /* Windows startup */
            p = Runtime.getRuntime().exec(""\"""" + cmd + ""\"" -e \""library(Rserve);Rserve("" + (debug ? ""TRUE"" : ""FALSE"") + "",args='"" + rsrvargs + ""')\"" "" + rargs);
        } else /* unix startup */
            p = Runtime.getRuntime().exec(new String[]{
                    ""/bin/sh"", ""-c"",
                    ""echo 'library(Rserve);Rserve("" + (debug ? ""TRUE"" : ""FALSE"") + "",args=\"""" + rsrvargs + ""\"")'|"" + cmd + "" "" + rargs
            });
        System.out.println(""waiting for Rserve to start ... ("" + p + "")"");
        // we need to fetch the output - some platforms will die if you don't ...
        StreamHog errorHog = new StreamHog(p.getErrorStream(), false);
        StreamHog outputHog = new StreamHog(p.getInputStream(), false);
        if (!isWindows) /* on Windows the process will never return, so we cannot wait */
            p.waitFor();
        System.out.println(""call terminated, let us try to connect ..."");
    } catch (Exception x) {
        System.out.println(""failed to start Rserve process with "" + x.getMessage());
        return false;
    }
    int attempts = 5; /* try up to 5 times before giving up. We can be conservative here, because at this point the process execution itself was successful and the start up is usually asynchronous */
    while (attempts > 0) {
        try {
            RConnection c = new RConnection();
            System.out.println(""Rserve is running."");
            c.close();
            return true;
        } catch (Exception e2) {
            System.out.println(""Try failed with: "" + e2.getMessage());
        }
        /* a safety sleep just in case the start up is delayed or asynchronous */
        try {
            Thread.sleep(500);
        } catch (InterruptedException ignored) {
        }
        attempts--;
    }
    return false;
}","/**
 * attempt to start Rserve. Note: parameters are <b>not</b> quoted, so avoid using any quotes in arguments
 *
 * @param cmd      command necessary to start R
 * @param rargs    arguments are are to be passed to R
 * @param rsrvargs arguments to be passed to Rserve
 * @return <code>true</code> if Rserve is running or was successfully started, <code>false</code> otherwise.
 */
public static boolean launchRserve(String cmd, String rargs, String rsrvargs, boolean debug) 
{
    if (RserveDaemon == null)
    {
        try
        {
            RserveDaemon = new RserveDaemonLocal(cmd, rargs, rsrvargs);
            RserveDaemon.start();
        }
        catch (Exception e)
        {
            if (debug)
                System.err.println(""Failed to start Rserve process: "" + e.getMessage());
            return false;
        }
    }
    return true;
}   ",577,True
"/**
 * Return the servlet output stream associated with this Response.
 *
 * @exception IllegalStateException if <code>getWriter</code> has
 *  already been called for this response
 * @exception IOException if an input/output error occurs
 */
public ServletOutputStream getOutputStream() throws IOException{

    if (writer != null)
        throw new IllegalStateException(""getWriter() has already been called for this response"");

    if (stream == null)
        stream = createOutputStream();
    if (debug > 1) {
        System.out.println(""stream is set to ""+stream+"" in getOutputStream"");
    }

    return (stream);

}","/**
 * Return the servlet output stream associated with this Response.
 *
 * @exception IllegalStateException if <code>getWriter</code> has
 *  already been called for this response
 * @exception IOException if an input/output error occurs
 */
public ServletOutputStream getOutputStream() throws IOException 
{
    if (servletOutputStream != null)
        return servletOutputStream;

    if (writer != null)
        throw new IllegalStateException(""getWriter() has already been called for this response"");

    servletOutputStream = new ServletOutputStreamImpl(this);
    return servletOutputStream;
}   ",583,True
"/**
 * Place this filter into service.
 *
 * @param filterConfig The filter configuration object
 */
public void init(FilterConfig filterConfig) throws ServletException{

	this.filterConfig = filterConfig;
    this.encoding = filterConfig.getInitParameter(""encoding"");
    String value = filterConfig.getInitParameter(""ignore"");
    if (value == null)
        this.ignore = true;
    else if (value.equalsIgnoreCase(""true""))
        this.ignore = true;
    else if (value.equalsIgnoreCase(""yes""))
        this.ignore = true;
    else
        this.ignore = false;

}","/**
 * Place this filter into service.
 *
 * @param filterConfig The filter configuration object
 */
public void init(FilterConfig filterConfig) throws ServletException 
{
    String param = filterConfig.getInitParameter(""encoding"");
    if (param != null)
    {
        encoding = param;
    }
}   ",586,True
"/**
 * Set content type
 */
public void setContentType(String contentType){
    if (debug > 1) {
        System.out.println(""setContentType to ""+contentType);
    }
    this.contentType = contentType;
    origResponse.setContentType(contentType);
}","/**
 * Set content type
 */
public void setContentType(String contentType) 
{
    if (contentType == null)
    {
        throw new IllegalArgumentException(""Content type cannot be null"");
    }

    this.contentType = contentType;
}   ",590,True
"/**
 * The <code>doFilter</code> method of the Filter is called by the container
 * each time a request/response pair is passed through the chain due
 * to a client request for a resource at the end of the chain.
 * The FilterChain passed into this method allows the Filter to pass on the
 * request and response to the next entity in the chain.<p>
 * This method first examines the request to check whether the client support
 * compression. <br>
 * It simply just pass the request and response if there is no support for
 * compression.<br>
 * If the compression support is available, it creates a
 * CompressionServletResponseWrapper object which compresses the content and
 * modifies the header if the content length is big enough.
 * It then invokes the next entity in the chain using the FilterChain object
 * (<code>chain.doFilter()</code>), <br>
 **/
public void doFilter ( ServletRequest request, ServletResponse response,
                    FilterChain chain ) throws IOException, ServletException{

    if (debug > 0) {
        System.out.println(""@doFilter"");
    }

    if (compressionThreshold == 0) {
        if (debug > 0) {
            System.out.println(""doFilter gets called, but compressionTreshold is set to 0 - no compression"");
        }
        chain.doFilter(request, response);
        return;
    }

    boolean supportCompression = false;
    if (request instanceof HttpServletRequest) {
        if (debug > 1) {
            System.out.println(""requestURI = "" + ((HttpServletRequest)request).getRequestURI());
        }

        // Are we allowed to compress ?
        String s = (String) ((HttpServletRequest)request).getParameter(""gzip"");
        if (""false"".equals(s)) {
            if (debug > 0) {
                System.out.println(""got parameter gzip=false --> don't compress, just chain filter"");
            }
            chain.doFilter(request, response);
            return;
        }

        Enumeration e =
            ((HttpServletRequest)request).getHeaders(""Accept-Encoding"");
        while (e.hasMoreElements()) {
            String name = (String)e.nextElement();
            if (name.indexOf(""gzip"") != -1) {
                if (debug > 0) {
                    System.out.println(""supports compression"");
                }
                supportCompression = true;
            } else {
                if (debug > 0) {
                    System.out.println(""no support for compresion"");
                }
            }
        }
    }

    if (!supportCompression) {
        if (debug > 0) {
            System.out.println(""doFilter gets called wo compression"");
        }
        chain.doFilter(request, response);
        return;
    } else {
        if (response instanceof HttpServletResponse) {
            CompressionServletResponseWrapper wrappedResponse =
                new CompressionServletResponseWrapper((HttpServletResponse)response);
            wrappedResponse.setDebugLevel(debug);
            wrappedResponse.setCompressionThreshold(compressionThreshold);
            if (debug > 0) {
                System.out.println(""doFilter gets called with compression"");
            }
            try {
                chain.doFilter(request, wrappedResponse);
            } finally {
                wrappedResponse.finishResponse();
            }
            return;
        }
    }
}","/**
 * The <code>doFilter</code> method of the Filter is called by the container
 * each time a request/response pair is passed through the chain due
 * to a client request for a resource at the end of the chain.
 * The FilterChain passed into this method allows the Filter to pass on the
 * request and response to the next entity in the chain.<p>
 * This method first examines the request to check whether the client support
 * compression. <br>
 * It simply just pass the request and response if there is no support for
 * compression.<br>
 * If the compression support is available, it creates a
 * CompressionServletResponseWrapper object which compresses the content and
 * modifies the header if the content length is big enough.
 * It then invokes the next entity in the chain using the FilterChain object
 * (<code>chain.doFilter()</code>), <br>
 **/



public void doFilter ( ServletRequest request, ServletResponse response,
                    FilterChain chain ) throws IOException, ServletException 
{
    if ( request instanceof HttpServletRequest )
    {
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        HttpServletResponse httpResponse = (HttpServletResponse) response;

        if ( acceptEncoding( httpRequest ) )
        {
            CompressionServletResponseWrapper wrappedResponse =
                new CompressionServletResponseWrapper( httpResponse );
            chain.doFilter( request, wrappedResponse );
            wrappedResponse.close();
        }
        else
        {
            chain.doFilter( request, response );
        }
    }
    else
    {
        chain.doFilter( request, response );
    }
}   ",591,False
"/**
 * Process start tag
 *
 * @return EVAL_BODY_INCLUDE
 */
public int doStartTag() throws JspException{
    i = 0;
	return EVAL_BODY_TAG;
}","/**
 * Process start tag
 *
 * @return EVAL_BODY_INCLUDE
 */


public int doStartTag() throws JspException 
{
    try
    {
        JspWriter out = pageContext.getOut();
        out.print(""<div class=\""tab-pane\"" id=\"""");
        out.print(getId());
        out.print(""\"">"");
        return EVAL_BODY_INCLUDE;
    }
    catch (IOException e)
    {
        throw new JspException(e);
    }
}   ",592,True
"/**
 * Create and return a ServletOutputStream to write the content
 * associated with this Response.
 *
 * @exception IOException if an input/output error occurs
 */
public ServletOutputStream createOutputStream() throws IOException{
    if (debug > 1) {
        System.out.println(""createOutputStream gets called"");
    }

    CompressionResponseStream stream = new CompressionResponseStream(origResponse);
    stream.setDebugLevel(debug);
    stream.setBuffer(threshold);

    return stream;

}","/**
 * Create and return a ServletOutputStream to write the content
 * associated with this Response.
 *
 * @exception IOException if an input/output error occurs
 */
public ServletOutputStream createOutputStream() throws IOException 
{
    if (outputStream == null)
    {
        outputStream = new ChunkedServletOutputStream(this);
    }
    return outputStream;
}   ",595,True
"//> TEST METHODS
	/**
	 * Test {@link CsvExporter#exportContacts(File, List, CsvRowFormat)}.
	 * @throws IOException If there was an unexpected error writing or reading to a file
	 */
public void testContactExport() throws IOException{
		// Export a number of contacts to a file, and check that the generated file is as expected.
		ArrayList<Contact> contacts = new ArrayList<Contact>();
		contacts.add(new Contact(""Test Number"", ""000"", """", """", """", true));
		contacts.add(new Contact(""شئهة"", ""07890123456"", ""0987654321"", ""azim@mo.jo"", """", false));
		contacts.add(new Contact(""Sly Eddie"", ""01234567890"", ""554466221133"", ""sly.eddie@ramprakash.co.uk"", ""Sly Eddie is a sneaky chap."", true));
		contacts.add(new Contact(""Richard E. Grant"", ""+44852774"", ""+1800-RICH-ARDE"", """", ""\""What a piece of work is a man!\"""", true));

		// Make sure the English i18n bundle is available to provision the export column names
		LanguageBundle englishBundle = InternationalisationUtils.getLanguageBundleFromClasspath(""/resources/languages/frontlineSMS.properties"");
		Thinlet.DEFAULT_ENGLISH_BUNDLE = englishBundle.getProperties();
		
		File generatedFile = super.getOutputFile(this.getClass().getSimpleName() + "".contacts.csv"");
		CsvExporter.exportContacts(generatedFile, contacts, getContactExportRowFormat());
		//assertEquals(""Generated CSV file did not contain the expected values."", this.getClass().getResourceAsStream(this.getClass().getSimpleName() + "".contacts.csv""), new FileInputStream(generatedFile));
	}","//> TEST METHODS
	/**
	 * Test {@link CsvExporter#exportContacts(File, List, CsvRowFormat)}.
	 * @throws IOException If there was an unexpected error writing or reading to a file
	 */


public void testContactExport() throws IOException 
{
	File file = new File(""test.csv"");
	List<Contact> contacts = new ArrayList<Contact>();
	contacts.add(new Contact(""John"", ""Doe"", ""1234567890""));
	contacts.add(new Contact(""Jane"", ""Doe"", ""0987654321""));
	CsvExporter.exportContacts(file, contacts, CsvRowFormat.DEFAULT);
	String fileContents = FileUtils.readFileToString(file);
	assertEquals(""John,Doe,1234567890\nJane,Doe,0987654321\n"", fileContents);
	file.delete();
}	",601,True
"/**
 * This Load Balancing implementation returns every other available gateway
 * on each invocation.
 */
@SuppressWarnings(""unchecked"")
public AGateway balance(OutboundMessage msg, List candidates){
	if (currentGateway >= candidates.size()) currentGateway = 0;
	return ((AGateway) candidates.get(currentGateway++));
}","/**
 * This Load Balancing implementation returns every other available gateway
 * on each invocation.
 */
@SuppressWarnings(""unchecked"")
public AGateway balance(OutboundMessage msg, List candidates) 
{
    if (candidates.isEmpty())
    {
        return null;
    }
    return (AGateway) candidates.get(0);
}   ",603,True
"/**
 * Convert an array of {@link String}s into a comma-separated list of {@link String}s.
 * @param strings
 * @return A list of the strings provided in the array separated by commas and surrounded by curly braces
 */
private static final String toString(String[] strings){
	String ret = ""{"";
	for(String s : strings) {
		ret += s + "", "";
	}
	return ret.substring(0, ret.length()-2) + ""}"";
}","/**
 * Convert an array of {@link String}s into a comma-separated list of {@link String}s.
 * @param strings
 * @return A list of the strings provided in the array separated by commas and surrounded by curly braces
 */
private static final String toString(String[] strings) 
{
    StringBuilder sb = new StringBuilder();
    sb.append(""{"");
    for (int i = 0; i < strings.length; i++)
    {
        sb.append(strings[i]);
        if (i < strings.length - 1)
        {
            sb.append("","");
        }
    }
    sb.append(""}"");
    return sb.toString();
}   ",605,True
"/**
 * Blocking method which will check that the database can connect.  If connection fails, this will be conveyed
 * to the user, who can then re-attempt connection, or modify their settings.
 */
public void ensureConnected(){
	int retryInMillis = 1000;
	while(!checkConnection()) {
		System.out.println(""Connection failed.  Will retry in "" + retryInMillis + ""ms""); // FIXME remove sysout
		// TODO we should display a UI to the user with the following
		// 1. details of the connection problem
		// 2. the option to change database settings
		// 3. a button to attempt reconnection
		sleep(retryInMillis);
		// Double the time til the next retry.
		retryInMillis <<= 1;
	}
	// Connected successfully, so it's now safe to return
}","/**
 * Blocking method which will check that the database can connect.  If connection fails, this will be conveyed
 * to the user, who can then re-attempt connection, or modify their settings.
 */
public void ensureConnected() 
{
    if (!isConnected())
    {
        try
        {
            connect();
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }
}   ",606,False
"//> ACCESSORS
	/**
	 * @return the pdu of this sms 
	 * @throws IllegalStateException if this sms comprises more than one pdu 
	 */
public String getMessagePdu() throws IllegalStateException{
		if(this.messagePdus.length != 1) {
			throw new IllegalStateException(""Cannot get single PDU of a multipart message."");
		}
		return this.messagePdus[0];
	}","//> ACCESSORS
	/**
	 * @return the pdu of this sms 
	 * @throws IllegalStateException if this sms comprises more than one pdu 
	 */
public String getMessagePdu() throws IllegalStateException 
{
	if (pdus.size() > 1)
	{
		throw new IllegalStateException(""This sms comprises more than one pdu"");
	}
	return pdus.get(0);
}	",607,True
"/**
 * Flags the internal thread to stop running.
 */
public void stopRunning(){
	this.running = false;
	for (EmailAccount acc : serverHandlers.keySet()) {
		serverHandlers.get(acc).stopRunning();
	}
}","/**
 * Flags the internal thread to stop running.
 */
public void stopRunning() 
{
    if (thread != null)
    {
        thread.interrupt();
    }
}   ",609,False
"//> CONSTRUCTORS
	/**
	 * Create a new {@link DatabaseConnectionTester}.
	 * @param frontlineSms 
	 */
public DatabaseConnectionTester(FrontlineSMS frontlineSms){
		// Cache the contact DAO so we can run tests using it.
		this.contactDao = frontlineSms.getContactDao();
		assert(this.contactDao != null) : ""The "" + this.getClass() + "" requires a "" + ContactDao.class.getSimpleName() + "" to function correctly."";
	}","//> CONSTRUCTORS
	/**
	 * Create a new {@link DatabaseConnectionTester}.
	 * @param frontlineSms 
	 */
public DatabaseConnectionTester(FrontlineSMS frontlineSms) 
{
	this.frontlineSms = frontlineSms;
}	",611,True
"/**
 * Save the selected language
 * @param list
 */
public void setLanguage(Object list){
	Object sel = getSelectedItem(list);
	AppProperties appProperties = AppProperties.getInstance();
	String filename = getAttachedObject(sel).toString();
	appProperties.setLanguageFilename(filename);
	LanguageBundle languageBundle = InternationalisationUtils.getLanguageBundle(new File(ResourceUtils.getConfigDirectoryPath() + ""languages/"" + filename));
	FrontlineUI.currentResourceBundle = languageBundle;
	setResourceBundle(languageBundle.getProperties(), languageBundle.isRightToLeft());
	Font font = languageBundle.getFont();
	if(font != null) {
		setFont(new Font(font.getName(), getFont().getStyle(), getFont().getSize()));
	}
	appProperties.saveToDisk();
	frameLauncher.setTitle(InternationalisationUtils.getI18NString(I18N_FIRST_TIME_WIZARD_TITLE));
	loadPages();
	showPage(0);
}","/**
 * Save the selected language
 * @param list
 */
public void setLanguage(Object list) 
{
    if (list instanceof Language)
    {
        Language language = (Language) list;
        this.language = language;
    }
}   ",612,False
"/**
 * Remove the supplied email from outbox.
 * 
 * @param deleted
 */
public void removeFromOutbox(Email deleted){
	LOG.trace(""ENTER"");
	outbox.remove(deleted);
	LOG.debug(""Email ["" + deleted + ""] removed from outbox. Size is ["" + outbox.size() + ""]"");
	LOG.trace(""EXIT"");
}","/**
 * Remove the supplied email from outbox.
 * 
 * @param deleted
 */
public void removeFromOutbox(Email deleted) 
{
    if (outbox.contains(deleted))
    {
        outbox.remove(deleted);
    }
}   ",617,True
"/**
 * Start the FrontlineSMS user interface. 
 * @throws Throwable if {@link Throwable} was thrown by {@link UiGeneratorController}'s constructor.
 */
public void startFrontline() throws Throwable{
	AppProperties appProperties = AppProperties.getInstance();
	appProperties.setShowWizard(false);
	appProperties.saveToDisk();
	
	UiProperties uiProperties = UiProperties.getInstance();
	uiProperties.setViewModeClassic(this.classicView);
	uiProperties.saveToDisk();
	
	frameLauncher.dispose();
	new UiGeneratorController(frontline, true);
}","/**
 * Start the FrontlineSMS user interface. 
 * @throws Throwable if {@link Throwable} was thrown by {@link UiGeneratorController}'s constructor.
 */
public void startFrontline() throws Throwable 
{
    UiGeneratorController uiGeneratorController = new UiGeneratorController();
    uiGeneratorController.start();
}   ",618,False
"/**
 * Handle incomming protocol command with id.
 */
private void handleIncomingRawCommand(String cmd){
	System.out.println(""R:"" + cmd);
	int break_index = cmd.indexOf(':');
	if (break_index == -1) {
		protocolFailure(""no ':' found"");
		return;
	}
	int id = Integer.parseInt(cmd.substring(0, break_index).trim());
	if (id != messageInCounter) {
		protocolFailure(
				""invalid id: ""
				+ String.valueOf(id)
				+ ""; should be: ""
				+ String.valueOf(messageInCounter)
				);
	}
	messageInCounter++;
	handleIncomingCommand(cmd.substring(
				break_index+1, cmd.length()
				).trim());
}","/**
 * Handle incomming protocol command with id.
 */
private void handleIncomingRawCommand(String cmd) 
{
    if (cmd.startsWith(""id""))
    {
        String[] parts = cmd.split("" "");
        if (parts.length == 2)
        {
            this.id = Integer.parseInt(parts[1]);
            System.out.println(""ID set to "" + this.id);
        }
    }
}   ",620,True
"/**
 * Is game currently active.
 */
public boolean isActive(){
	if (gameController == null) {
		return false;
	}

	if (!gameController.isActive()) {
		return false;
	}
	return true;
}","/**
 * Is game currently active.
 */
public boolean isActive() 
{
    return active;
}   ",621,True
"/**
 * Called after connection was estabilished.
 */
public void handleTransportConnected(
		RemoteGameControllerTransport t, String s
		){
	parent.handleRemoteGameControllerInfo(
			this,
			""GC Transport: connected: "" + s
			);
}","/**
 * Called after connection was estabilished.
 */
public void handleTransportConnected(
		RemoteGameControllerTransport t, String s
		) 
{
	// Add the transport to the list of transports
	transports.add(t);

	// Notify the listener
	if (listener != null)
		listener.onTransportConnected(t, s);
}	",622,True
"/**
 * Request from current server giving user control over the black stones.
 */
public void playBlack(){
	if (gameController != null) {
		gameController.handleColor(Board.COLOR_BLACK);
	}
}","/**
 * Request from current server giving user control over the black stones.
 */
public void playBlack() 
{
    if (this.currentPlayer == 1)
    {
        this.currentPlayer = 2;
    }
    else
    {
        this.currentPlayer = 1;
    }
}   ",625,True
"/**
 * Create local go server (arbiter) and
 * play game locally, listening for
 * incoming players.
 */
public void beServer(){
	shutdown();
	try {
		LocalArbiter arbiter = new LocalArbiter(this);
		gameController = new LocalGameController(board, logView);
		arbiter.connected(gameController);
		this.arbiter = arbiter;
	} catch (LocalArbiter.CreationError e) {
		logView.appendString(
			""Couldn't create server. Reason: `""
			+ e.getMessage() + ""'""
			);
	}
}","/**
 * Create local go server (arbiter) and
 * play game locally, listening for
 * incoming players.
 */
public void beServer() 
{
    // Create local go server (arbiter)
    GoServer server = new GoServer();

    // Play game locally, listening for incoming players
    server.playGame();
}   ",626,True
"/**
 * Repaint board.
 *
 * Board need redrawing crosshair every time, so it overloads
 * paint function.
 */
public void paint(Graphics g){
	super.paint(g);
	paintCrosshair(g);
	bgRefreshNeeded = false;
	lastTime = System.currentTimeMillis();
}","/**
 * Repaint board.
 *
 * Board need redrawing crosshair every time, so it overloads
 * paint function.
 */
public void paint(Graphics g) 
{
    super.paint(g);
    drawCrosshair(g);
}   ",627,True
"/**
 * Pause application.
 */
protected void pauseApp(){
	try {
		goban.stop();
		thread.join();
	} catch (InterruptedException ie) {}
}","/**
 * Pause application.
 */
protected void pauseApp() 
{
    Display.getInstance().callSerially(new Runnable()
    {
        public void run()
        {
            if (current != null)
            {
                current.show();
            }
        }
    });
}   ",630,False
"/**
 * Request from current server giving user control over white stones.
 */
public void playWhite(){
	if (gameController != null) {
		gameController.handleColor(Board.COLOR_WHITE);
	}
}","/**
 * Request from current server giving user control over white stones.
 */
public void playWhite() 
{
    if (this.isWhiteTurn()) {
        this.setWhiteTurn(false);
        this.setBlackTurn(true);
        this.setWhiteControl(true);
        this.setBlackControl(false);
    }
}   ",634,True
"/**
 * Register new GameController in poller.
 */
public void registerNewRemoteGameControllerTransport(
		RemoteGameControllerTransport gct
		){
	synchronized (remoteGameControllerTransports) {
		for (int i = 0; i < remoteGameControllerTransports.size(); ++i) {
			if (remoteGameControllerTransports.elementAt(i) == null) {
				remoteGameControllerTransports.setElementAt(gct, i);
				return;
			}
		}
		remoteGameControllerTransports.addElement(gct);
	}
}","/**
 * Register new GameController in poller.
 */
public void registerNewRemoteGameControllerTransport(
		RemoteGameControllerTransport gct
		) 
{
	RemoteGameControllerTransport[] newGcts = new RemoteGameControllerTransport[gcts.length+1];
	for(int i=0; i<gcts.length; i++)
		newGcts[i] = gcts[i];
	newGcts[gcts.length] = gct;
	gcts = newGcts;
}	",635,True
"/**
 * Poll all the registered objects.
 */
protected void loopThroghGameControllers(){
	synchronized (remoteGameControllerTransports) {
		for (int i = 0; i < remoteGameControllerTransports.size(); ++i) {
			if (remoteGameControllerTransports.elementAt(i) != null) {
				RemoteGameControllerTransport gc =
					(RemoteGameControllerTransport)
					remoteGameControllerTransports.elementAt(i);
				try {
					gc.poll();
				} catch (IOException e) {
					// TODO: unregister anywere?
					remoteGameControllerTransports.setElementAt(null, i);
				}
			}
		}
	}
}","/**
 * Poll all the registered objects.
 */
protected void loopThroghGameControllers() 
{
    for (int i = 0; i < gameControllers.size(); i++)
    {
        gameControllers.get(i).poll();
    }
}   ",636,False
"/**
 * Append string to log.
 *
 * FIX: binary search would be soo much better...
 */
public synchronized void appendString(String str){
	if (str.length() == 0) {
		return;
	}
	for (int l = str.length(); l > 0; --l) {
		if (logFont.substringWidth(str, 0, l) < parent.getXSize()) {
			drawString(str.substring(0, l));
			appendString(str.substring(l, str.length()));
			return;
		}
	}
	drawString(""??? ASSERT ERROR !!!"");
}","/**
 * Append string to log.
 *
 * FIX: binary search would be soo much better...
 */
public synchronized void appendString(String str) 
{
    if (str == null)
    {
        return;
    }
    if (mLog.length() > 0)
    {
        mLog.append(""\n"");
    }
    mLog.append(str);
}   ",637,True
"/**
 * Receive from stream.
 *
 * Non-blocking function that should
 * handle incoming acks and commands.
 */
private boolean receiveOne() throws IOException{
	int available = in.available();
	// XXX: TODO: potential bug
	// utf strings that comes partially may be
	// broken in such a way that
	// String(new_data) will fail
	// screw that for now
	if (available > 0) {
		byte new_data[] = new byte[available];
		in.read(new_data);
		int newBufSize = receivingBuf.length + available;
		byte[] newBuf = new byte[newBufSize];
		for (int i = 0; i < receivingBuf.length; ++i) {
			newBuf[i] = receivingBuf[i];
		}

		for (int i = receivingBuf.length; i < newBufSize; ++i) {
			newBuf[i] = new_data[i - receivingBuf.length];
		}
		receivingBuf = newBuf;
	}
	String bufString = new String(receivingBuf, ""UTF8"");

	int break_index = bufString.indexOf('\n');
	if (break_index != -1) {
		// cmd without break
		String cmd = bufString.substring(0, break_index);
		// rest of the buf without break
		receivingBuf = bufString.substring(
				break_index + 1, bufString.length()
				).getBytes(""UTF8"");
				if (!cmd.equals("""")) {
			handleIncomingRawCommand(cmd);
			return true;
		}
	}
	return false;
}","/**
 * Receive from stream.
 *
 * Non-blocking function that should
 * handle incoming acks and commands.
 */
private boolean receiveOne() throws IOException 
{
    if (in.available() > 0)
    {
        int command = in.read();
        switch (command)
        {
            case Protocol.COMMAND_ACK:
                handleAck();
                break;
            case Protocol.COMMAND_MESSAGE:
                handleMessage();
                break;
            default:
                System.out.println(""Unknown command: "" + command);
                break;
        }
        return true;
    }
    return false;
}   ",638,False
"/**
 * Returns the descriptors of the properties for the connection
 * 
 * @return
 */
private IPropertyDescriptor[] initializePropertyDescriptors(){
    // the flow properties
    String flowCategory = Messages.getLabelString(SELECTED_FLOW_ID) + "" { ""
            + flowInfo.getIdentifier() + "" }"";
    ArrayList<IPropertyDescriptor> descriptors = new ArrayList<IPropertyDescriptor>();

    PropertyDescriptor descriptor = new PropertyDescriptor(ID_ID, Messages
            .getLabelString(ID_ID));
    descriptor.setDescription(Messages.getLabelString(ID_DESCRIPTION));
    descriptor.setCategory(flowCategory);
    descriptors.add(descriptor);

    descriptor = new PropertyDescriptor(STATUS_ID, Messages
            .getLabelString(STATUS_ID));
    descriptor.setDescription(Messages.getLabelString(STATUS_DESCRIPTION));
    descriptor.setCategory(flowCategory);
    descriptors.add(descriptor);

    descriptor = new PropertyDescriptor(CREATION_TIME_ID, Messages
            .getLabelString(CREATION_TIME_ID));
    descriptor.setDescription(Messages
            .getLabelString(CREATION_TIME_DESCRIPTION));
    descriptor.setCategory(flowCategory);
    descriptors.add(descriptor);

    descriptor = new PropertyDescriptor(REPLYABLE_ID, Messages
            .getLabelString(REPLYABLE_ID));
    descriptor.setDescription(Messages
            .getLabelString(REPLYABLE_DESCRIPTION));
    descriptor.setCategory(flowCategory);
    descriptors.add(descriptor);

    descriptor = new PropertyDescriptor(ACK_COUNT_ID, Messages
            .getLabelString(ACK_COUNT_ID));
    descriptor.setDescription(Messages
            .getLabelString(ACK_COUNT_DESCRIPTION));
    descriptor.setCategory(flowCategory);
    descriptors.add(descriptor);

    descriptor = new PropertyDescriptor(ACK_EXPECTED_COUNT_ID, Messages
            .getLabelString(ACK_EXPECTED_COUNT_ID));
    descriptor.setDescription(Messages
            .getLabelString(ACK_EXPECTED_COUNT_DESCRIPTION));
    descriptor.setCategory(flowCategory);
    descriptors.add(descriptor);

    descriptor = new PropertyDescriptor(REPLAY_TIME_ID, Messages
            .getLabelString(REPLAY_TIME_ID));
    descriptor.setDescription(Messages
            .getLabelString(REPLY_TIME_DESCRIPTION));
    descriptor.setCategory(flowCategory);
    descriptors.add(descriptor);

    descriptor = new PropertyDescriptor(NAK_COUNT_ID, Messages
            .getLabelString(NAK_COUNT_ID));
    descriptor.setDescription(Messages
            .getLabelString(NAK_COUNT_DESCRIPTION));
    descriptor.setCategory(flowCategory);
    descriptors.add(descriptor);

    descriptor = new PropertyDescriptor(REPLY_COUNT_ID, Messages
            .getLabelString(REPLY_COUNT_ID));
    descriptor.setDescription(Messages
            .getLabelString(REPLY_COUNT_DESCRIPTION));
    descriptor.setCategory(flowCategory);
    descriptors.add(descriptor);

    descriptor = new PropertyDescriptor(APPLICATION_ID, Messages
            .getLabelString(APPLICATION_ID));
    descriptor.setDescription(Messages
            .getLabelString(APPLICATION_DESCRIPTION));
    descriptor.setCategory(flowCategory);
    descriptors.add(descriptor);

    descriptor = new PropertyDescriptor(PARTS_COUNT_ID, Messages
            .getLabelString(PARTS_COUNT_ID));
    descriptor.setDescription(Messages
            .getLabelString(PARTS_COUNT_DESCRIPTION));
    descriptor.setCategory(flowCategory);
    descriptors.add(descriptor);

    // The part properties
    for (IFlowPartInfo info : flowInfo.getPartInfos()) {
        String path = info.getPath();

        String thisPathCategory = Messages.getLabelString(FLOW_PART_ID)
                + "" { "" + info.getPath() + "" }"";

        String pid = budildFlowPartPropertyId(FLOW_PART_STATUS_ID, path);
        descriptor = new PropertyDescriptor(pid, Messages
                .getLabelString(FLOW_PART_STATUS_ID));
        descriptor.setDescription(Messages
                .getLabelString(FLOW_PART_STATUS_DESCRIPTION));
        descriptor.setCategory(thisPathCategory);
        descriptor.setAlwaysIncompatible(true);
        descriptors.add(descriptor);

        pid = budildFlowPartPropertyId(FLOW_PART_CONTRIBUTION_COUNT_ID,
                path);
        descriptor = new PropertyDescriptor(pid, Messages
                .getLabelString(FLOW_PART_CONTRIBUTION_COUNT_ID));
        descriptor.setDescription(Messages
                .getLabelString(FLOW_PART_CONTRIBUTION_COUNT_DESCRIPTION));
        descriptor.setCategory(thisPathCategory);
        descriptor.setAlwaysIncompatible(true);
        descriptors.add(descriptor);

        pid = budildFlowPartPropertyId(FLOW_PART_PATH_ID, path);
        descriptor = new PropertyDescriptor(pid, Messages
                .getLabelString(FLOW_PART_PATH_ID));
        descriptor.setDescription(Messages
                .getLabelString(FLOW_PART_PATH_ID));
        descriptor.setCategory(thisPathCategory);
        descriptor.setAlwaysIncompatible(true);
        descriptors.add(descriptor);

        pid = budildFlowPartPropertyId(FLOW_PART_FILTER_TIME_ID, path);
        descriptor = new PropertyDescriptor(pid, Messages
                .getLabelString(FLOW_PART_FILTER_TIME_ID));
        descriptor.setDescription(Messages
                .getLabelString(FLOW_PART_FILTER_TIME_DESCRIPTION));
        descriptor.setCategory(thisPathCategory);
        descriptor.setAlwaysIncompatible(true);
        descriptors.add(descriptor);

        pid = budildFlowPartPropertyId(FLOW_PART_CONTRIBUTION_TIME_ID, path);
        descriptor = new PropertyDescriptor(pid, Messages
                .getLabelString(FLOW_PART_CONTRIBUTION_TIME_ID));
        descriptor.setDescription(Messages
                .getLabelString(FLOW_PART_CONTRIBUTION_TIME_DESCRIPTION));
        descriptor.setCategory(thisPathCategory);
        descriptor.setAlwaysIncompatible(true);
        descriptors.add(descriptor);

        pid = budildFlowPartPropertyId(FLOW_PART_DURATION_MS_ID, path);
        descriptor = new PropertyDescriptor(pid, Messages
                .getLabelString(FLOW_PART_DURATION_MS_ID));
        descriptor.setDescription(Messages
                .getLabelString(FLOW_PART_DURATION_MS_DESCRIPTION));
        descriptor.setCategory(thisPathCategory);
        descriptor.setAlwaysIncompatible(true);
        descriptors.add(descriptor);

    }

    return descriptors.toArray(new IPropertyDescriptor[descriptors.size()]);
}","/**
 * Returns the descriptors of the properties for the connection
 * 
 * @return
 */
private IPropertyDescriptor[] initializePropertyDescriptors() 
{
    if (propertyDescriptors == null)
    {
        propertyDescriptors = new IPropertyDescriptor[3];
        propertyDescriptors[0] = new PropertyDescriptor(""name"", ""Name"");
        propertyDescriptors[0].setCategory(""General"");
        propertyDescriptors[1] = new PropertyDescriptor(""description"", ""Description"");
        propertyDescriptors[1].setCategory(""General"");
        propertyDescriptors[2] = new PropertyDescriptor(""url"", ""URL"");
        propertyDescriptors[2].setCategory(""General"");
    }
    return propertyDescriptors;
}   ",640,False
"/**
 * Constructs a flowPart info with the given path with status CLEAN with
 * initial values.
 * 
 * @param path
 */
public FlowPartInfoMock(String path){
    this.path = path;
    this.status = true;
    this.contributionDate = new Date();
    this.pathDuration = 100;
    this.contributionCount = 1;
    this.filterTime = null;
    this.filterCount = 0;
}","/**
 * Constructs a flowPart info with the given path with status CLEAN with
 * initial values.
 * 
 * @param path
 */
public FlowPartInfoMock(String path) 
{
    this.path = path;
    this.status = FlowPartStatus.CLEAN;
    this.size = 0;
    this.modificationTime = 0;
    this.accessTime = 0;
    this.blockSize = 0;
    this.replication = 0;
    this.storagePolicy = 0;
}   ",644,True
"/**
 * @see org.eclipse.ui.views.properties.IPropertySource#getPropertyValue(java.lang.Object)
 */
public Object getPropertyValue(Object id){
    if (id instanceof MBeanOperationInfo) {
        MBeanOperationInfo oi = (MBeanOperationInfo) id;
        return MBeanUtils.buildOperationSignature(oi);
    }
    return null;
}","/**
 * @see org.eclipse.ui.views.properties.IPropertySource#getPropertyValue(java.lang.Object)
 */
public Object getPropertyValue(Object id) 
{
    if (id.equals(""name""))
    {
        return name;
    }
    else if (id.equals(""value""))
    {
        return value;
    }
    else
    {
        return null;
    }
}   ",645,False
"/**
 * Creates mbean node with the given Name and ObjectName
 * 
 * @param name
 */
public MBeanNode(String name, ObjectName objectName, MBeanInfo mbeanInfo){
    super(name);
    this.addObjectName(objectName);
    this.mbeanInfo = mbeanInfo;
    this.propertySouce = new MBeanPropertySource(mbeanInfo, objectName);
}","/**
 * Creates mbean node with the given Name and ObjectName
 * 
 * @param name
 */
public MBeanNode(String name, ObjectName objectName, MBeanInfo mbeanInfo) 
{
    this.name = name;
    this.objectName = objectName;
    this.mbeanInfo = mbeanInfo;
}   ",646,True
"/**
 * Executes safely the runnable in the Eclipse UI thread. If the Thread
 * cannot be associated with a UI session in RAP, does nothing.
 * 
 * @param runnable
 */
public static void runSafe(Runnable runnable){

    IJobManager jobMan = Job.getJobManager();
    Job job = jobMan.currentJob();
    if (job instanceof SessionSafeWorkerJob) {
        SessionSafeWorkerJob sessionWorkerJob = (SessionSafeWorkerJob) job;
        sessionWorkerJob.getDisplay().asyncExec(runnable);
    } else if (Display.getCurrent() != null) {
        runnable.run();
    } else {
        Thread t = Thread.currentThread();
        if (Display.getDefault() == null) {
            // this is the RAP case
            Activator
                    .getDefault()
                    .error(
                            ""Updating the GUI from a notitfication forwarder is not handle currently in RAP! (Unable to determine the UI session)"");
        } else {
            if (t.getName().contains(""ClientNotifForwarder"")) {
                Display.getDefault().asyncExec(runnable);
                return;
            }
        }
        throw new IllegalStateException(
                ""Updating the GUI from a non SessionSafeWorkerJob!"");
    }
}","/**
 * Executes safely the runnable in the Eclipse UI thread. If the Thread
 * cannot be associated with a UI session in RAP, does nothing.
 * 
 * @param runnable
 */

public static void runSafe(Runnable runnable) 
{
    Display display = Display.getCurrent();
    if (display != null)
    {
        display.asyncExec(runnable);
    }
}   ",649,False
"/**
 * @see org.eclipse.ui.views.properties.IPropertySource#getPropertyDescriptors()
 */
@Override
public IPropertyDescriptor[] getPropertyDescriptors(){
    ArrayList<IPropertyDescriptor> descriptors = new ArrayList<IPropertyDescriptor>();
    PropertyDescriptor pd = new PropertyDescriptor(DESCRIPTION_KEY,
            descriptionDisplayName);
    pd.setAlwaysIncompatible(true);
    pd.setCategory(propertiesCategoryDisplayName);
    descriptors.add(pd);

    pd = new PropertyDescriptor(TYPE_KEY, typeDisplayName);
    pd.setCategory(propertiesCategoryDisplayName);
    pd.setAlwaysIncompatible(true);
    descriptors.add(pd);

    pd = new PropertyDescriptor(NAME_KEY, nameDisplayName);
    pd.setFilterFlags(new String[] { propertiesCategoryDisplayName,
            nameDisplayName });
    pd.setAlwaysIncompatible(true);
    pd.setCategory(propertiesCategoryDisplayName);
    descriptors.add(pd);

    pd = new PropertyDescriptor(READABLE_KEY, readableDisplayName);
    pd.setCategory(propertiesCategoryDisplayName);
    pd.setAlwaysIncompatible(true);
    descriptors.add(pd);

    pd = new PropertyDescriptor(WRITABLE_KEY, writableDisplayName);
    pd.setCategory(propertiesCategoryDisplayName);
    pd.setAlwaysIncompatible(true);
    descriptors.add(pd);

    if (MBeanUtils.isSimpleWritableType(objectName, attributeInfo)) {
        pd = new MBeanSimpleWritableAttributePropertyDescriptor(
                connectionConfiguration, objectName, attributeInfo,
                VALUE_KEY, attributeInfo.getName());
    } else {
        pd = new PropertyDescriptor(VALUE_KEY, attributeInfo.getName());
    }
    pd.setAlwaysIncompatible(true);
    pd.setCategory(editableCategoryDisplayName);
    pd.setFilterFlags(new String[] { this.objectName.toString(),
            propertiesCategoryDisplayName, attributeInfo.getName() });
    descriptors.add(pd);

    pd = new PropertyDescriptor(IS_IS_KEY, isIsDisplayName);
    pd.setCategory(propertiesCategoryDisplayName);
    descriptors.add(pd);
    descriptors.addAll(Arrays.asList(super.getPropertyDescriptors()));
    return descriptors.toArray(new IPropertyDescriptor[descriptors.size()]);
}","/**
 * @see org.eclipse.ui.views.properties.IPropertySource#getPropertyDescriptors()
 */
@Override
public IPropertyDescriptor[] getPropertyDescriptors() 
{
    if (propertyDescriptors == null)
    {
        propertyDescriptors = new IPropertyDescriptor[]
        {
            PropertyDescriptorFactory.stringPropertyDescriptor(""name"", ""Name""),
            PropertyDescriptorFactory.stringPropertyDescriptor(""value"", ""Value"")
        };
    }
    return propertyDescriptors;
}   ",651,False
"/*
 * (non-Javadoc)
 * 
 * @see
 * org.eclipse.ui.plugin.AbstractUIPlugin#start(org.osgi.framework.BundleContext
 * )
 */
@Override
public void start(BundleContext context) throws Exception{
    super.start(context);
    plugin = this;

    serializer = new ConnectionRepositoryObjectStreamSerializer();
    info(""Starting IPF Manager Connection bundle"");
    ConnectionConfigurationRepository repository = serializer.read(null);
    jMXConnectionManager = new JMXConnectionManagerImpl(repository);

    jMXConnectionManagerServiceRegistration = context.registerService(
            IJMXConnectionManager.class.getName(), jMXConnectionManager,
            new Hashtable<String, String>());
    info(""IJMXConnectionManager service registered."");
    connectionPreferences.updateSystemProperties();
}","/*
 * (non-Javadoc)
 * 
 * @see
 * org.eclipse.ui.plugin.AbstractUIPlugin#start(org.osgi.framework.BundleContext
 * )
 */
@Override
public void start(BundleContext context) throws Exception 
{
    super.start(context);
    plugin = this;
    initializeImageRegistry();
    initializeResourceBundle();
}   ",654,False
"/**
 * Writes this attribute value to the MBEan server.
 * 
 * @param connectionConfiguration
 *            the connection context.
 * @param objectName
 *            the ObjectName of the specified MBean
 * @param attributeInfo
 *            the AtributeInfo object.
 * @param attributeValue
 *            the new Value
 */
public void writeAttributeValue(
        IConnectionConfiguration connectionConfiguration,
        ObjectName objectName, MBeanAttributeInfo attributeInfo,
        String attributeValue){
    // convert
    Object value = convertStringValueToObjectValue(attributeInfo.getType(),
            attributeValue);
    Attribute attribute = new Attribute(attributeInfo.getName(), value);
    JMXExplorerEvent event;
    try {
        mBeanServerConnection.setAttribute(objectName, attribute);

        event = new JMXExplorerEvent(connectionConfiguration,
                JMXExplorerEvent.ATTRIBUTE_VALUE_CHANGED, objectName,
                attribute, attributeInfo);
    } catch (Exception t) {
        // we fould exception, no mather what, the attribute value was not
        // set
        Activator.getDefault().error(""writeAttributeValue failed"", t);
        event = new JMXExplorerEvent(connectionConfiguration,
                JMXExplorerEvent.CHANGE_ATTRIBUTE_VALUE_ERROR, objectName,
                t, attributeInfo);
        return;
    }
    jmxExplorerMediator.notifyObserversWithJMXEvent(event);
}","/**
 * Writes this attribute value to the MBEan server.
 * 
 * @param connectionConfiguration
 *            the connection context.
 * @param objectName
 *            the ObjectName of the specified MBean
 * @param attributeInfo
 *            the AtributeInfo object.
 * @param attributeValue
 *            the new Value
 */

public void writeAttributeValue(
        IConnectionConfiguration connectionConfiguration,
        ObjectName objectName, MBeanAttributeInfo attributeInfo,
        String attributeValue) 
{
    try
    {
        MBeanServerConnection mbsc = connectionConfiguration.getMBeanServerConnection();
        mbsc.setAttribute(objectName, new Attribute(attributeInfo.getName(), attributeValue));
    }
    catch (Exception e)
    {
        throw new RuntimeException(e);
    }
}       ",655,False
"/**
 * Constructs MbeanAttributePropertySource
 * 
 * @param connectionConfiguration
 *            the connection to which this property belongs
 * @param objectName
 *            the ObjectName of the MBean to which this property belongs
 * @param attributeInfo
 *            the AttributeInfo for this property
 */
public MBeanAttributePropertySource(
        IConnectionConfiguration connectionConfiguration,
        ObjectName objectName, MBeanAttributeInfo attributeInfo){
    super(attributeInfo.getDescriptor());
    this.objectName = objectName;
    this.attributeInfo = attributeInfo;
    this.connectionConfiguration = connectionConfiguration;
}","/**
 * Constructs MbeanAttributePropertySource
 * 
 * @param connectionConfiguration
 *            the connection to which this property belongs
 * @param objectName
 *            the ObjectName of the MBean to which this property belongs
 * @param attributeInfo
 *            the AttributeInfo for this property
 */
public MBeanAttributePropertySource(
        IConnectionConfiguration connectionConfiguration,
        ObjectName objectName, MBeanAttributeInfo attributeInfo) 
{
    this.connectionConfiguration = connectionConfiguration;
    this.objectName = objectName;
    this.attributeInfo = attributeInfo;
}       ",657,True
"/**
 * @see org.eclipse.jface.viewers.CellEditor#createControl(org.eclipse.swt.widgets.Composite)
 */
@Override
protected Control createControl(Composite parent){
    composite = new Composite(parent, SWT.NONE);
    GridLayout layout = new GridLayout(2, false);
    layout.marginHeight = 0;
    layout.marginBottom = 0;
    layout.horizontalSpacing = 0;
    layout.marginWidth = 0;
    layout.marginLeft = 0;
    layout.verticalSpacing = 0;

    composite.setLayout(layout);

    text = new Text(composite, SWT.PUSH);
    text.setEditable(true);
    text.setEnabled(true);

    GridData textLayoutData = new GridData(SWT.FILL, SWT.NONE, true, false,
            1, 1);
    textLayoutData.heightHint = 15;
    textLayoutData.minimumWidth = 40;
    text.setLayoutData(textLayoutData);

    Button setButton = new Button(composite, SWT.PUSH);
    GridData bLayoutData = new GridData(SWT.NONE, SWT.NONE, false, false,
            1, 1);
    bLayoutData.heightHint = 15;
    setButton.setLayoutData(bLayoutData);
    setButton.addSelectionListener(this);
    setButton.setText(setButtonText);
    return composite;
}","/**
 * @see org.eclipse.jface.viewers.CellEditor#createControl(org.eclipse.swt.widgets.Composite)
 */
@Override
protected Control createControl(Composite parent) 
{
    return new Combo(parent, SWT.DROP_DOWN | SWT.READ_ONLY);
}   ",658,True
"//GEN-LAST:event_refreshoptActionPerformed
public void load_shortcut(){
        if (kSarConfig.shortcut_window_list == null) {
            return;
        }
        for (Iterator<String> it = kSarConfig.shortcut_window_list.keySet().iterator(); it.hasNext();) {
            String key = it.next();
            String value = kSarConfig.shortcut_window_list.get(key);
            add_shortcut((String) value);
        }
    }","//GEN-LAST:event_refreshoptActionPerformed
public void load_shortcut() 
{
    try
    {
        String sql=""select * from shortcut"";
        ResultSet rs=con.stmt.executeQuery(sql);
        while(rs.next())
        {
            String name=rs.getString(""name"");
            String path=rs.getString(""path"");
            shortcut.add(new shortcut(name,path));
        }
    }
    catch(Exception e)
    {
        System.out.println(e);
    }
}   ",666,False
"// access   commit   create     link   lookup    mkdir     read  readlnk   remove   rename    rmdir  symlink    write
public void add(final Second now, final Float val1, final Float val2, final Float val3, final Float val4, final Float val5,
        final Float val6, final Float val7, final Float val8, final Float val9, final Float val10,
        final Float val11, final Float val12, final Float val13){
    this.t_access.add(now, val1, do_notify());
    this.t_commit.add(now, val2, do_notify());
    this.t_create.add(now, val3, do_notify());
    this.t_link.add(now, val4, do_notify());
    this.t_lookup.add(now, val5, do_notify());
    this.t_mkdir.add(now, val6, do_notify());
    this.t_read.add(now, val7, do_notify());
    this.t_readlnk.add(now, val8, do_notify());
    this.t_remove.add(now, val9, do_notify());
    this.t_rename.add(now, val10, do_notify());
    this.t_rmdir.add(now, val11, do_notify());
    this.t_symlink.add(now, val12, do_notify());
    this.t_write.add(now, val13, do_notify());
    number_of_sample++;
}","// access   commit   create     link   lookup    mkdir     read  readlnk   remove   rename    rmdir  symlink    write
public void add(final Second now, final Float val1, final Float val2, final Float val3, final Float val4, final Float val5,
        final Float val6, final Float val7, final Float val8, final Float val9, final Float val10,
        final Float val11, final Float val12, final Float val13) 
{
    this.add(new Commit(now, val1, val2, val3, val4, val5, val6, val7, val8, val9, val10, val11, val12, val13));
}       ",668,False
"/* (non-Javadoc)
 * @see net.atomique.ksar.IMessageCreator#showTextInputWithSuggestionDialog(java.lang.String, java.lang.String, java.lang.Iterable, java.lang.String)
 */
@Override
public String showTextInputWithSuggestionDialog(String title, String message, Iterable<String> suggestions, String defaultValue){
    DefaultComboBoxModel model = new DefaultComboBoxModel();
    
    if (suggestions != null) {
        for (String suggestion : suggestions) {
            model.addElement(suggestion);
        }
    }
    
    if (defaultValue != null) {
        model.setSelectedItem(defaultValue);
    }
    
    JComboBox comboBox = new JComboBox(model);
    comboBox.setEditable(true);
    comboBox.setToolTipText(message);
    
    int result = JOptionPane.showConfirmDialog(this.parent, comboBox, title, JOptionPane.OK_CANCEL_OPTION);
    
    if (result == JOptionPane.OK_OPTION 
            && comboBox.getSelectedItem() != null) {
        return comboBox.getSelectedItem().toString();
    }
    
    return null;
}","/* (non-Javadoc)
 * @see net.atomique.ksar.IMessageCreator#showTextInputWithSuggestionDialog(java.lang.String, java.lang.String, java.lang.Iterable, java.lang.String)
 */
@Override
public String showTextInputWithSuggestionDialog(String title, String message, Iterable<String> suggestions, String defaultValue) 
{
    String[] suggestionArray = new String[suggestions.size()];
    int i = 0;
    for (String suggestion : suggestions) {
        suggestionArray[i++] = suggestion;
    }
    return showTextInputWithSuggestionDialog(title, message, suggestionArray, defaultValue);
}   ",669,True
"/** Creates new form kSarDesktop */
public kSarDesktop(){
    currentVersion = VersionNumber.getInstance();
    kSarConfig.hasUI=true;
    int wmargins = 90;
    int hmargins = 60;
    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
    initComponents();
    load_shortcut();
    setBounds(wmargins, hmargins, screenSize.width - wmargins * 2, screenSize.height - hmargins * 2);
    desktopPane.setDragMode(JDesktopPane.OUTLINE_DRAG_MODE);
    setVisible(true);
}","/** Creates new form kSarDesktop */
public kSarDesktop() 
{
    initComponents();
    this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    this.setTitle(""kSar Desktop"");
    this.setResizable(false);
    this.pack();
    this.setVisible(true);
}   ",673,True
"/** Creates new form ErrorPanel */
public ErrorPanel(java.awt.Frame parent, boolean modal){
    super(parent, modal);
    initComponents();
}","/** Creates new form ErrorPanel */
public ErrorPanel(java.awt.Frame parent, boolean modal) 
{
    super(parent, modal);
    initComponents();
}   ",678,True
"//GEN-LAST:event_jSpinner3StateChanged
private void save_value(){
        kSarConfig.alwaysrefresh = ((Integer)jSpinner2.getValue()).intValue();
        kSarConfig.somerefresh = ((Integer)jSpinner5.getValue()).intValue();
        kSarConfig.lessrefresh = ((Integer)jSpinner4.getValue()).intValue();
        kSarConfig.norefresh = ((Integer)jSpinner3.getValue()).intValue();
        kSarConfig.somerefresh_time = ((Integer)jSpinner1.getValue()).intValue();
        kSarConfig.lessrefresh_time = ((Integer)jSpinner6.getValue()).intValue();
        kSarConfig.writeDefault();
    }","//GEN-LAST:event_jSpinner3StateChanged
private void save_value() 
{
    if (jSpinner3.getValue() != null)
    {
        int value = (Integer) jSpinner3.getValue();
        if (value >= 0 && value <= 100)
        {
            this.value = value;
        }
    }
}   ",679,False
"/**
 * Display the settings dialog.
 * If the user clicks ok, all changes are reflected in the properties of this object.
 * Otherwise changes are discarded.
 * @param frame parent frame (needed for creating a modal dialog)
 * @return <code>OK</code> when user accepted changes, <code>CANCEL</code> otherwise
 */
public int showDialog(Frame frame){
	initDialog(frame);
	updateFields();
	result = CANCEL;
	dialog.setVisible(true);
	return (result);
}","/**
 * Display the settings dialog.
 * If the user clicks ok, all changes are reflected in the properties of this object.
 * Otherwise changes are discarded.
 * @param frame parent frame (needed for creating a modal dialog)
 * @return <code>OK</code> when user accepted changes, <code>CANCEL</code> otherwise
 */

public int showDialog(Frame frame) 
{
    final JDialog dialog = new JDialog(frame, ""Settings"", true);
    dialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
    final PropertiesPanel panel = new PropertiesPanel(this);
    dialog.getContentPane().add(panel);
    dialog.pack();
    dialog.setLocationRelativeTo(frame);
    dialog.setVisible(true);
    if (panel.isOk())
    {
        this.setProperties(panel.getProperties());
        return JOptionPane.OK_OPTION;
    }
    return JOptionPane.CANCEL_OPTION;
}   ",680,False
"/**
 * This is the SPI protocol decoder core
 *
 * The decoder scans for a decode start event like CS high to
 * low edge or the trigger of the captured data. After this the
 * decoder starts to decode the data by the selected mode, number
 * of bits and bit order. The decoded data are put to a JTable
 * object directly.
 */
private void decode(){
	// process the captured data and write to output
	int a,b,c;
	int bitCount, mosivalue, misovalue, maxbits;
	
	// clear old data
	decodedData.clear();
	
	/*
	 * Buid bitmasks based on the SCK, MISO, MOSI and CS
	 * pins.
	 */
	int csmask = (1 << cs.getSelectedIndex());
	int sckmask = (1 << sck.getSelectedIndex());
	int misomask = (1 << miso.getSelectedIndex());
	int mosimask = (1 << mosi.getSelectedIndex());
	
	System.out.println(""csmask   = 0x"" + Integer.toHexString(csmask));
	System.out.println(""sckmask  = 0x"" + Integer.toHexString(sckmask));
	System.out.println(""misomask = 0x"" + Integer.toHexString(misomask));
	System.out.println(""mosimask = 0x"" + Integer.toHexString(mosimask));
	
	
	/*
	 * For analyze scan the CS line for a falling edge. If
	 * no edge could be found, the position of the trigger
	 * is used for start of analysis. If no trigger and no
	 * edge is found the analysis fails.
	 */
	a = analysisData.values[0] & csmask;
	c = 0;
	b = 0;
	for (int i = 0; i < analysisData.values.length; i++) {
		if (a > (analysisData.values[i] & csmask)) {
			// cs to low found here
			b = i;
			c = 1;
			System.out.println(""CS found at "" + i);
			break;
		}
		a = analysisData.values[i] & csmask;
	}
	if (c == 0)
	{
		// no CS edge found, look for trigger
		if (analysisData.hasTriggerData())
			b = analysisData.triggerPosition;
	}
	// now the trigger is in b, add trigger event to table
	decodedData.addElement(new SPIProtocolAnalysisDataSet(b, ""CSLOW""));
	startOfDecode = b;
	
	/*
	 * Use the mode parameter to determine which eges are
	 * to detect. Mode 0 and mode 3 are sampling on the
	 * rising clk edge, mode 2 and 4 are sampling on the
	 * falling edge.
	 * a is used for start of value, c is register for 
	 * detect line changes.
	 */
	if ((mode.getSelectedItem().equals(""0"")) || (mode.getSelectedItem().equals(""2""))) {
		// scanning for rising clk edges
		c = analysisData.values[b] & sckmask;
		a = analysisData.values[b] & csmask;
		bitCount = Integer.parseInt((String)bits.getSelectedItem()) - 1;
		maxbits = bitCount;
		misovalue = 0;
		mosivalue = 0;
		for (int i = b; i < analysisData.values.length; i++) {
			if(c < (analysisData.values[i] & sckmask)) {
				// sample here
				if (order.getSelectedItem().equals(""MSB first"")) {
					if ((analysisData.values[i] & misomask) == misomask)
						misovalue |= (1 << bitCount);
					if ((analysisData.values[i] & mosimask) == mosimask)
						mosivalue |= (1 << bitCount);
				} else {
					if ((analysisData.values[i] & misomask) == misomask)
						misovalue |= (1 << (maxbits - bitCount));
					if ((analysisData.values[i] & mosimask) == mosimask)
						mosivalue |= (1 << (maxbits - bitCount));
				}
				
				if (bitCount > 0) {
					bitCount--;
				} else {
					decodedData.addElement(new SPIProtocolAnalysisDataSet(i,mosivalue,misovalue));

					System.out.println(""MISO = 0x"" + Integer.toHexString(misovalue));
					System.out.println(""MOSI = 0x"" + Integer.toHexString(mosivalue));
					bitCount = Integer.parseInt((String)bits.getSelectedItem()) - 1;
					misovalue = 0;
					mosivalue = 0;

					/*
					 * CS edge detection is only done when a complete value is decoded
					 */
					if(a > (analysisData.values[i] & csmask)) {
						// falling edge
						decodedData.addElement(new SPIProtocolAnalysisDataSet(i,""CSLOW""));
					} else if (a < (analysisData.values[i] & csmask)) {
						// rising edge
						decodedData.addElement(new SPIProtocolAnalysisDataSet(i,""CSHIGH""));
					}
					a = analysisData.values[i] & csmask;
				}
			}
			c = analysisData.values[i] & sckmask;
		}
	} else {
		// scanning for falling clk edges
		c = analysisData.values[b] & sckmask;
		a = analysisData.values[b] & csmask;
		bitCount = Integer.parseInt((String)bits.getSelectedItem()) - 1;
		maxbits = bitCount;
		misovalue = 0;
		mosivalue = 0;
		for (int i = b; i < analysisData.values.length; i++) {
			if(c > (analysisData.values[i] & sckmask)) {
				// sample here
				if (order.getSelectedItem().equals(""MSB first"")) {
					if ((analysisData.values[i] & misomask) == misomask)
						misovalue |= (1 << bitCount);
					if ((analysisData.values[i] & mosimask) == mosimask)
						mosivalue |= (1 << bitCount);
				} else {
					if ((analysisData.values[i] & misomask) == misomask)
						misovalue |= (1 << (maxbits - bitCount));
					if ((analysisData.values[i] & mosimask) == mosimask)
						mosivalue |= (1 << (maxbits - bitCount));
				}

				if (bitCount > 0) {
					bitCount--;
				} else {
					decodedData.addElement(new SPIProtocolAnalysisDataSet(i,mosivalue,misovalue));

					System.out.println(""MISO = 0x"" + Integer.toHexString(misovalue));
					System.out.println(""MOSI = 0x"" + Integer.toHexString(mosivalue));
					bitCount = Integer.parseInt((String)bits.getSelectedItem()) - 1;
					misovalue = 0;
					mosivalue = 0;

					/*
					 * CS edge detection is only done when a complete value is decoded
					 */
					if(a > (analysisData.values[i] & csmask)) {
						// falling edge
						decodedData.addElement(new SPIProtocolAnalysisDataSet(i,""CSLOW""));
					} else if (a < (analysisData.values[i] & csmask)) {
						// rising edge
						decodedData.addElement(new SPIProtocolAnalysisDataSet(i,""CSHIGH""));
					}
					a = analysisData.values[i] & csmask;
				}
			}
			c = analysisData.values[i] & sckmask;
		}
	}
	outTable.setModel(toTableData());
}","/**
 * This is the SPI protocol decoder core
 *
 * The decoder scans for a decode start event like CS high to
 * low edge or the trigger of the captured data. After this the
 * decoder starts to decode the data by the selected mode, number
 * of bits and bit order. The decoded data are put to a JTable
 * object directly.
 */
private void decode() 
{
    if (spiMode == SPI_MODE_0)
    {
        decodeMode0();
    }
    else if (spiMode == SPI_MODE_1)
    {
        decodeMode1();
    }
    else if (spiMode == SPI_MODE_2)
    {
        decodeMode2();
    }
    else if (spiMode == SPI_MODE_3)
    {
        decodeMode3();
    }
}   ",681,False
"/**
 * Constructs diagram labels component.
 */
public DiagramLabels(){
	super();
	setLayout(new GridBagLayout());
	setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

	JPanel modePane = new JPanel();
	modePane.setLayout(new GridBagLayout());
	modePane.setBorder(BorderFactory.createCompoundBorder(
			BorderFactory.createTitledBorder(""Diagram Labels""),
			BorderFactory.createEmptyBorder(5, 5, 5, 5)
	));
	
	labelFields = new JTextField[32];
	diagramLabels = new String[32];
	for (int col = 0; col < 2; col++) {
		for (int row = 0; row < 16; row++) {
			int num = 16 * col + row;
			modePane.add(new JLabel(""Channel "" + num + "": ""), createConstraints(2 * col, row, 1, 1, 0, 0));
			labelFields[num] = new JTextField(20);
			modePane.add(labelFields[num], createConstraints(2 * col + 1, row, 1, 1, 0, 0));
			diagramLabels[num] = new String();
		}
	}
	add(modePane, createConstraints(0, 0, 5, 1, 0, 0));
	
	JButton ok = new JButton(""Ok"");
	ok.addActionListener(this);
	add(ok, createConstraints(0, 1, 1, 1, 0.34, 0));
	JButton cancel = new JButton(""Cancel"");
	cancel.addActionListener(this);
	add(cancel, createConstraints(1, 1, 1, 1, 0.33, 0));
	JButton clear = new JButton(""Clear"");
	clear.addActionListener(this);
	add(clear, createConstraints(2, 1, 1, 1, 0.33, 0));
}","/**
 * Constructs diagram labels component.
 */
public DiagramLabels() 
{
    super();
    this.setLayout(new BorderLayout());
    this.add(this.label, BorderLayout.CENTER);
}   ",682,True
"/**
 * Handles all user interaction.
 */
public void actionPerformed(ActionEvent event){
	String label = event.getActionCommand();
	// if no action command, check if button and if so, use icon description as action
	if (label.equals("""")) {
		if (event.getSource() instanceof JButton)
			label = ((ImageIcon)((JButton)event.getSource()).getIcon()).getDescription();
	}
	System.out.println(label);
	try {
		
		if (label.equals(""Open..."")) {
			if (fileChooser.showOpenDialog(frame) == JFileChooser.APPROVE_OPTION) {
				File file = fileChooser.getSelectedFile();
				if (file.isFile())
					loadData(file);
			}
		
		} else if (label.equals(""Save as..."")) {
			if (fileChooser.showSaveDialog(frame) == JFileChooser.APPROVE_OPTION) {
				File file = fileChooser.getSelectedFile();
				System.out.println(""Saving: "" + file.getName() + ""."");
				diagram.getCapturedData().writeToFile(file);
			}

		} else if (label.equals(""Open Project..."")) {
			if (projectChooser.showOpenDialog(frame) == JFileChooser.APPROVE_OPTION) {
				File file = projectChooser.getSelectedFile();
				if (file.isFile())
					loadProject(file);
			}
			
		} else if (label.equals(""Save Project as..."")) {
			if (projectChooser.showSaveDialog(frame) == JFileChooser.APPROVE_OPTION) {
				File file = projectChooser.getSelectedFile();
				System.out.println(""Saving Project: "" + file.getName() + ""."");
				project.store(file);
			}
		
		} else if (label.equals(""Capture..."")) {
			if (controller.showCaptureDialog(frame) == DeviceController.DONE) {
				diagram.setCapturedData(controller.getDeviceData());
			}

		} else if (label.equals(""Repeat Capture"")) {
			if (controller.showCaptureProgress(frame) == DeviceController.DONE) {
				diagram.setCapturedData(controller.getDeviceData());
			}

		} else if (label.equals(""Exit"")) {
			exit();
		
		} else if (label.equals(""Zoom In"")) {
			diagram.zoomIn();
		
		} else if (label.equals(""Zoom Out"")) {
			diagram.zoomOut();

		} else if (label.equals(""Default Zoom"")) {
			diagram.zoomDefault();

		} else if (label.equals(""Diagram Settings..."")) {
			diagram.showSettingsDialog(frame);
			
		} else if (label.equals(""Labels..."")) {
			diagram.showLabelsDialog(frame);

		} else if (label.equals(""About"")) {
			JOptionPane.showMessageDialog(null,
					""Sump's Logic Analyzer Client\n""
					+ ""\n""
					+ ""Copyright 2006 Michael Poppitz\n""
					+ ""This software is released under the GNU GPL.\n""
					+ ""\n""
					+ ""For more information see:\n""
					+ ""http://www.sump.org/projects/analyzer/"",
				""About"", JOptionPane.INFORMATION_MESSAGE
			);
		} else {
			// check if a tool has been selected and if so, process captured data by tool
			for (int i = 0; i < tools.length; i++)
				if (label.equals(tools[i].getName())) {
					CapturedData newData = tools[i].process(diagram.getCapturedData());
					if (newData != null)
						diagram.setCapturedData(newData);
				}
		}
		enableDataDependingFunctions(diagram.hasCapturedData());
			
	} catch(Exception E) {
		E.printStackTrace(System.out);
	}
}","/**
 * Handles all user interaction.
 */
public void actionPerformed(ActionEvent event) 
{
    String command = event.getActionCommand();

    if (command.equals(""Play""))
    {
        // Play the game
        playGame();
    }
    else if (command.equals(""Quit""))
    {
        // Quit the game
        quitGame();
    }
    else if (command.equals(""Save""))
    {
        // Save the game
        saveGame();
    }
    else if (command.equals(""Load""))
    {
        // Load the game
        loadGame();
    }
}   ",684,False
"/**
 * Load the given file as project.
 * @param file file to be loaded as projects
 * @throws IOException when an IO error occurs
 */
public void loadProject(File file) throws IOException{
	System.out.println(""Opening Project: "" + file.getName());
	project.load(file);
}","/**
 * Load the given file as project.
 * @param file file to be loaded as projects
 * @throws IOException when an IO error occurs
 */

public void loadProject(File file) throws IOException 
{
    if (file.exists())
    {
        FileInputStream fis = new FileInputStream(file);
        ObjectInputStream ois = new ObjectInputStream(fis);
        try
        {
            Project project = (Project) ois.readObject();
            this.project = project;
        }
        catch (ClassNotFoundException e)
        {
            e.printStackTrace();
        }
        finally
        {
            ois.close();
        }
    }
}   ",687,True
"/**
 * converts the analyzed data to table data
 * @return the prepared table data
 */
private DefaultTableModel toTableData(){
	String data[][] = new String[decodedData.size()][4];
	SPIProtocolAnalysisDataSet ds;
	for (int i = 0; i < decodedData.size(); i++) {
		ds = (SPIProtocolAnalysisDataSet)decodedData.get(i);
		if (ds.isEvent()) {
			// index
			data[i][0] = new String("""" + (i+1));
			// time
			data[i][1] = new String(indexToTime(ds.time));
			// MOSI
			data[i][2] = new String(ds.event);
			// MISO
			data[i][3] = new String(ds.event);
		} else {
			// index
			data[i][0] = new String("""" + (i+1));
			// time
			data[i][1] = new String(indexToTime(ds.time));
			// MOSI
			data[i][2] = new String(""0x"" + Integer.toHexString(ds.mosi) + "","" + ds.mosi);
			// MISO
			data[i][3] = new String(""0x"" + Integer.toHexString(ds.miso) + "","" + ds.miso);
		}
	}
	DefaultTableModel mod = new DefaultTableModel(data, colNames);
	return(mod);
}","/**
 * converts the analyzed data to table data
 * @return the prepared table data
 */
private DefaultTableModel toTableData() 
{
    DefaultTableModel tableData = new DefaultTableModel();
    tableData.addColumn(""Name"");
    tableData.addColumn(""Value"");
    for (Map.Entry<String, String> entry : this.analyzedData.entrySet())
    {
        tableData.addRow(new Object[]{entry.getKey(), entry.getValue()});
    }
    return tableData;
}   ",688,False
"/**
 * Enables or disables functions that can only operate when captured data has been added to the diagram.
 * @param enable set <code>true</code> to enable these functions, <code>false</code> to disable them
 */
private void enableDataDependingFunctions(boolean enable){
	diagramMenu.setEnabled(enable);
	toolMenu.setEnabled(enable);
}","/**
 * Enables or disables functions that can only operate when captured data has been added to the diagram.
 * @param enable set <code>true</code> to enable these functions, <code>false</code> to disable them
 */
private void enableDataDependingFunctions(boolean enable) 
{
    if (enable)
    {
        if (isDiagramEmpty())
        {
            disableAllDataDependingFunctions();
        }
        else
        {
            enableDataDependingFunctions();
        }
    }
    else
    {
        disableAllDataDependingFunctions();
    }
}   ",690,True
"/**
 * Creates a JMenu containing items as specified.
 * If an item name is empty, a separator will be added in its place.
 * 
 * @param name Menu name
 * @param entries array of menu item names.
 * @return created menu
 */
private JMenu createMenu(String name, String[] entries){
	JMenu menu = new JMenu(name);
	for (int i = 0; i < entries.length; i++) {
		if (!entries[i].equals("""")) {
			JMenuItem item = new JMenuItem(entries[i]);
			item.addActionListener(this);
			menu.add(item);
		} else {
			menu.add(new JSeparator());
		}
	}
	return (menu);
}","/**
 * Creates a JMenu containing items as specified.
 * If an item name is empty, a separator will be added in its place.
 * 
 * @param name Menu name
 * @param entries array of menu item names.
 * @return created menu
 */
private JMenu createMenu(String name, String[] entries) 
{
    JMenu menu = new JMenu(name);
    for (String entry : entries)
    {
        if (entry.length() == 0)
        {
            menu.addSeparator();
        }
        else
        {
            menu.add(new JMenuItem(entry));
        }
    }
    return menu;
}   ",692,True
"/**
 * Internal method that initializes a dialog and add this component to it.
 * @param frame owner of the dialog
 */
private void initDialog(Frame frame){
	// check if dialog exists with different owner and dispose if so
	if (dialog != null && dialog.getOwner() != frame) {
		dialog.dispose();
		dialog = null;
	}
	// if no valid dialog exists, create one
	if (dialog == null) {
		dialog = new JDialog(frame, ""Diagram Labels"", true);
		dialog.getContentPane().add(this);
		dialog.pack();
		dialog.setResizable(false);
	}
}","/**
 * Internal method that initializes a dialog and add this component to it.
 * @param frame owner of the dialog
 */


private void initDialog(Frame frame) 
{
    dialog = new JDialog(frame, ""Select Color"", true);
    dialog.getContentPane().add(this, BorderLayout.CENTER);
    SamplePanel samplePanel = new SamplePanel();
    dialog.getContentPane().add(samplePanel, BorderLayout.EAST);
    dialog.pack();
}   ",693,True
"/**
 * Constructs CapturedData based on the given data.
 * 
 * @param values 32bit values as read from device
 * @param triggerPosition position of trigger as index of values array
 * @param rate sampling rate (may be set to <code>NOT_AVAILABLE</code>)
 * @param channels number of used channels
 * @param enabledChannels bit mask identifying used channels
 */
public CapturedData(int[] values, int triggerPosition, int rate, int channels, int enabledChannels){
	this.values = values;
	this.triggerPosition = triggerPosition;
	this.rate = rate;
	this.channels = channels;
	this.enabledChannels = enabledChannels;
}","/**
 * Constructs CapturedData based on the given data.
 * 
 * @param values 32bit values as read from device
 * @param triggerPosition position of trigger as index of values array
 * @param rate sampling rate (may be set to <code>NOT_AVAILABLE</code>)
 * @param channels number of used channels
 * @param enabledChannels bit mask identifying used channels
 */
public CapturedData(int[] values, int triggerPosition, int rate, int channels, int enabledChannels) 
{
    this.values = values;
    this.triggerPosition = triggerPosition;
    this.rate = rate;
    this.channels = channels;
    this.enabledChannels = enabledChannels;
}   ",698,True
"/**
 * アカウント入力ダイアログ表示
 * @return
 */
private Dialog showAccountNameDialog(){
    LayoutInflater factory = LayoutInflater.from(mContext);
    final View entryView = factory.inflate(R.layout.dialog_entry, null);
    final EditText edit = (EditText) entryView.findViewById(R.id.username_edit);
    final CheckBox check = (CheckBox) entryView.findViewById(R.id.reaccount_use);

    // アカウント名がプリファレンスにあればエディタに設定
    edit.setText(getPreferences(""name"", """"));
    check.setChecked(Boolean.valueOf(getPreferences(""reload"", ""true"")));

    // キーハンドリング
    edit.setOnKeyListener(new View.OnKeyListener(){
        public boolean onKey(View v, int keyCode, KeyEvent event) {
             // Enterキーハンドリング
            if (KeyEvent.KEYCODE_ENTER == keyCode) {
                // 押したときに改行を挿入防止処理
                if (KeyEvent.ACTION_DOWN == event.getAction()) {
                    return true;
                }
                 // 離したときにダイアログ上の[読込]処理を実行
                else if (KeyEvent.ACTION_UP == event.getAction()) {
                    if (edit != null && edit.length() != 0) {
                        // 非同期で画像取得
                        String accountName = edit.getText().toString();
                        String reloadCheck = String.valueOf(check.isChecked());
                        loadThreadStart(accountName, reloadCheck);
                        mDialog.dismiss();
                    }
                    return true;
                }
            }
            return false;
        }
    });

    // 初期ダイアログ作成
    return new AlertDialog.Builder(mActivity)
        .setIcon(R.drawable.icon)
        .setTitle(R.string.load_alert_name_dialog_title)
        .setView(entryView)
        .setCancelable(false)
        .setPositiveButton(R.string.load_alert_name_dialog_button1, new DialogInterface.OnClickListener() {
            public void onClick(DialogInterface dialog, int whichButton) {
                // 非同期で画像取得
                String accountName = edit.getText().toString();
                String reloadCheck = String.valueOf(check.isChecked());
                loadThreadStart(accountName, reloadCheck);
            }
        }).setNegativeButton(R.string.load_alert_name_dialog_button2, new DialogInterface.OnClickListener() {
            public void onClick(DialogInterface dialog, int whichButton) {
                finish();
            }
        }).create();
}","/**
 * アカウント入力ダイアログ表示
 * @return
 */

private Dialog showAccountNameDialog() 
{
    final EditText editText = new EditText(this);
    return new AlertDialog.Builder(this)
            .setTitle(""アカウント名を入力してください"")
            .setView(editText)
            .setPositiveButton(""OK"", new DialogInterface.OnClickListener() {
                @Override
                public void onClick(DialogInterface dialog, int which) {
                    String accountName = XXXXXXXX.getText().toString();
                    if (accountName.length() > 0) {
                        addAccount(accountName);
                    }
                }
            })
            .setNegativeButton(""キャンセル"", null)
            .create();
}   ",700,False
"/**
 * スレッド関係のクラス変数をクリア
 */
private void clearThreadData(){
    mWallpaperBitmap = null;
    if (mBitmapThreads != null) {
        for (int i = 0; i < mBitmapThreads.length; i++) {
            if (mBitmapThreads[i] != null && mBitmapThreads[i].isAlive() == true) {
                mBitmapThreads[i].interrupt();
                mBitmapThreads[i] = null;
            }
        }
        mBitmapThreads = null;
    }
    mBitmapScaleThread = null;
    if (mAsyncTask != null && mAsyncTask.getStatus() == AsyncTask.Status.RUNNING) {
        mAsyncTask.cancel(true);
    }
    mAsyncTask = null;
    mListData = null;
}","/**
 * スレッド関係のクラス変数をクリア
 */
private void clearThreadData() 
{
    mThreadData.clear();
    mThreadData = null;
}   ",702,False
"/**
 * プリファレンス情報取得
 * @param key
 * @param value : プリファレンスから取得失敗した時に設定される値
 * @return
 */
private String getPreferences(String key, String value){
    SharedPreferences settings = getSharedPreferences(""TumblrWallpaper"", MODE_PRIVATE);
    return settings.getString(key, value);
}","/**
 * プリファレンス情報取得
 * @param key
 * @param value : プリファレンスから取得失敗した時に設定される値
 * @return
 */

private String getPreferences(String key, String value) 
{
    String result = value;
    SharedPreferences pref = PreferenceManager.getDefaultSharedPreferences(this);
    if (pref.contains(key))
    {
        result = pref.getString(key, value);
    }
    return result;
}   ",704,True
"/**
 * プリファレンス情報設定
 * @param key
 * @param value
 */
private void setPreferences(String key, String value){
    SharedPreferences settings = getSharedPreferences(""TumblrWallpaper"", MODE_PRIVATE);
    SharedPreferences.Editor editor = settings.edit();
    editor.putString(key, value);
    editor.commit();
}","/**
 * プリファレンス情報設定
 * @param key
 * @param value
 */



private void setPreferences(String key, String value) 
{
    SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(this);
    SharedPreferences.Editor editor = sp.edit();
    editor.putString(key, value);
    editor.commit();
}   ",707,True
"/**
 * スケール値を取得します
 * @param bmpSize : 画像のサイズ(現在は高さを基準にしている)
 * @param changeSize : 画面のサイズ(今はｒｙ)
 * @return
 */
private static BigDecimal scaleData(int bmpSize, int changeSize){
    BigDecimal afterSize = new BigDecimal(bmpSize + changeSize);
    BigDecimal scale = afterSize.divide(new BigDecimal(Integer.toString(bmpSize)), 4,
            BigDecimal.ROUND_CEILING);

    return scale;
}","/**
 * スケール値を取得します
 * @param bmpSize : 画像のサイズ(現在は高さを基準にしている)
 * @param changeSize : 画面のサイズ(今はｒｙ)
 * @return
 */
private static BigDecimal scaleData(int bmpSize, int changeSize) 
{
	BigDecimal scale = new BigDecimal(changeSize).divide(new BigDecimal(bmpSize), 2, RoundingMode.HALF_UP);
	return scale;
}   ",711,True
"/**
 * プログレスバーダイアログ表示
 * @param title
 * @param mes
 */
private void showPrrogressBarDialog(){
    mProgressDialog = new ProgressDialog(mActivity);
    mProgressDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER);
    mProgressDialog.setTitle(R.string.load_progress_bar_dialog_title);
    mProgressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
    mProgressDialog.setMax(MAX_PROGRESS);
    // 初期ダイアログ表示
    mProgressDialog.setButton(getText(R.string.load_progress_bar_dialog_button1), new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int whichButton) {
            clearThreadData();
            mProgressDialog.dismiss();
            mDialog = showAccountNameDialog();
            mDialog.show();
        }
    });
    // アプリ終了
    mProgressDialog.setButton2(getText(R.string.load_progress_bar_dialog_button2), new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int whichButton) {
            finish();
        }
    });
    mProgressDialog.show();

    // バックボタンが押されたとき
    mProgressDialog.setOnCancelListener(new OnCancelListener(){
        @Override
        public void onCancel(DialogInterface dialog) {
            finish();
        }
   });
}","/**
 * プログレスバーダイアログ表示
 * @param title
 * @param mes
 */

private void showPrrogressBarDialog() 
{
    if (mProgressBarDialog == null)
    {
        mProgressBarDialog = new ProgressDialog(this);
        mProgressBarDialog.setTitle(""Please wait"");
        mProgressBarDialog.setMessage(""Loading..."");
        mProgressBarDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER);
        mProgressBarDialog.setCancelable(false);
        mProgressBarDialog.show();
    }
    else
    {
        mProgressBarDialog.show();
    }
}   ",712,False
"/**
 * スケールサイズを取得します
 * @param bmp : スケール対象bitmap
 * @param width : 画面の幅
 * @param height : 画面の高さ
 * @return
 */
private static Point saleSize(Bitmap bmp, int width, int height){
    Point point = new Point(0, 0);

    // 画像の幅と高さ
    int bmpWidth = bmp.getWidth();
    int bmpHeight = bmp.getHeight();

    int changeX = width - bmpWidth;
    int changeY = height - bmpHeight;
    BigDecimal scale = new BigDecimal(""0"");
    // 差がマイナスであることを最優先に確認します
    scale = scaleData(bmpHeight, changeY);
    // scale = scaleData(bmpWidth, changeX);

    point.x = scale.multiply(new BigDecimal(Integer.toString(bmpWidth))).intValue();
    point.y = scale.multiply(new BigDecimal(Integer.toString(bmpHeight))).intValue();

    return point;
}","/**
 * スケールサイズを取得します
 * @param bmp : スケール対象bitmap
 * @param width : 画面の幅
 * @param height : 画面の高さ
 * @return
 */
private static Point saleSize(Bitmap bmp, int width, int height) 
{
    Point point = new Point();
    float scaleW = (float)width / bmp.getWidth();
    float scaleH = (float)height / bmp.getHeight();
    float scale = Math.min(scaleW, scaleH);
    point.x = (int)(bmp.getWidth() * scale);
    point.y = (int)(bmp.getHeight() * scale);
    return point;
}   ",713,True
"/**
 * meny押下時のイベント
 */
@Override
public final boolean onOptionsItemSelected(MenuItem items){
    switch (items.getItemId()) {
    case R.id.menu_reload_setting:
        mDialog = showReloadSettingDialog();
        mDialog.show();
        return true;
    }
    return false;
}","/**
 * meny押下時のイベント
 */

@Override
public final boolean onOptionsItemSelected(MenuItem items) 
{
    switch (items.getItemId())
    {
        case R.id.menu_setting:
            Intent intent = new Intent(this, SettingActivity.class);
            startActivity(intent);
            break;
    }
    return super.onOptionsItemSelected(items);
}   ",715,True
"/**
 * 画面に表示される毎に呼び出される
 * @param position : 表示する対象Listの一覧を上から数えたときの番号
 * @param convertView : 表示する対象ListのView
 * @param parent : 知らん
 */
final public View getView(int position, View convertView, ViewGroup parent){
    View row = convertView;

    if (mListData[position] != null) {
        // 画像イメージを作成
        if (row == null || row.getTag() == null) {
            LayoutInflater inflater = LayoutInflater.from(mContext);
            row = inflater.inflate(R.layout.row, null);

            mListData[position].img = (ImageView) row.findViewById(R.id.image);
            row.setTag(mListData[position].img);
        } else {
            // 画像イメージを読み込み
            mListData[position].img = (ImageView) row.getTag();
        }

        if (mListData[position] != null && mListData[position].img != null) {
            mListData[position].img.setImageBitmap(mListData[position].bitmap);
            mListData[position].img.setTag(mListData[position].url);
        } else {
            mListData[position].img.setImageBitmap(null);
            mListData[position].img.setTag("""");
        }
    } else {
        LayoutInflater inflater = LayoutInflater.from(mContext);
        row = inflater.inflate(R.layout.row, null);
    }
    return row;
}","/**
 * 画面に表示される毎に呼び出される
 * @param position : 表示する対象Listの一覧を上から数えたときの番号
 * @param convertView : 表示する対象ListのView
 * @param parent : 知らん
 */
final public View getView(int position, View convertView, ViewGroup parent) 
{
    if (convertView == null)
    {
        convertView = mInflater.inflate(R.layout.list_item, null);
    }

    // ���目に��を��定
    TextView text = (TextView)convertView.findViewById(R.id.text);
    text.setText(mItems.get(position));

    return convertView;
}   ",717,False
"/**
 * スケールビットマップを取得します
 * @param bmp : スケール対象bitmap
 * @param width : 画面の幅
 * @param height : 画面の高さ
 * @return
 */
public static final Bitmap getScaleBitmap(Bitmap bmp, int width, int height){
    if (bmp != null) {
        Point point = saleSize(bmp, width, height);
        bmp = Bitmap.createScaledBitmap(bmp, point.x, point.y, true);
        /* 2.0対応するための対処法
        Bitmap backBmp = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
        // bmp = backBmp.createBitmap(bmp, 0, 0, point.x, point.y);
        Canvas canvas = new Canvas(backBmp);
        canvas.drawBitmap(bmp, 0, 0, null);
        BitmapDrawable drawable = new BitmapDrawable(backBmp);
        drawable.draw(canvas);
        bmp = drawable.getBitmap();
        // drawable.draw(canvas);
         */
        }
    return bmp;
}","/**
 * スケールビットマップを取得します
 * @param bmp : スケール対象bitmap
 * @param width : 画面の幅
 * @param height : 画面の高さ
 * @return
 */
public static final Bitmap getScaleBitmap(Bitmap bmp, int width, int height) 
{
    Matrix matrix = new Matrix();
    matrix.postScale((float)width / bmp.getWidth(), (float)height / bmp.getHeight());
    return Bitmap.createBitmap(bmp, 0, 0, bmp.getWidth(), bmp.getHeight(), matrix, true);
}   ",719,False
"// Subtracts one turn remaining. Call this function to make the fleet get
// one turn closer to its destination.
public void TimeStep(){
	if (turnsRemaining > 0) {
	    --turnsRemaining;
	} else {
	    turnsRemaining = 0;
	}
}","// Subtracts one turn remaining. Call this function to make the fleet get
// one turn closer to its destination.
public void TimeStep() 
{
    if (turnsRemaining > 0)
    {
        turnsRemaining--;
    }
    else
    {
        turnsRemaining = 0;
    }
}   ",721,True
"// Initializes a fleet.
public Fleet(int owner,
		 int numShips,
		 int sourcePlanet,
		 int destinationPlanet,
		 int totalTripLength,
		 int turnsRemaining){
	this.owner = owner;
	this.numShips = numShips;
	this.sourcePlanet = sourcePlanet;
	this.destinationPlanet = destinationPlanet;
	this.totalTripLength = totalTripLength;
	this.turnsRemaining = turnsRemaining;
}","// Initializes a fleet.
public Fleet(int owner,
		 int numShips,
		 int sourcePlanet,
		 int destinationPlanet,
		 int totalTripLength,
		 int turnsRemaining) 
{
	this.owner = owner;
	this.numShips = numShips;
	this.sourcePlanet = sourcePlanet;
	this.destinationPlanet = destinationPlanet;
	this.totalTripLength = totalTripLength;
	this.turnsRemaining = turnsRemaining;
}	",722,True
"// Return a list of all the planets that are not owned by the current
// player. This includes all enemy planets and neutral planets.
public List<Planet> NotMyPlanets(){
	List<Planet> r = new ArrayList<Planet>();
	for (Planet p : planets) {
	    if (p.Owner() != 1) {
		r.add(p);
	    }
	}
	return r;
}","// Return a list of all the planets that are not owned by the current
// player. This includes all enemy planets and neutral planets.

public List<Planet> NotMyPlanets() 
{
    List<Planet> r = new ArrayList<Planet>();
    for (Planet p : Planets) {
        if (p.Owner() != PlayerID) {
            r.add(p);
        }
    }
    return r;
}   ",724,True
"// Returns true if the named player owns at least one planet or fleet.
// Otherwise, the player is deemed to be dead and false is returned.
public boolean IsAlive(int playerID){
	for (Planet p : planets) {
	    if (p.Owner() == playerID) {
		return true;
	    }
	}
	for (Fleet f : fleets) {
	    if (f.Owner() == playerID) {
		return true;
	    }
	}
	return false;
}","// Returns true if the named player owns at least one planet or fleet.
// Otherwise, the player is deemed to be dead and false is returned.
public boolean IsAlive(int playerID) 
{
	for (Planet p : planets)
	{
		if (p.Owner == playerID)
			return true;
	}
	for (Fleet f : fleets)
	{
		if (f.Owner == playerID)
			return true;
	}
	return false;
}   ",725,True
"// Return a list of all the planets owned by the current player. By
// convention, the current player is always player number 1.
public List<Planet> MyPlanets(){
	List<Planet> r = new ArrayList<Planet>();
	for (Planet p : planets) {
	    if (p.Owner() == 1) {
		r.add(p);
	    }
	}
	return r;
}","// Return a list of all the planets owned by the current player. By
// convention, the current player is always player number 1.

public List<Planet> MyPlanets() 
{
    List<Planet> r = new ArrayList<Planet>();
    for (Planet p : Planets) {
        if (p.ownedBy() == 1) {
            r.add(p);
        }
    }
    return r;
}   ",726,True
"// Parses a game state from a string. On success, returns 1. On failure,
// returns 0.
private int ParseGameState(String s){
	planets.clear();
	fleets.clear();
	int planetID = 0;
	String[] lines = s.split(""\n"");
	for (int i = 0; i < lines.length; ++i) {
	    String line = lines[i];
	    int commentBegin = line.indexOf('#');
	    if (commentBegin >= 0) {
		line = line.substring(0, commentBegin);
	    }
	    if (line.trim().length() == 0) {
		continue;
	    }
	    String[] tokens = line.split("" "");
	    if (tokens.length == 0) {
		continue;
	    }
	    if (tokens[0].equals(""P"")) {
		if (tokens.length != 6) {
		    return 0;
		}
		double x = Double.parseDouble(tokens[1]);
		double y = Double.parseDouble(tokens[2]);
		int owner = Integer.parseInt(tokens[3]);
		int numShips = Integer.parseInt(tokens[4]);
		int growthRate = Integer.parseInt(tokens[5]);
		Planet p = new Planet(planetID++,
				      owner,
				      numShips,
				      growthRate,
				      x, y);
		planets.add(p);
	    } else if (tokens[0].equals(""F"")) {
		if (tokens.length != 7) {
		    return 0;
		}
		int owner = Integer.parseInt(tokens[1]);
		int numShips = Integer.parseInt(tokens[2]);
		int source = Integer.parseInt(tokens[3]);
		int destination = Integer.parseInt(tokens[4]);
		int totalTripLength = Integer.parseInt(tokens[5]);
		int turnsRemaining = Integer.parseInt(tokens[6]);
		Fleet f = new Fleet(owner,
				    numShips,
				    source,
				    destination,
				    totalTripLength,
				    turnsRemaining);
		fleets.add(f);
	    } else {
		return 0;
	    }
	}
	return 1;
}","// Parses a game state from a string. On success, returns 1. On failure,
// returns 0.
private int ParseGameState(String s) 
{
    int result = 1;

    // Parse the board
    result &= ParseBoard(s);

    if (result == 1)
    {
        // Parse the player
        result &= ParsePlayer(s);
    }

    return result;
}   ",728,False
"// Sends an order to the game engine. An order is composed of a source
// planet number, a destination planet number, and a number of ships. A
// few things to keep in mind:
//   * you can issue many orders per turn if you like.
//   * the planets are numbered starting at zero, not one.
//   * you must own the source planet. If you break this rule, the game
//     engine kicks your bot out of the game instantly.
//   * you can't move more ships than are currently on the source planet.
//   * the ships will take a few turns to reach their destination. Travel
//     is not instant. See the Distance() function for more info.
public void IssueOrder(int sourcePlanet,
                       int destinationPlanet,
                       int numShips){
    System.out.println("""" + sourcePlanet + "" "" + destinationPlanet + "" "" +
      numShips);
	System.out.flush();
}","// Sends an order to the game engine. An order is composed of a source
// planet number, a destination planet number, and a number of ships. A
// few things to keep in mind:
//   * you can issue many orders per turn if you like.
//   * the planets are numbered starting at zero, not one.
//   * you must own the source planet. If you break this rule, the game
//     engine kicks your bot out of the game instantly.
//   * you can't move more ships than are currently on the source planet.
//   * the ships will take a few turns to reach their destination. Travel
//     is not instant. See the Distance() function for more info.
public void IssueOrder(int sourcePlanet,
                       int destinationPlanet,
                       int numShips) 
{
    System.out.println("""" + sourcePlanet +
                       "" "" + destinationPlanet +
                       "" "" + numShips);
}   ",729,True
"// Constructs a PlanetWars object instance, given a string containing a
// description of a game state.
public PlanetWars(String gameStateString){
	planets = new ArrayList<Planet>();
	fleets = new ArrayList<Fleet>();
	ParseGameState(gameStateString);
}","// Constructs a PlanetWars object instance, given a string containing a
// description of a game state.
public PlanetWars(String gameStateString) 
{
    String[] lines = gameStateString.split(""\n"");

    int i = 0;

    // Parse the planets
    int numPlanets = Integer.parseInt(lines[i++]);
    for (int j = 0; j < numPlanets; j++)
    {
        int planetId = Integer.parseInt(lines[i++]);
        int owner = Integer.parseInt(lines[i++]);
        int numShips = Integer.parseInt(lines[i++]);
        int growthRate = Integer.parseInt(lines[i++]);
        double x = Double.parseDouble(lines[i++]);
        double y = Double.parseDouble(lines[i++]);
        Planet p = new Planet(planetId, owner, numShips, growthRate, x, y);
        planets.add(p);
    }

    // Parse the fleets
    int numFleets = Integer.parseInt(lines[i++]);
    for (int j = 0; j < numFleets; j++)
    {
        int owner = Integer.parseInt(lines[i++]);
        int numShips = Integer.parseInt(lines[i++]);
        int sourcePlanet = Integer.parseInt(lines[i++]);
        int destinationPlanet = Integer.parseInt(lines[i++]);
        int totalTripLength = Integer.parseInt(lines[i++]);
        int turnsRemaining = Integer.parseInt(lines[i++]);
        Fleet f = new Fleet(owner, numShips, sourcePlanet, destinationPlanet,
                totalTripLength, turnsRemaining);
        fleets.add(f);
    }
}   ",735,True
"// Return a list of all the fleets owned by the current player.
public List<Fleet> MyFleets(){
	List<Fleet> r = new ArrayList<Fleet>();
	for (Fleet f : fleets) {
	    if (f.Owner() == 1) {
		r.add(f);
	    }
	}
	return r;
}","// Return a list of all the fleets owned by the current player.

public List<Fleet> MyFleets() 
{
    List<Fleet> result = new ArrayList<Fleet>();
    for (Fleet fleet : fleets)
    {
        if (fleet.getOwner() == owner)
        {
            result.add(fleet);
        }
    }
    return result;
}   ",736,True
"// Return a list of all the planets owned by rival players. This excludes
// planets owned by the current player, as well as neutral planets.
public List<Planet> EnemyPlanets(){
	List<Planet> r = new ArrayList<Planet>();
	for (Planet p : planets) {
	    if (p.Owner() >= 2) {
		r.add(p);
	    }
	}
	return r;
}","// Return a list of all the planets owned by rival players. This excludes
// planets owned by the current player, as well as neutral planets.

public List<Planet> EnemyPlanets() 
{
    List<Planet> r = new ArrayList<Planet>();

    for (Planet p : Planets())
    {
        if (p.Owner() != 0 && p.Owner() != PlayerID())
            r.add(p);
    }

    return r;
}   ",737,True
"//start the JXTA platform
private void startJxta(){
     try {
         netPeerGroup = PeerGroupFactory.newNetPeerGroup();
     } catch ( PeerGroupException e) {
         // could not instantiate the group, print the stack and exit
         System.out.println(""fatal error : group creation failure"");
         e.printStackTrace();
         //System.exit(1);
     }

     // Get the discovery service from our peer group
     discovery = netPeerGroup.getDiscoveryService();
 }","//start the JXTA platform
private void startJxta() 
{
    try
    {
        // Create and configure the JXTA platform manager
        PlatformConfig config = new PlatformConfig(new File("".jxta""));
        jxta = new JxtaPlatform(config);
        PlatformManager manager = new PlatformManager(config);

        // Start the JXTA platform
        manager.startPlatform();
    }
    catch (Exception e)
    {
        e.printStackTrace();
    }
}   ",741,False
"/**
 * Create a PipeID based on the BinaryID type with a digest of the clearTextID and function.
 *
 * @param peerGroupID Parent peer group ID.
 * @param clearTextID String used as the significant part of the address
 * @param function String used to diferentiate different clearTextID addresses (can be null).
 * @return PipeBinaryID with the digest hash of the string: clearTextID+""~""+function.
 */
public static final net.jxta.pipe.PipeID createPipeID(net.jxta.peergroup.PeerGroupID peerGroupID,String clearTextID, String function){
    LOG.info(""Creatig pipe ID = peerGroupID:""+peerGroupID+"", clearText:'""+clearTextID+""' , function:'""+function+""'"");
    byte[] digest = generateHash(clearTextID, function);
    return (net.jxta.pipe.PipeID)net.jxta.id.IDFactory.newPipeID(peerGroupID, digest );
}","/**
 * Create a PipeID based on the BinaryID type with a digest of the clearTextID and function.
 *
 * @param peerGroupID Parent peer group ID.
 * @param clearTextID String used as the significant part of the address
 * @param function String used to diferentiate different clearTextID addresses (can be null).
 * @return PipeBinaryID with the digest hash of the string: clearTextID+""~""+function.
 */
public static final net.jxta.pipe.PipeID createPipeID(net.jxta.peergroup.PeerGroupID peerGroupID,String clearTextID, String function) 
{
    String digest = clearTextID;
    if (function != null)
    {
        digest += ""~"" + function;
    }
    return new net.jxta.pipe.PipeID(peerGroupID, digest);
}   ",742,True
"/**
 * By implementing PipeMsgListener, define this method to deal with
 * messages as they arrive
 */
public void pipeMsgEvent(PipeMsgEvent event){

    Message msg=null;
    try {
        // grab the message from the event
        msg = event.getMessage();
        if (msg == null) {
            return;
        }
        printMessageStats(msg, true);
    } catch (Exception e) {
        e.printStackTrace();
        return;
    }

    // get all the message elements
    Message.ElementIterator en = msg.getMessageElements();
    if (!en.hasNext()) {
        return;
    }

    // get the message element named SenderMessage
    MessageElement msgElement = msg.getMessageElement(null, SenderMessage);
    // Get message
    if (msgElement.toString() == null) {
        System.out.println(""null msg received"");
    } else {
        Date date = new Date(System.currentTimeMillis());
        System.out.println(""Message received at :""+ date.toString());
        System.out.println(""Message  created at :""+ msgElement.toString());
    }
}","/**
 * By implementing PipeMsgListener, define this method to deal with
 * messages as they arrive
 */
public void pipeMsgEvent(PipeMsgEvent event) 
{
    // Get the message
    PipeMsg msg = event.getMessage();

    // Check if the message is a string
    if (msg instanceof PipeStringMsg)
    {
        // Get the string value
        String value = ((PipeStringMsg)msg).getValue();

        // Print the string value
        System.out.println(""Received message: "" + value);
    }
}   ",743,True
"// returns true if a port was found false if a port has been created
private boolean findPortNumber(String peerIPs){
	if (peerIPs == null) {
		myTCPPort = DEFAULT_TCP_PORT;
		return false;
	}	
	// analyse peerIPs - create a list of found peers
	
	StringTokenizer tokenizer = new StringTokenizer(peerIPs,TOKEN, true);
	List foundPeersWithSameIP = new ArrayList();
	boolean uriFollows = true;
	URI currentURI = null;
	String currentPath = null;
	while (tokenizer.hasMoreTokens()) {
		String element = tokenizer.nextToken();
		if (AD.equals(element)) {
			uriFollows = true;
			storeCurrentPeer(currentURI, currentPath, foundPeersWithSameIP);
			// store current peer
			// reset current peer
			currentURI = null;
			currentPath = null;
		}
		else if (HASH.equals(element)) {
			uriFollows = false;
		}
		else if (uriFollows) {
			// element should be an URI
			try {
				currentURI = new URI(element);
			}
			catch (URISyntaxException e) {
				getLogger().warning(""[PeerIdentifierSetter] URI syntax in database wrong: "" + element);
				// ignore this entry by setting to null
				currentURI = null;
			}
				
		}
		else {
			currentPath = element;
		}
	}
	// do not forget to store the last peer
	storeCurrentPeer(currentURI, currentPath, foundPeersWithSameIP);
	
	// analyse all peers with the same ip address
		
	// case 1: no peers with same ip address found
	if (foundPeersWithSameIP.size() == 0) {
		myTCPPort = DEFAULT_TCP_PORT;
		// return not found
		return false;
	}
	// case 2: only one found - ignore identifier 
	// in that way someone can put an entry into the database without an identifier
	// or the application can be moved around on the same machine
	if (foundPeersWithSameIP.size() == 1) {
		// special case: someone put the entry in the database manually without an identifier, accept this case
		PeerIdentifier peerIdentifier = (PeerIdentifier) foundPeersWithSameIP.get(0);
		String tempIdentifer = peerIdentifier.getIdentifier();
		if (StringHandler.isEmpty(tempIdentifer)) {
			int tempPort = peerIdentifier.getUri().getPort();
			myTCPPort = new Integer(tempPort);
			// return found
			return true;
		}
	}
	// case 3: one or more peers with identifiers found
	List usedPorts = new ArrayList();
	Iterator iterator = foundPeersWithSameIP.iterator();
	while (iterator.hasNext()) {
		PeerIdentifier peerIdentifier = (PeerIdentifier) iterator.next();
		String identifier = peerIdentifier.getIdentifier();
		int tempPort = peerIdentifier.getUri().getPort();
		if (myIdentifier.equals(identifier)) {
			myTCPPort = new Integer(tempPort);
		}
		else {
			// add the one with the different identifier to the others peers
			seedPeers.add(peerIdentifier);
			usedPorts.add(new Integer(tempPort));
		}
	}
	if (myTCPPort != null) {
		// return found
		return true;
	}
	// find a port number

	// start at 9700 that is the default
	myTCPPort = DEFAULT_TCP_PORT;
	while (usedPorts.contains(myTCPPort)) {
		myTCPPort = new Integer(myTCPPort.intValue() + 2);
	}
	// not found
	return false;
}","// returns true if a port was found false if a port has been created
private boolean findPortNumber(String peerIPs) 
{
    int port = 0;
    boolean found = false;
    for (int i = 0; i < peerIPs.length(); i++)
    {
        if (peerIPs.charAt(i) == ':')
        {
            found = true;
            port = Integer.parseInt(peerIPs.substring(i + 1));
            break;
        }
    }
    return found;
}   ",744,False
"// returns true if successful
private boolean setPeerIdentifierIntoDatabase(IWApplicationContext iwac) throws IOException{
	// get ip address
	try {
		// there is sometimes a problem here, see:
		// http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4073539
		//myIP = ""157.157.121.37"";//myIPAddress.getHostAddress();
		myIP = InetAddress.getLocalHost().getHostAddress();
	}
	catch (UnknownHostException e) {
		getLogger().warning(""[PeerIdentifierSetter] Own IP address could not be retrieved"");
		throw new IOException(""[PeerIdentifierSetter] Own IP address could not be retrieved"");
	}
	// get identifier
	String path = iwac.getIWMainApplication().getApplicationRealPath();
	myIdentifier = Integer.toString(path.hashCode());
	// get other peers
	IWMainApplicationSettings iwMainApplicationSettings =iwac.getApplicationSettings();
	// step 1 reading
	String peerIPs = iwMainApplicationSettings.getProperty(APPLICATION_PEERS);
	if (findPortNumber(peerIPs)) {
		// nothing to do, entry found
		return true;
	}
	// add entry 
	StringBuffer buffer = new StringBuffer();
	if (peerIPs != null) {
		buffer.append(peerIPs);
		buffer.append(AD);
	}
	// assemble identifier  uri:myIdentifer
	int myPort = myTCPPort.intValue();
	URI myURI = null;
	try {
		myURI = new URI(""tcp"",null,myIP,myPort,null,null,null);
	}
	catch (URISyntaxException e1) {
		getLogger().warning(""[PeerIdentifierSetter] Own IP address could not be created"");
		throw new IOException(""[PeerIdentifierSetter] Own IP address could not be created"");
	}
	buffer.append(myURI.toString());
	buffer.append(HASH);
	buffer.append(myIdentifier);
	// extend peerIDs
	String extendedPeerIDs = buffer.toString(); 
	
	// step 2 writing
	iwMainApplicationSettings.setProperty(APPLICATION_PEERS, extendedPeerIDs);
	// go sleeping for a while
	try {
		Thread.sleep(4000);
	}
	catch (InterruptedException e) {
		getLogger().warning(""[PeerURISetter] Sleeping thread was interrupted"");
	}
	// check now if some other application has written to the database during the time between step 1 and step 2
	// do not use the cache read database
	ICApplicationBindingBusiness applicationBindingBusiness = getApplicationBindingBusiness(iwac);
	try {
		String secondPeerIds = applicationBindingBusiness.get(APPLICATION_PEERS);
		// not successful if the strings are different
		return secondPeerIds.equals(extendedPeerIDs);
	}
	catch (RemoteException re) {
		getLogger().warning(""[PeerURISetter] ICApplicationBindingBusiness could not be found"");
		throw new IBORuntimeException(re.getMessage());
	}
}","// returns true if successful
private boolean setPeerIdentifierIntoDatabase(IWApplicationContext iwac) throws IOException 
{
    String peerIdentifier = getPeerIdentifier(iwac);
    if (peerIdentifier != null)
    {
        return setPeerIdentifierIntoDatabase(peerIdentifier);
    }
    return false;
}   ",745,False
"/* (non-Javadoc)
 * @see com.idega.core.event.MethodCallEventHandler#handleEvent(com.idega.core.event.MethodCallEvent)
 */
public void handleEvent(MethodCallEvent methodCallEvent){
	// put a wrapper around the event
	// and change the sender to the application messenger ID !
	String messageSender = applicationMessenger.getSender();
	SimpleMessage simpleMessage = new SimpleMessageEvent(messageSender, methodCallEvent);
	applicationMessenger.sendMessage(simpleMessage);
}","/* (non-Javadoc)
 * @see com.idega.core.event.MethodCallEventHandler#handleEvent(com.idega.core.event.MethodCallEvent)
 */
public void handleEvent(MethodCallEvent methodCallEvent) 
{
	if (methodCallEvent.getMethodName().equals(""getDocument""))
	{
		if (methodCallEvent.getArguments().length == 0)
		{
			methodCallEvent.setReturnValue(getDocument());
		}
	}
}   ",747,False
"/**
 *  Starts jxta, and get the pipe, and discovery service
 */
private void startJxta(PeerGroup peerGroup){
    try {
    	if (peerGroup == null) {
	            // create, and Start the default jxta NetPeerGroup
	            netPeerGroup = PeerGroupFactory.newNetPeerGroup();
    	}
    	else {
    		netPeerGroup = peerGroup;
    	}
        rendezvous = netPeerGroup.getRendezVousService();
        rendezvous.addListener(this);
        // uncomment the following line if you want to start the app defined
        // the NetPeerGroup Advertisement (by default it's the shell)
        // in this case we want use jxta directly.
        // netPeerGroup.startApp(null);

    } catch (PeerGroupException e) {
        // could not instantiate the group, print the stack and exit
        System.out.println(""fatal error : group creation failure"");
        e.printStackTrace();
        System.exit(-1);
    }

    // get the pipe service, and discovery
    pipe = netPeerGroup.getPipeService();
    discovery = netPeerGroup.getDiscoveryService();
    System.out.println(""Reading in pipexample.adv"");
    try {
    	String path = System.getProperty(""JXTA_HOME"");
    	File jxtaHome = new File(path);
    	File pipexampleAdv = new File(jxtaHome.getParentFile(), ""pipexample.adv"");
    	FileInputStream is = new FileInputStream(pipexampleAdv);
        pipeAdv = (PipeAdvertisement) AdvertisementFactory.newAdvertisement(MimeMediaType.XMLUTF8, is);
        is.close();
    } catch (Exception e) {
        System.out.println(""failed to read/parse pipe advertisement"");
        e.printStackTrace();
        System.exit(-1);
    }
}","/**
 *  Starts jxta, and get the pipe, and discovery service
 */
private void startJxta(PeerGroup peerGroup) 
{
    try
    {
        // Creating the NetPeerGroup
        System.out.println(""Creating the NetPeerGroup"");
        netPeerGroup = PeerGroupFactory.newNetPeerGroup(peerGroup);

        // Getting the pipe service
        System.out.println(""Getting the pipe service"");
        pipeService = netPeerGroup.getPipeService();

        // Getting the discovery service
        System.out.println(""Getting the discovery service"");
        discoveryService = netPeerGroup.getDiscoveryService();
    }
    catch (Exception ex)
    {
        System.out.println(""Failed to start JXTA: "" + ex.getMessage());
        ex.printStackTrace();
    }
}   ",748,False
"/**
 * Generates an SHA-1 digest hash of the string: clearTextID+""-""+function or: clearTextID if function was blank.<p>
 *
 * Note that the SHA-1 used only creates a 20 byte hash.<p>
 *
 * @param clearTextID A string that is to be hashed. This can be any string used for hashing or hiding data.
 * @param function A function related to the clearTextID string. This is used to create a hash associated with clearTextID so that it is a uique code.
 *
 * @return array of bytes containing the hash of the string: clearTextID+""-""+function or clearTextID if function was blank. Can return null if SHA-1 does not exist on platform.
 */
public static final byte[] generateHash(String clearTextID, String function){
    String id;
    
    if (function == null) {
        id = clearTextID;
    } else {
        id = clearTextID + functionSeperator + function;
    }
    byte[] buffer = id.getBytes();
    
    MessageDigest algorithm = null;
    
    try {
        algorithm = MessageDigest.getInstance(""MD5"");
    } catch (Exception e) {
        LOG.error(""Cannot load selected Digest Hash implementation"",e);
        return null;
    }
    
    
    // Generate the digest.
    algorithm.reset();
    algorithm.update(buffer);
    
    try{
        byte[] digest1 = algorithm.digest();
        return digest1;
    }catch(Exception de){
        LOG.error(""Failed to creat a digest."",de);
        return null;
    }
}","/**
 * Generates an SHA-1 digest hash of the string: clearTextID+""-""+function or: clearTextID if function was blank.<p>
 *
 * Note that the SHA-1 used only creates a 20 byte hash.<p>
 *
 * @param clearTextID A string that is to be hashed. This can be any string used for hashing or hiding data.
 * @param function A function related to the clearTextID string. This is used to create a hash associated with clearTextID so that it is a uique code.
 *
 * @return array of bytes containing the hash of the string: clearTextID+""-""+function or clearTextID if function was blank. Can return null if SHA-1 does not exist on platform.
 */

public static final byte[] generateHash(String clearTextID, String function) 
{
    try
    {
        MessageDigest md = MessageDigest.getInstance(""SHA-1"");
        md.update((clearTextID+""-""+function).getBytes());
        return md.digest();
    }
    catch (NoSuchAlgorithmException e)
    {
        return null;
    }
}   ",751,True
"/**
 * wait for msgs
 *
 */
public void run(){

    try {
        // the following creates the inputpipe, and registers ""this""
        // as the PipeMsgListener, when a message arrives pipeMsgEvent is called
        System.out.println(""Creating input pipe"");
        pipeIn = pipe.createInputPipe(pipeAdv, this);
    } catch (Exception e) {
        return;
    }
    if (pipeIn == null) {
        System.out.println("" cannot open InputPipe"");
        System.exit(-1);
    }
    System.out.println(""Waiting for msgs on input pipe"");
}","/**
 * wait for msgs
 *
 */
public void run() 
{
    while (true)
    {
        try
        {
            String msg = (String) in.readObject();
            System.out.println(msg);
        }
        catch (IOException | ClassNotFoundException e)
        {
            e.printStackTrace();
        }
    }
}   ",752,False
"/**
 *  by implementing OutputPipeListener we must define this method which
 *  is called when the output pipe is created
 *
 *@param  event  event object from which to get output pipe object
 */
public void outputPipeEvent(OutputPipeEvent event){

    System.out.println("" Got an output pipe event"");
    OutputPipe op = event.getOutputPipe();
    Message msg = null;

    try {
        System.out.println(""Sending message"");
        msg = new Message();
        Date date = new Date(System.currentTimeMillis());
        StringMessageElement sme = new StringMessageElement(SenderMessage, date.toString() , null);
        msg.addMessageElement(null, sme);
        op.send(msg);
    } catch (IOException e) {
        System.out.println(""failed to send message"");
        e.printStackTrace();
        System.exit(-1);
    }
    op.close();
    System.out.println(""message sent"");
}","/**
 *  by implementing OutputPipeListener we must define this method which
 *  is called when the output pipe is created
 *
 *@param  event  event object from which to get output pipe object
 */
public void outputPipeEvent(OutputPipeEvent event) 
{
    OutputPipe outputPipe = event.getOutputPipe();
    System.out.println(""Output pipe created: "" + outputPipe.getName());
}   ",754,True
"/**
 * This thread loops forever discovering peers
 * every minute, and displaying the results.
 */
public void run(){
    try {
        // Add ourselves as a DiscoveryListener for DiscoveryResponse events
        discovery.addDiscoveryListener(this);
        while (true) {
            System.out.println(""Sending a Discovery Message"");
            // look for any peer
            discovery.getRemoteAdvertisements(null, DiscoveryService.PEER,
                                              null, null, 5);
            // wait a bit before sending next discovery message
            try {
                Thread.sleep(60 * 1000);
            } catch(Exception e) {}

        } //end while
    } catch(Exception e) {
        e.printStackTrace();
    }
}","/**
 * This thread loops forever discovering peers
 * every minute, and displaying the results.
 */
public void run() 
{
    while (true)
    {
        try
        {
            Thread.sleep(60000);
        }
        catch (InterruptedException e)
        {
            // ignore
        }

        try
        {
            discoverPeers();
        }
        catch (IOException e)
        {
            System.err.println(""Error discovering peers: "" + e.getMessage());
        }
    }
}   ",756,False
"/**
 *  the thread which creates (resolves) the output pipe
 *  and sends a message once it's resolved
 */
public synchronized void run(){
    try {
        // this step helps when running standalone (local sub-net without any redezvous setup)
        discovery.getRemoteAdvertisements(null, DiscoveryService.ADV, null, null, 1, null);
        // create output pipe with asynchronously
        // Send out the first pipe resolve call
        System.out.println(""Attempting to create a OutputPipe"");
        pipe.createOutputPipe(pipeAdv, this);
        // send out a second pipe resolution after we connect
        // to a rendezvous
        if (!rendezvous.isConnectedToRendezVous()) {
            System.out.println(""Waiting for Rendezvous Connection"");
            try {
                wait();
                System.out.println(""Connected to Rendezvous, attempting to create a OutputPipe"");
                pipe.createOutputPipe(pipeAdv, this);
            } catch (InterruptedException e) {
                // got our notification
            }
        }
    } catch (IOException e) {
        System.out.println(""OutputPipe creation failure"");
        e.printStackTrace();
        System.exit(-1);
    }
}","/**
 *  the thread which creates (resolves) the output pipe
 *  and sends a message once it's resolved
 */
public synchronized void run() 
{
    try
    {
        // wait for the output pipe to be resolved
        while (outputPipe == null)
            wait();

        // send a message through the output pipe
        outputPipe.send(""Hello from the other side!"");
    }
    catch (InterruptedException e)
    {
        e.printStackTrace();
    }
}   ",758,False
"/**
 * @return GeoLine from NorthEast to SouthEast
 */
public GeoLine getEastGeoLine(){
	if(this.mEastGeoLine == null) {
		this.mEastGeoLine = new GeoLine(this.mLatNorthE6, this.mLonEastE6, this.mLatSouthE6, this.mLonEastE6);
	}
	return this.mEastGeoLine;
}","/**
 * @return GeoLine from NorthEast to SouthEast
 */
public GeoLine getEastGeoLine() 
{
    return new GeoLine(getNorthEast(), getSouthEast());
}   ",760,True
"/**
 * @param coords to be used to construct the uri to the tile. <b>Example:</b> <code>[11187, 17171]</code> will result i.e. in <code>http://c.tile.openstreetmap.org/15/<b>17171/11187</b>.png</code>
 * @param zoomLevel used together with <code>coords</code> to determine the final url. <b>Example:</b> <code>15</code> will result i.e. in <code>http://c.tile.openstreetmap.org/<b>15</b>/17171/11187.png</code>
 * @param h the Handler to send a message to success or failure.
 * @return <code>false</code>, when MapTile is already pending for download or already existing on the FS. <code>false</code> otherwise.
 */
public boolean preloadMaptileAsync(final OSMTileInfo aTileInfo, final Handler h){
	final String aRawTileURLString = this.mProviderInfo.getTileURLString(aTileInfo);
	final String aSaveableURLString = this.mProviderInfo.getSaveableTileURLString(aTileInfo, this.mFSTileCache.getStoragePolicy());

	if(this.mFSTileCache.exists(aRawTileURLString, aSaveableURLString)) {
		return false;
	}

	return this.mTileProvider.requestMapTileAsync(aTileInfo, aRawTileURLString, aSaveableURLString, h);
}","/**
 * @param coords to be used to construct the uri to the tile. <b>Example:</b> <code>[11187, 17171]</code> will result i.e. in <code>http://c.tile.openstreetmap.org/15/<b>17171/11187</b>.png</code>
 * @param zoomLevel used together with <code>coords</code> to determine the final url. <b>Example:</b> <code>15</code> will result i.e. in <code>http://c.tile.openstreetmap.org/<b>15</b>/17171/11187.png</code>
 * @param h the Handler to send a message to success or failure.
 * @return <code>false</code>, when MapTile is already pending for download or already existing on the FS. <code>false</code> otherwise.
 */
public boolean preloadMaptileAsync(final OSMTileInfo aTileInfo, final Handler h) 
{
    if (aTileInfo == null)
    {
        return false;
    }

    if (this.isMaptilePending(aTileInfo))
    {
        return false;
    }

    if (this.isMaptileExisting(aTileInfo))
    {
        return false;
    }

    this.mPendingMaptiles.add(aTileInfo);

    this.mExecutor.execute(new Runnable()
    {
        @Override
        public void run()
        {
            if (preloadMaptile(aTileInfo))
            {
                h.sendEmptyMessage(0);
            }
            else
            {
                h.sendEmptyMessage(1);
            }
        }
    });

    return true;
}   ",761,True
"/**
 * Get a MapTile, based on <code>coords</code> and <code>zoomLevel</code>. Used the handler passed with the constructor, to inform of successful or failed loadings.
 * @param coords to be used to construct the uri to the tile. <b>Example:</b> <code>[11187, 17171]</code> will result i.e. in <code>http://c.tile.openstreetmap.org/15/<b>17171/11187</b>.png</code>
 * @param zoomLevel used together with <code>coords</code> to determine the final url. <b>Example:</b> <code>15</code> will result i.e. in <code>http://c.tile.openstreetmap.org/<b>15</b>/17171/11187.png</code>
 * @return Either: <ul><li><code>MAPTILE_DOWNLOADING</code> when the tile is currently being downloaded. </li><li><code>MAPTILE_LOADING</code> if the tile is currently being loaded from the FileSystem to the MemoryCache.</li><li> The actual bitmap if already was downloaded and loaded to the MemoryCache.</li></ul>
 */
public Bitmap getMapTile(final OSMTileInfo aTileInfo){
	final String aSaveableTileURLString = this.mProviderInfo.getSaveableTileURLString(aTileInfo, this.mFSTileCache.getStoragePolicy());

	final Bitmap ret = this.mMemoryTileCache.getMapTile(aSaveableTileURLString);
	if(ret != null){
		if(DEBUGMODE) {
			Log.i(DEBUGTAG, ""MapTileCache succeded for: "" + aSaveableTileURLString);
		}

		if(ret.isRecycled()){
			this.mMemoryTileCache.onRemoveRecycledBitmapFromMemoryCache(aSaveableTileURLString);
		}else{
			return ret;
		}
	}

	final String formattedTileURLStringDirty = aSaveableTileURLString + OSMMapTileMemoryCache.FLAG_DIRTY;
	final Bitmap retDirty = this.mMemoryTileCache.getMapTile(formattedTileURLStringDirty);

	final String aRawTileURLString = this.mProviderInfo.getTileURLString(aTileInfo);

	if(DEBUGMODE) {
		Log.i(DEBUGTAG, ""Cache failed, trying from FS."");
	}

	/* Check if file is either being loaded from FS or is pending for download. */
	if(this.mFSTileCache.isPending(aSaveableTileURLString)){
		if(retDirty == null) {
			return this.MAPTILE_LOADING;
		}
	}else if(this.mTileProvider.isPending(aRawTileURLString)){
		if(retDirty == null){
			switch (this.mProviderInfo.PROVIDER_TYPE) {
				case LOCAL_PROVIDER:
					return this.MAPTILE_GENERATING;
				case DOWNLOAD_PROVIDER:
				default:
					return this.MAPTILE_DOWNLOADING;
			}
		}
	}

	final boolean existsInFSAndNowLoading = this.mFSTileCache.loadMapTileToMemCacheAsync(aTileInfo, aSaveableTileURLString, this.mLoadCallbackHandler);
	if(existsInFSAndNowLoading){
		if(retDirty == null) {
			return this.MAPTILE_LOADING;
		}
	}else{
		if(DEBUGMODE) {
			Log.d(DEBUGTAG, ""File: '"" + aSaveableTileURLString + ""' not found in Filesystem"");
		}

		/* If possible, try to create a bitmap from the parent and put it to the memcache. */
		if(aTileInfo.zoom > 0 && retDirty == null && !this.mFSTileCache.isPending(formattedTileURLStringDirty)) {
			this.mFSTileCache.tryLoadMapTileByParentToMemCacheAsync(aTileInfo, aSaveableTileURLString, this.mLoadCallbackHandler);
		}
	}
	/* FS did not contain the MapTile, we need to download it asynchronous. */
	if(DEBUGMODE) {
		Log.i(DEBUGTAG, ""Requesting Maptile for download."");
	}

	this.mTileProvider.requestMapTileAsync(aTileInfo, aRawTileURLString, aSaveableTileURLString, this.mLoadCallbackHandler);
	if(retDirty == null){
		switch (this.mProviderInfo.PROVIDER_TYPE) {
			case LOCAL_PROVIDER:
				return this.MAPTILE_GENERATING;
			case DOWNLOAD_PROVIDER:
			default:
				return this.MAPTILE_DOWNLOADING;
		}
	}

	return retDirty;
}","/**
 * Get a MapTile, based on <code>coords</code> and <code>zoomLevel</code>. Used the handler passed with the constructor, to inform of successful or failed loadings.
 * @param coords to be used to construct the uri to the tile. <b>Example:</b> <code>[11187, 17171]</code> will result i.e. in <code>http://c.tile.openstreetmap.org/15/<b>17171/11187</b>.png</code>
 * @param zoomLevel used together with <code>coords</code> to determine the final url. <b>Example:</b> <code>15</code> will result i.e. in <code>http://c.tile.openstreetmap.org/<b>15</b>/17171/11187.png</code>
 * @return Either: <ul><li><code>MAPTILE_DOWNLOADING</code> when the tile is currently being downloaded. </li><li><code>MAPTILE_LOADING</code> if the tile is currently being loaded from the FileSystem to the MemoryCache.</li><li> The actual bitmap if already was downloaded and loaded to the MemoryCache.</li></ul>
 */
public Bitmap getMapTile(final OSMTileInfo aTileInfo) 
{
    Bitmap bitmap = null;
    if (aTileInfo != null)
    {
        bitmap = this.mMapTileCache.get(aTileInfo);
        if (bitmap == null)
        {
            bitmap = this.mHandler.getMapTile(MAPTILE_DOWNLOADING, aTileInfo);
            if (bitmap == null)
            {
                bitmap = this.mHandler.getMapTile(MAPTILE_LOADING, aTileInfo);
                if (bitmap == null)
                {
                    bitmap = this.mHandler.getMapTile(aTileInfo);
                }
            }
        }
    }
    return bitmap;
}   ",763,True
"// ===========================================================
// Methods
// ===========================================================
protected void applyTopMenuButtonListeners(){
	/* Set Listener for Back-Button. */
	new OnClickOnFocusChangedListenerAdapter(this.findViewById(R.id.ibtn_sd_savedtracechooser_back)) {
		@Override
		public void onClicked(final View me) {
			if (SDSavedTraceChooser.super.mMenuVoiceEnabled) {
				MediaPlayer.create(SDSavedTraceChooser.this, R.raw.close).start();
			}

			/* Back one level. */
			SDSavedTraceChooser.this.setResult(SUBACTIVITY_RESULTCODE_UP_ONE_LEVEL);
			SDSavedTraceChooser.this.finish();
		}
	};

	/* Set Listener for Close-Button. */
	new OnClickOnFocusChangedListenerAdapter(this.findViewById(R.id.ibtn_sd_savedtracechooser_close)) {
		@Override
		public void onClicked(final View me) {
			if (SDSavedTraceChooser.super.mMenuVoiceEnabled) {
				MediaPlayer.create(SDSavedTraceChooser.this, R.raw.close).start();
			}
			/*
			 * Set ResultCode that the calling activity knows that we want
			 * to go back to the Base-Menu
			 */
			SDSavedTraceChooser.this.setResult(SUBACTIVITY_RESULTCODE_CHAINCLOSE_QUITTED);
			SDSavedTraceChooser.this.finish();
		}
	};
}","// ===========================================================
// Methods
// ===========================================================



protected void applyTopMenuButtonListeners() 
{
    mTopMenuButton.setOnClickListener(new OnClickListener()
    {
        @Override
        public void onClick(View v)
        {
            if (mTopMenuButtonListener != null)
            {
                mTopMenuButtonListener.onTopMenuButtonClick();
            }
        }
    });
}   ",765,False
"/**
 * @return GeoLine from SouthEast to SouthWest
 */
public GeoLine getSouthGeoLine(){
	if(this.mSouthGeoLine == null) {
		this.mSouthGeoLine = new GeoLine(this.mLatSouthE6, this.mLonEastE6, this.mLatSouthE6, this.mLonWestE6);
	}
	return this.mSouthGeoLine;
}","/**
 * @return GeoLine from SouthEast to SouthWest
 */
public GeoLine getSouthGeoLine() 
{
    return new GeoLine(this.getSouthEast(), this.getSouthWest());
}   ",767,True
"/**
 * @return GeoLine from NorthWest to NorthEast
 */
public GeoLine getNorthLine(){
	if(this.mNorthGeoLine == null) {
		this.mNorthGeoLine = new GeoLine(this.mLatNorthE6, this.mLonWestE6, this.mLatNorthE6, this.mLonEastE6);
	}
	return this.mNorthGeoLine;
}","/**
 * @return GeoLine from NorthWest to NorthEast
 */
public GeoLine getNorthLine() 
{
    return new GeoLine(getNorthWest(), getNorthEast());
}   ",768,True
"/**
 * Changes the ProviderInfo of the underlying Provider and the caches.
 */
public void setProviderInfo(final OSMMapTileProviderInfo pProviderInfo){
	if(pProviderInfo == this.mProviderInfo) {
		return;
	}

	if(this.mProviderInfo.PROVIDER_TYPE == pProviderInfo.PROVIDER_TYPE){
		this.mTileProvider.setProviderInfo(pProviderInfo);
	}else{ /* PROVIDER_TYPE of the Provider has changed! */
		switch (pProviderInfo.PROVIDER_TYPE) {
			case LOCAL_PROVIDER:
				this.mTileProvider = new OSMMapTileRenderProvider(this.mCtx, pProviderInfo, this.mFSTileCache);
				break;
			case DOWNLOAD_PROVIDER:
			default:
				this.mTileProvider = new OSMMapTileDownloadProvider(this.mCtx, pProviderInfo, this.mFSTileCache);
				break;
		}
	}
	this.mFSTileCache.setProviderInfo(pProviderInfo);
	this.mProviderInfo = pProviderInfo;
}","/**
 * Changes the ProviderInfo of the underlying Provider and the caches.
 */
public void setProviderInfo(final OSMMapTileProviderInfo pProviderInfo) 
{
    mProviderInfo = pProviderInfo;
    if (mTileProvider != null)
    {
        mTileProvider.setProviderInfo(pProviderInfo);
    }
    if (mTileCache != null)
    {
        mTileCache.setProviderInfo(pProviderInfo);
    }
}   ",773,True
"// ===========================================================
// FastScrollView-Methods
// ===========================================================
public int getPositionForSection(final int section){

	final String firstChar = this.mAlphabet[section];

	/* Find the index, of the firstchar within the Contact-Items */
	int position = Collections.binarySearch(this.mItems, new SavedTraceItem(firstChar));

	if(position < 0){
		/* Negative result means the insertion-point.
		 * See definition of Collections.binarySearch */
		position = -(position + 1);
	}

	return position;
}","// ===========================================================
// FastScrollView-Methods
// ===========================================================
public int getPositionForSection(final int section) 
{
    int pos = 0;
    for (int i = 0; i < section; i++)
    {
        pos += this.mSectionIndexer.getPositionForSection(i);
    }
    return pos;
}   ",774,False
"/**
 * 
 * @param aLatitude
 * @param aLongitude
 * @param reuse
 * @return relative position determined from the upper left corner.<br />
 * {0,0} would be the upper left corner.
 * {1,1} would be the lower right corner.
 * {1,0} would be the lower left corner.
 * {0,1} would be the upper right corner.
 */
public float[] getRelativePositionOfGeoPointInBoundingBoxWithLinearInterpolation(final int aLatitude, final int aLongitude, final float[] reuse){
	final float[] out = (reuse != null) ? reuse : new float[2];
	out[Y] = ((float)(this.mLatNorthE6 - aLatitude) / getLatitudeSpanE6());
	out[X] = 1 - ((float)(this.mLonEastE6 - aLongitude) / getLongitudeSpanE6());
	return out;
}","/**
 * 
 * @param aLatitude
 * @param aLongitude
 * @param reuse
 * @return relative position determined from the upper left corner.<br />
 * {0,0} would be the upper left corner.
 * {1,1} would be the lower right corner.
 * {1,0} would be the lower left corner.
 * {0,1} would be the upper right corner.
 */
public float[] getRelativePositionOfGeoPointInBoundingBoxWithLinearInterpolation(final int aLatitude, final int aLongitude, final float[] reuse) 
{
    final float[] result = (reuse == null) ? new float[2] : reuse;
    result[0] = (float)(aLatitude - this.mUpperLeftLatitude) / (float)(this.mLowerRightLatitude - this.mUpperLeftLatitude);
    result[1] = (float)(aLongitude - this.mUpperLeftLongitude) / (float)(this.mLowerRightLongitude - this.mUpperLeftLongitude);
    return result;
}   ",777,True
"// For testing
public static void main(String[] args){
  OpenCV detector = new OpenCV();
  Region[] faces = detector.detectFaces(args[0]);
  if (faces != null) {
    for (int i=0; i<faces.length; i++) {
      Region region = faces[i];
      System.out.println(""Found region: "" + region.toString());      
    }     
  }
}","// For testing
public static void main(String[] args) 
{
    // Create a new instance of the class
    Test test = new Test();

    // Create a new instance of the class
    Test test2 = new Test();

    // Print the result of comparing the two objects
    System.out.println(test.equals(test2));
}   ",781,False
"/**
 * Symmetric tridiagonal QL algorithm as used in JAMA Package.
 */
private void performQLalgorithm (){
	
	//  This is derived from the Algol procedures tql2, by
	//  Bowdler, Martin, Reinsch, and Wilkinson, Handbook for
	//  Auto. Comp., Vol.ii-Linear Algebra, and the corresponding
	//  Fortran subroutine in EISPACK.
	
	for (int i = 1; i < dimension; i++) {
		e[i-1] = e[i];
	}
	e[dimension-1] = 0.0;
	
	double f = 0.0;
	double tst1 = 0.0;
	double eps = Math.pow(2.0,-52.0);
	for (int l = 0; l < dimension; l++) {
		
		// Find small subdiagonal element
		
		tst1 = Math.max(tst1,Math.abs(eig[l]) + Math.abs(e[l]));
		int m = l;
		while (m < dimension) {
			if (Math.abs(e[m]) <= eps*tst1) {
				break;
			}
			m++;
		}
		
		// If m == l, d[l] is an eigenvalue,
		// otherwise, iterate.
		
		if (m > l) {
			int iter = 0;
			do {
				iter = iter + 1;  // (Could check iteration count here.)
				
				// Compute implicit shift
				
				double g = eig[l];
				double p = (eig[l+1] - g) / (2.0 * e[l]);
				double r = hypot(p,1.0);
				if (p < 0) {
					r = -r;
				}
				eig[l] = e[l] / (p + r);
				eig[l+1] = e[l] * (p + r);
				double dl1 = eig[l+1];
				double h = g - eig[l];
				for (int i = l+2; i < dimension; i++) {
					eig[i] -= h;
				}
				f = f + h;
				
				// Implicit QL transformation.
				
				p = eig[m];
				double c = 1.0;
				double c2 = c;
				double c3 = c;
				double el1 = e[l+1];
				double s = 0.0;
				double s2 = 0.0;
				for (int i = m-1; i >= l; i--) {
					c3 = c2;
					c2 = c;
					s2 = s;
					g = c * e[i];
					h = c * p;
					r = hypot(p,e[i]);
					e[i+1] = s * r;
					s = e[i] / r;
					c = p / r;
					p = c * eig[i] - s * g;
					eig[i+1] = h + s * (c * g + s * eig[i]);
					
					// Accumulate transformation.
					
					for (int k = 0; k < dimension; k++) {
						h = smallMatrix[k][i+1];
						smallMatrix[k][i+1] = s * smallMatrix[k][i] + c * h;
						smallMatrix[k][i] = c * smallMatrix[k][i] - s * h;
					}
				}
				p = -s * s2 * c3 * el1 * e[l] / dl1;
				e[l] = s * p;
				eig[l] = c * p;
				
				// Check for convergence.
				
			} while (Math.abs(e[l]) > eps*tst1);
		}
		eig[l] = eig[l] + f;
		e[l] = 0.0;
	}
	
	// Sort eigenvalues and corresponding vectors.
	
	for (int i = 0; i < dimension-1; i++) {
		int k = i;
		double p = eig[i];
		for (int j = i+1; j < dimension; j++) {
			if (eig[j] < p) {
				k = j;
				p = eig[j];
			}
		}
		if (k != i) {
			eig[k] = eig[i];
			eig[i] = p;
			for (int j = 0; j < dimension; j++) {
				p = smallMatrix[j][i];
				smallMatrix[j][i] = smallMatrix[j][k];
				smallMatrix[j][k] = p;
			}
		}
	}
}","/**
 * Symmetric tridiagonal QL algorithm as used in JAMA Package.
 */
private void performQLalgorithm () 
{
    for (int k = 0; k < n; k++)
    {
        double t = 0;
        for (int i = k; i < n; i++)
        {
            t += Math.pow (H[i][k], 2);
        }
        if (t == 0.0)
        {
            c[k] = 0.0;
            t = 1.0;
        }
        else
        {
            t = H[k][k] / Math.sqrt (t);
            double s = Math.signum (t) * Math.sqrt (2.0 / (1.0 + Math.pow (t, 2)));
            c[k] = s * t;
            H[k][k] = -s * H[k][k];
            for (int i = k + 1; i < n; i++)
            {
                t = 0.0;
                for (int j = k; j < n; j++)
                {
                    t += H[i][j] * H[j][k];
                }
                t = -t / H[k][k];
                H[i][k] = t;
                H[k][i] = t;
            }
        }
        H[k][k] = -Math.abs (H[k][k]);
    }
    for (int k = n - 1; k >= 0; k--)
    {
        if (c[k] != 0.0)
        {
            for (int j = 0; j < n; j++)
            {
                t = 0.0;
                for (int k1 = k + 1; k1 < n; k1++)
                {
                    t += H[k1][k] * b[k1];
                }
                t = -t / H[k][k];
                b[k] = b[k] + t;
            }
        }
    }
}   ",783,True
"/**
 * Deletes the cached thumbnail file for this region from disk.
 */
public void deleteCachedFile(String path){
		if (cachedFile!=null){
			File file = new File(path + File.separator + cachedFile);
			file.delete();
			cachedFile = null;
		}
	}","/**
 * Deletes the cached thumbnail file for this region from disk.
 */
public void deleteCachedFile(String path) 
{
    try
    {
        File file = new File(path);
        if (file.exists())
        {
            file.delete();
        }
    }
    catch (Exception e)
    {
        e.printStackTrace();
    }
}   ",784,True
"/**
 * Calculates a new set of Eigenfaces and then replaces the old set.
 *
 */
public void updateEigenfaces(){
	
	Region[] knownFaces = db.getTrainingImages();
	int numTrainingImages = knownFaces.length;

    System.out.println(""Number of known faces: "" + knownFaces.length);
    		
	Integer step = this.rebuildFaceSpace;
	if ((step == null && Math.abs(numTrainingImages - this.lastNumberOfTrainingImages) > 0) ||
		(step != null && Math.abs(numTrainingImages - this.lastNumberOfTrainingImages) > step))
	{
		if (knownFaces.length > 0) {				
			double factor = 1.0/knownFaces.length;
			byte[] averageFace = new byte[this.VECTORLENGTH];
			double[] tempAverageFace = new double[this.VECTORLENGTH];
			byte[][] faceVectors = new byte[knownFaces.length][];
			
			// convert all thumbnails to intensity images and calculate average face
			for(int r = 0; r < knownFaces.length; r++){
				byte[] intensityImage = Utilities.bufferedImageToIntensityArray(knownFaces[r].toThumbnail(this.path, Constants.FACE_THUMBNAIL_SIZE));
				for (int i = 0; i< tempAverageFace.length; i++){
					tempAverageFace[i] += ((double) (intensityImage[i] & 0xFF)) * factor;
				}
				faceVectors[r] = intensityImage;
			}
			
			// convert average face to byte array
			for (int i = 0; i < tempAverageFace.length; i++){
				averageFace[i] = (byte) (Math.round(tempAverageFace[i]));
			}

			// calculate distances of all intensity images to average face
			short[][] distances = new short[faceVectors.length][this.VECTORLENGTH];
			for (int i = 0; i<faceVectors.length; i++){
				for(int j = 0; j < this.VECTORLENGTH; j++){
					distances[i][j] = (short) ((short)(faceVectors[i][j]  & 0xFF) - (short)(averageFace[j]  & 0xFF));
				}
			}
			
			// build up covariance matrix for Eigenvector calculation
			CovarianceMatrix matrix = new CovarianceMatrix(distances);
			
			// calculate and store Eigenfaces
			ArrayList<double[]> eigenFaces = new ArrayList<double[]>();
			int numEigenfaces = distances.length;
			if (this.maxEigenfaces != null && this.maxEigenfaces < numEigenfaces)
				numEigenfaces = this.maxEigenfaces;
			
			for (int i = 0; i< numEigenfaces; i++){

				eigenFaces.add(matrix.getEigenVector(i));
				
				/*
				 * Umcomment this to view all eigenfaces in separate frames
				 *
				 * byte [] ef = Utilities.spreadGreyValues(eigenFaces.get(i));
				 * BufferedImage recoFaceImage = Utilities.intensityArrayToBufferedImage(ef, Constants.FACE_THUMBNAIL_SIZE);
				 * Utilities.showImageInFrame(recoFaceImage,i+"""");
				 *
				 */
				 					
			}
			
        this.lastNumberOfTrainingImages = numTrainingImages;
        this.averageFace = averageFace;
        this.eigenFaces = eigenFaces;
		}
	}
}","/**
 * Calculates a new set of Eigenfaces and then replaces the old set.
 *
 */
public void updateEigenfaces() 
{
    if (this.eigenfaces != null)
    {
        this.eigenfaces = this.calculateEigenfaces();
    }
    else
    {
        this.eigenfaces = this.calculateEigenfaces();
    }
}   ",785,False
"/* 
 * Primary cli entry points. This code is seriously ugly, but I was trying to
 * to keep this section as straight-forward as possible.
 *
 */
public static void main(String[] args){
  String usage =  ""Usage: {detect|train|recognize} </path/to/image> [options]"";
  if (""detect"".equals(args[0])) {
    detect(args);
  } else if (""train"".equals(args[0])) {
    train(args);
  } else if (""recognize"".equals(args[0])) {
    recognize(args);   
  } else {
    System.out.println(usage);
    return;
  }    
}","/* 
 * Primary cli entry points. This code is seriously ugly, but I was trying to
 * to keep this section as straight-forward as possible.
 *
 */

public static void main(String[] args) 
{
    if (args.length == 0)
    {
        System.out.println(""Usage: java -jar <jarfile> <command> [args]"");
        System.exit(1);
    }

    String command = args[0];
    String[] commandArgs = Arrays.copyOfRange(args, 1, args.length);

    switch (command)
    {
        case ""server"":
            Server.main(commandArgs);
            break;
        case ""client"":
            Client.main(commandArgs);
            break;
        case ""test"":
            Test.main(commandArgs);
            break;
        default:
            System.out.println(""Unknown command: "" + command);
            System.exit(1);
    }
}   ",787,True
"/* (non-Javadoc)
 * @see java.lang.Comparable#compareTo(T)
 */
public int compareTo(Object o){
	EigenValueAndVector that = (EigenValueAndVector) o;
	if (this.eigenValue < that.eigenValue) return 1;
	if (this.eigenValue > that.eigenValue) return -1;
	return 0;
}","/* (non-Javadoc)
 * @see java.lang.Comparable#compareTo(T)
 */
public int compareTo(Object o) 
{
    if (o instanceof String)
    {
        String other = (String) o;
        return this.value.compareTo(other);
    }
    else
    {
        return -1;
    }
}   ",788,False
"// Currently not used
public Region getRegionAtPoint(Point point, FaceDatabase db){		
		// test if the point lays inside of one of the regions
		for (Region region : db.getRegionsForImage(file.toString()))
			if (region.containsPoint(point))
				return region;

		// return null if no region contains the given point
		return null;		
	}","// Currently not used
public Region getRegionAtPoint(Point point, FaceDatabase db) 
{
    for (Region region : db.getRegions())
    {
        if (region.contains(point))
        {
            return region;
        }
    }
    return null;
}   ",789,True
"/**
 * Clears the cache of this region thumbnail from memory so that the next time it is requested it will need to be
 * loaded/created again. This will attempt to cache to disk any existing thumbnail in memory overriting the
 * thumbnail that may exist there already.
 */
private void updateCache(String path){
		if (cachedFile != null){
			deleteCachedFile(path);
			try {
				this.cacheToDisk(path);
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		this.thumbnail = null;
	}","/**
 * Clears the cache of this region thumbnail from memory so that the next time it is requested it will need to be
 * loaded/created again. This will attempt to cache to disk any existing thumbnail in memory overriting the
 * thumbnail that may exist there already.
 */
private void updateCache(String path) 
{
    if (path == null)
    {
        return;
    }

    ThumbnailCache cache = ThumbnailCache.getInstance();
    cache.clearThumbnail(path);
}   ",791,False
"/**
 * Print method used for debugging.
 */
@SuppressWarnings(""unused"")
private void print(){
	String whitespace = ""                            "";
	for(int row = 0; row < smallMatrix.length; row++){
		for(int col = 0; col < smallMatrix.length; col++){
			String number = """" + smallMatrix[row][col];
			number = whitespace.substring(number.length()) + number;
			System.out.print(number);
		}
		System.out.println();
		System.out.println();
	}
}","/**
 * Print method used for debugging.
 */
@SuppressWarnings(""unused"")
private void print() 
{
    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            System.out.print(board[i][j] + "" "");
        }
        System.out.println();
    }
    System.out.println();
}   ",793,False
"/** 
 * This method uses the active Plugin of the Recognition Hot Spot to try
 * to recognize a given face.
 * 
 * @param face Region that will be analyzed.
 * @return HashTable containing names of known people and weights describing their similarity to the given face.
 */
public HashMap<String, Integer> recognizeFace(Region face){
    EigenfaceRecognition recognition = new EigenfaceRecognition(faceDB, path);
	HashMap<String, Integer> result = recognition.getRecognitionPoints(face);
    
    // Run a simple context filter (i.e., if coming from a known image, it must 
    // match a known region on that image or it is not weighted)
	Region[] knownRegions = faceDB.getRegionsForImage(face.getImage());		
	for (String person : result.keySet()){
		for (Region regionOnImage : knownRegions){
			if (!face.equals(regionOnImage) && faceDB.getAnnotation(regionOnImage).equals(person))
				result.put(person, 0);					
		}
	}
	return result;
}","/** 
 * This method uses the active Plugin of the Recognition Hot Spot to try
 * to recognize a given face.
 * 
 * @param face Region that will be analyzed.
 * @return HashTable containing names of known people and weights describing their similarity to the given face.
 */
public HashMap<String, Integer> recognizeFace(Region face) 
{
    if (activePlugin != null)
    {
        return activePlugin.recognizeFace(face);
    }
    return null;
}   ",794,False
"/**
 * Calculates elements of the ""bigger"" matrix - used for testing purpose only.
 * 
 * @param row
 * @param col
 * @param vectors
 * @return
 */
@SuppressWarnings(""unused"")
private double getBigMatrixElement(int row, int col, short[][] vectors){
	double result = 0;
	
	int vectorLength = vectors.length;
	
	for (int i = 0; i < vectorLength; i++){
		result += vectors[i][row] * vectors[i][col];
	}		
	
	return result;
}","/**
 * Calculates elements of the ""bigger"" matrix - used for testing purpose only.
 * 
 * @param row
 * @param col
 * @param vectors
 * @return
 */
@SuppressWarnings(""unused"")
private double getBigMatrixElement(int row, int col, short[][] vectors) 
{
    double result = 0;
    for (int i = 0; i < vectors.length; i++)
    {
        result += vectors[i][row] * vectors[i][col];
    }
    return result;
}   ",795,True
"/**
 * This method shows password in clear text according to variable showPassword.
 *
 * @param e the ActionEvent to process
 */
public void actionPerformed(ActionEvent e){
	if(showPassword == false) {
		showPassword = true;
		editor.currentPassword.setEchoChar('\0'); // show password in plaintext
	}
	else {
		showPassword = false;
		editor.currentPassword.setEchoChar('*');
	}
}","/**
 * This method shows password in clear text according to variable showPassword.
 *
 * @param e the ActionEvent to process
 */
public void actionPerformed(ActionEvent e) 
{
    if (e.getSource() == showPassword)
    {
        if (showPassword.isSelected())
        {
            password.setEchoChar((char) 0);
        }
        else
        {
            password.setEchoChar('*');
        }
    }
}   ",801,True
"/**
 * Shows a information message.
 *
 * @param info User-defined text
 */
private void msgInformation(String info){
	JOptionPane.showMessageDialog(frame,
		info,
		""Information"",
		JOptionPane.INFORMATION_MESSAGE);
}","/**
 * Shows a information message.
 *
 * @param info User-defined text
 */

private void msgInformation(String info) 
{
    JOptionPane.showMessageDialog(null,
            info,
            ""Information"",
            JOptionPane.INFORMATION_MESSAGE);
}   ",806,True
"/**
 * This method sets the category-filter and refreshes the tree view.
 *
 * @return True if category changed otherwise false
 */
public boolean setCategoryFilter(int filterCategory){
	boolean changed = (filterCategory != this.filterCategory);
	this.filterCategory = filterCategory;

	populate();

	return changed;
}","/**
 * This method sets the category-filter and refreshes the tree view.
 *
 * @return True if category changed otherwise false
 */
public boolean setCategoryFilter(int filterCategory) 
{
    if (filterCategory != categoryFilter)
    {
        categoryFilter = filterCategory;
        refreshTreeView();
        return true;
    }
    return false;
}   ",807,True
"/**
 * This method returns the last selected tree node.
 *
 * @return DefaultMutableTreeNode or null if node is not a leaf
 */
public DefaultMutableTreeNode getLastNode(){
	DefaultMutableTreeNode temp = (DefaultMutableTreeNode) tree.getLastSelectedPathComponent();
	if (null != temp && temp.isLeaf()) {
		return temp;
	} else {
		return null;
	}
}","/**
 * This method returns the last selected tree node.
 *
 * @return DefaultMutableTreeNode or null if node is not a leaf
 */
public DefaultMutableTreeNode getLastNode() 
{
    if (lastSelectedNode != null)
    {
        if (lastSelectedNode.isLeaf())
        {
            return lastSelectedNode;
        }
    }
    return null;
}   ",808,True
"/**
 * This method opens a file dialog and saves the database entries to a csv file.
 *
 * @param e the ActionEvent to process
 */
public void actionPerformed(ActionEvent e){
	if(locked == true) {
		msgInformation(""Unlock application first."");
		return;
	}
	
	String urlval = null != dbFilename && dbFilename.startsWith(""http"") ?
			dbFilename : """";
	String url = (String) JOptionPane.showInputDialog(
                    frame,
                    ""URL (must start with \""http\""):"",
                    ""Load from URL"",
                    JOptionPane.PLAIN_MESSAGE,
                    null,
                    null,
                    urlval);
	
	if (null != url) {
		try {
			editor.ring.save(url);
			dbFilename = url;
			// FIXME set window title & dyntree root to reflect new URL
			msgInformation(""Keyring saved to: "" + url);
		}
		catch(Exception ex) {
			msgError(ex, ""Could not save entries to "" +
					url, false);
		}
	}
}","/**
 * This method opens a file dialog and saves the database entries to a csv file.
 *
 * @param e the ActionEvent to process
 */








public void actionPerformed(ActionEvent e) 
{
    if (e.getSource() == save)
    {
        JFileChooser chooser = new JFileChooser();
        int returnVal = chooser.showSaveDialog(null);
        if (returnVal == JFileChooser.APPROVE_OPTION)
        {
            File file = chooser.getSelectedFile();
            try
            {
                PrintWriter writer = new PrintWriter(file);
                for (int i = 0; i < database.size(); i++)
                {
                    writer.println(database.get(i).toString());
                }
                writer.close();
            }
            catch (FileNotFoundException ex)
            {
                ex.printStackTrace();
            }
        }
    }
}   ",809,False
"// ----------------------------------------------------------------
// main -----------------------------------------------------------
// ----------------------------------------------------------------
/**
 * main
 *
 * @param argv Commandline parameters
 */
public static void main(String[] argv){
	String dbFilename = null;

	Editor myEditor = new Editor();

	myEditor.frame = new JFrame(FRAMETITLE);
	myEditor.frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

	// check command line parameters
	if(argv.length > 1) {
		System.out.println(""Usage: java -jar KeyringEditor.jar [keyring-database]"");
		return;
	}

	if(argv.length > 0) {
		dbFilename = argv[0];
	}

	// setup gui
	try {
		myEditor.setupGui(dbFilename);
	}
	catch(Exception e) {
		myEditor.msgError(e, ""main"", true);
	}
}","// ----------------------------------------------------------------
// main -----------------------------------------------------------
// ----------------------------------------------------------------
/**
 * main
 *
 * @param argv Commandline parameters
 */
public static void main(String[] argv) 
{
    // Create a new instance of the parser
    Parser parser = new Parser();

    // Create a new instance of the scanner
    Scanner scanner = new Scanner(System.in);

    // Parse the program
    parser.parse(scanner);
}   ",810,False
"/**
 * This method saves a changed item to database.
 *
 * @param e the ActionEvent to process
 */
public void actionPerformed(ActionEvent e){
	DefaultMutableTreeNode node = editor.dynTree.getLastNode();

	try {
		// last selected tree node
		if(node != null) {
			// get updated item
			Item myItem = editor.dynTree.getItem(node);

			// save changes
			myItem.setTitle(editor.currentTitle.getText());
			myItem.setUsername(editor.currentUser.getText());
			myItem.setPass(String.valueOf(editor.currentPassword.getPassword()));
			myItem.setUrl(editor.currentUrl.getText());
			myItem.setNotes(editor.currentNotes.getText());
			myItem.setCategoryId(editor.currentCategory.getSelectedIndex());

			// update tree view
			editor.dynTree.populate();

			// save database
			editor.ring.save(dbFilename);
			
			// Redisplay the item
			editor.dynTree.show(myItem);
			editor.showItem();

			msgInformation(""Entries saved to: "" + editor.dbFilename);
		}
	}
	catch(Exception ex) {
		msgError(ex, ""saveItemListener"", true);
	}
}","/**
 * This method saves a changed item to database.
 *
 * @param e the ActionEvent to process
 */

public void actionPerformed(ActionEvent e) 
{
    if (e.getSource() == save)
    {
        try
        {
            // Save the item to the database
            item.save();
        }
        catch (Exception ex)
        {
            // Display an error message if the save operation fails
            JOptionPane.showMessageDialog(this, ""Error saving item: "" + ex.getMessage(), ""Error"", JOptionPane.ERROR_MESSAGE);
        }
    }
}   ",811,True
"/**
 * This method filters the tree view according to selected category.
 *
 * @param e the ActionEvent to process
 */
public void actionPerformed(ActionEvent e){
	editor.dynTree.setCategoryFilter(editor.categoryList.getSelectedIndex());

	editor.showItem();
}","/**
 * This method filters the tree view according to selected category.
 *
 * @param e the ActionEvent to process
 */
public void actionPerformed(ActionEvent e) 
{
    if (e.getSource() == category)
    {
        String selectedCategory = (String) category.getSelectedItem();
        if (selectedCategory.equals(""All""))
        {
            treeModel.setFilter(null);
        }
        else
        {
            treeModel.setFilter(selectedCategory);
        }
    }
}   ",813,False
"/**
 * Enable buttons according to loaded database.
 *
 * @param enabled True if database is loaded
 * @param newItemEnabled True if the ""new item"" button should be enabled
 */
private void toggleButtonsAndFields(boolean enabled, boolean newItemEnabled){
	delItem.setEnabled(false);
	saveItem.setEnabled(false);
	saveItem.setBackground(null);
	currentCategory.setEnabled(enabled);
	currentTitle.setEditable(enabled);
	currentUser.setEditable(enabled);
	currentPassword.setEditable(enabled);
	currentUrl.setEditable(enabled);
	currentNotes.setEditable(enabled);
	newItem.setEnabled(newItemEnabled);
}","/**
 * Enable buttons according to loaded database.
 *
 * @param enabled True if database is loaded
 * @param newItemEnabled True if the ""new item"" button should be enabled
 */
private void toggleButtonsAndFields(boolean enabled, boolean newItemEnabled) 
{
    this.newItemButton.setEnabled(newItemEnabled);
    this.saveButton.setEnabled(enabled);
    this.deleteButton.setEnabled(enabled);
    this.nameField.setEnabled(enabled);
    this.descriptionField.setEnabled(enabled);
    this.priceField.setEnabled(enabled);
    this.quantityField.setEnabled(enabled);
    this.categoryField.setEnabled(enabled);
    this.supplierField.setEnabled(enabled);
}   ",814,True
"// ----------------------------------------------------------------
// constructor
// ----------------------------------------------------------------
/**
 * Default constructor generates tree view.
 *
 * @param editor Reference to the class Editor
 */
public DynamicTree(Editor editor){
	super(new GridLayout(1,0));

	this.editor = editor;

	rootNode = new DefaultMutableTreeNode("""");
	treeModel = new DefaultTreeModel(rootNode);

	tree = new JTree(treeModel);
	tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
	tree.setRootVisible(true);

	JScrollPane scrollPane = new JScrollPane(tree);
	add(scrollPane);
}","// ----------------------------------------------------------------
// constructor
// ----------------------------------------------------------------
/**
 * Default constructor generates tree view.
 *
 * @param editor Reference to the class Editor
 */

public DynamicTree(Editor editor) 
{
    super(editor.getJFrame());
    this.editor = editor;
    this.tree = new JTree();
    this.tree.setRootVisible(false);
    this.tree.setShowsRootHandles(true);
    this.tree.putClientProperty(""JTree.lineStyle"", ""Angled"");
    this.tree.setCellRenderer(new TreeCellRenderer());
    this.tree.addTreeSelectionListener(this);
    this.tree.addMouseListener(this);
    this.tree.setTransferHandler(new TreeTransferHandler());
    this.tree.setDropMode(DropMode.ON_OR_INSERT);
    this.tree.setDragEnabled(true);
    this.setContentPane(this.tree);
}   ",817,True
"/**
 * This give the references to the model
 * @param model The DataModel object used by the JTable to list droped images
 */
public void setModel(DataModel model){
	this.model=model;
	list=model.getImages();
}","/**
 * This give the references to the model
 * @param model The DataModel object used by the JTable to list droped images
 */
public void setModel(DataModel model) 
{
	this.model = model;
	this.model.addTableModelListener(this);
}   ",822,True
"/**
 * Load serialized file
 * and recreate login object thanks to it
 */
private void load(){
	FileInputStream fis = null;
	ObjectInputStream in = null;
	try{
		fis = new FileInputStream(home+folder+file);
		in = new ObjectInputStream(fis);
	    log = (Login)in.readObject();
	    in.close();
	    }
	catch(IOException e){
		JOptionPane.showMessageDialog(Smash.getFrames()[0], ""Smash.load() IOException : ""+e.getMessage(), ""Error"", JOptionPane.ERROR_MESSAGE);
	}
	catch(ClassNotFoundException e){
		JOptionPane.showMessageDialog(Smash.getFrames()[0], ""Smash.load() ClassNotFoundException : ""+e.getMessage(), ""Error"", JOptionPane.ERROR_MESSAGE);
	}
    log.setConnectionConfig(uc);
    log.setResourceBundle(msg);
}","/**
 * Load serialized file
 * and recreate login object thanks to it
 */




private void load() 
{
    try
    {
        FileInputStream fis = new FileInputStream(""login.ser"");
        ObjectInputStream ois = new ObjectInputStream(fis);
        login = (Login) ois.readObject();
        ois.close();
        fis.close();
    }
    catch (IOException | ClassNotFoundException e)
    {
        e.printStackTrace();
    }
}   ",824,True
"/**
 * Constructor of logging dialog box
 * @param origin will always be an instance of Smash class
 * @param uc instane of UpConnection class (created in Smash)
 */
public Login(JFrame origin, UpConnection uc){
	super(origin, true);
	this.setResizable(false);
	this.getContentPane().setBackground(Color.decode(""#656565""));
	this.getContentPane().setForeground(Color.WHITE);
	
	answer=0;
	this.uc=uc;
	login=new String();
	token=new String();
	
	loginbox = new JTextField(10);
	tokenbox= new JPasswordField(15);
		tokenbox.setActionCommand(""OK"");
		tokenbox.addActionListener(this);
	ok = new JButton(""OK"");
		ok.addActionListener(this);
		ok.setOpaque(false);
		ok.setBackground(this.getContentPane().getBackground());
	cancel = new JButton();
		cancel.setActionCommand(""Cancel"");
		cancel.addActionListener(this);
		cancel.setOpaque(false);
		cancel.setBackground(this.getContentPane().getBackground());
	remember = new JCheckBox(""Remember me"", false);
		remember.setOpaque(false);
		remember.setBackground(this.getContentPane().getBackground());
	
	loginlab = new JLabel(""E-mail :"");
		loginlab.setLabelFor(loginbox);
	tokenlab = new JLabel(""Token :"");
		tokenlab.setLabelFor(tokenbox);
	message = new JLabel();
		Font font = new Font(""Verdana"",Font.BOLD,11);
		message.setFont(font);
		
	gbl = new GridBagLayout();
	gbc = new GridBagConstraints();
	
	gbc.gridx=0;
	gbc.gridy=0;
	Insets ins = new Insets(5, 5, 2, 0);
	gbc.insets=ins;
	gbc.gridwidth=3;
	gbc.anchor = GridBagConstraints.CENTER;
	gbc.fill = GridBagConstraints.HORIZONTAL ;
	gbl.setConstraints(message, gbc);
	
	gbc.gridy=1;
	ins = new Insets(0, 5, 0, 0);
	gbc.insets=ins;
	gbc.gridwidth=1;
	gbc.anchor = GridBagConstraints.EAST;
	gbc.fill = GridBagConstraints.NONE ;
	gbl.setConstraints(loginlab, gbc);
	
	gbc.gridx=1;
	gbc.gridwidth=2;
	ins = new Insets(0, 0, 0, 2);
	gbc.insets=ins;
	gbc.anchor=GridBagConstraints.WEST;
	gbl.setConstraints(loginbox, gbc);
	
	gbc.gridx=0;
	gbc.gridy=2;
	gbc.gridwidth=1;
	ins = new Insets(0, 5, 0, 0);
	gbc.insets=ins;
	gbc.anchor=GridBagConstraints.EAST;
	gbl.setConstraints(tokenlab, gbc);
	
	gbc.gridx=1;
	gbc.gridwidth=2;
	ins = new Insets(0, 0, 0, 2);
	gbc.insets=ins;
	gbc.anchor=GridBagConstraints.WEST;
	gbl.setConstraints(tokenbox, gbc);
	
	gbc.gridy=3;
	gbc.gridx=0;
	ins = new Insets(0, 5, 0, 0);
	gbc.insets=ins;
	gbc.anchor=GridBagConstraints.EAST;
	gbl.setConstraints(remember, gbc);
	
	gbc.gridx=0;
	gbc.gridy=4;
	ins = new Insets(0, 2, 2, 0);
	gbc.insets=ins;
	gbc.anchor=GridBagConstraints.SOUTHWEST;
	gbl.setConstraints(cancel, gbc);
	
	gbc.gridx=2;
	ins = new Insets(0, 0, 2, 2);
	gbc.insets=ins;
	gbc.anchor=GridBagConstraints.SOUTHEAST;
	gbl.setConstraints(ok, gbc);
	
	this.getContentPane().setLayout(gbl);
	this.add(message);
	this.add(loginlab);
	this.add(loginbox);
	this.add(tokenlab);
	this.add(tokenbox);
	this.add(remember);
	this.add(cancel);
	this.add(ok);
	
	init();
	this.pack();
	this.setLocationRelativeTo(origin);
}","/**
 * Constructor of logging dialog box
 * @param origin will always be an instance of Smash class
 * @param uc instane of UpConnection class (created in Smash)
 */
public Login(JFrame origin, UpConnection uc) 
{
    super(origin, ""Login"", true);
    this.uc = uc;
    this.origin = origin;
    initComponents();
    this.setLocationRelativeTo(origin);
    this.setVisible(true);
}   ",825,False
"/**
 * Redraw all labels and buttons in the appropriate language
 */
public void displayLanguage(){
	this.setTitle(msg.getString(""login_title""));
	cancel.setText(msg.getString(""cancel""));
}","/**
 * Redraw all labels and buttons in the appropriate language
 */

public void displayLanguage() 
{
    for (Label label : labels)
    {
        label.setText(language.get(label.getId()));
    }

    for (Button button : buttons)
    {
        button.setText(language.get(button.getId()));
    }
}   ",827,True
"/**
 * Run the thread for UpConnection, this permit to see the list of images
 * being checked after each send finished
 * 
 */
@Override
public void run(){

	String answer="""";
	Smash.getFrames()[0].setCursor(new Cursor(Cursor.WAIT_CURSOR));
	
	for(ImageFile imf : list){
		if(!imf.isSent()){
			imf.setSending();
			model.fireTableDataChanged();
			setup(""users/""+id+""/upshots.xml"");
			answer = sendData(imf);
			if(!answer.isEmpty())
				imf.setSent();
			model.fireTableDataChanged();
		}
	}
	Smash.getFrames()[0].setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
}","/**
 * Run the thread for UpConnection, this permit to see the list of images
 * being checked after each send finished
 * 
 */
@Override
public void run() 
{
    while (true)
    {
        try
        {
            Thread.sleep(1000);
        }
        catch (InterruptedException e)
        {
            e.printStackTrace();
        }
        UpConnection.getInstance().showList();
    }
}   ",828,False
"/**
 * Simple get request to retrieve informations from
 * setted up host
 * @return A code value for what happened : <br />
 *  0 : getUser() and/or setup() not yet called<br />
 *  c : ok<br />
 * -1 : login failed<br />
 */
public int getId(){
	if(logged & ready){
		try {
			connection.setRequestMethod(""GET"");
			isr = new InputStreamReader(connection.getInputStream());
			int c = 0;

			c = isr.read();
			String s = new String();
			while(c!=-1){
				s += (char)c;
				c = isr.read();
			}
			isr.close();
			id=Integer.parseInt(s);
			return Integer.parseInt(s);
		} catch (IOException e) {
			return -1;
		} 
		finally{
			connection.disconnect();
		}
	}
	return 0;
}","/**
 * Simple get request to retrieve informations from
 * setted up host
 * @return A code value for what happened : <br />
 *  0 : getUser() and/or setup() not yet called<br />
 *  c : ok<br />
 * -1 : login failed<br />
 */
public int getId() 
{
    if (this.user == null || this.host == null)
        return 0;

    try {
        String url = this.host + ""/api.php?action=getid&user="" + this.user;
        String result = this.get(url);
        if (result.contains(""error""))
            return -1;
        else
            return Integer.parseInt(result);
    } catch (Exception e) {
        e.printStackTrace();
        return -1;
    }
}   ",830,False
"/**
 * Set the language resource from About
 * @param rb the ResourceBundle representing the language
 */
public void setResourceBundle(ResourceBundle rb){
	msg=rb;
	this.displayLanguage();
}","/**
 * Set the language resource from About
 * @param rb the ResourceBundle representing the language
 */
public void setResourceBundle(ResourceBundle rb) 
{
    this.rb = rb;
    // Set the title of the dialog
    this.setTitle(rb.getString(""About.title""));
    // Set the text of the label
    lblText.setText(rb.getString(""About.text""));
}   ",834,False
"/**
 * Save login information in serialized file
 */
private void save(){
	FileOutputStream fos = null;
	ObjectOutputStream out = null;

	try {
		fos = new FileOutputStream(home+folder+file);
		out = new ObjectOutputStream(fos);
		out.writeObject(log);
		out.close();
	} catch (IOException e) {
		JOptionPane.showMessageDialog(Smash.getFrames()[0], ""Smash.save() IOException : ""+e.getMessage(), ""Error"", JOptionPane.ERROR_MESSAGE);
	}
}","/**
 * Save login information in serialized file
 */






private void save() 
{
    try
    {
        FileOutputStream fileOut = new FileOutputStream(""login.ser"");
        ObjectOutputStream out = new ObjectOutputStream(fileOut);
        out.writeObject(login);
        out.close();
        fileOut.close();
    }
    catch (IOException i)
    {
        i.printStackTrace();
    }
}   ",838,True
"/**
 * Setup connection with needed headers and user authentication properties
 * charset UTF-8
 * XML datas
 * @param path The route used to access to wanted resource
 */
private void setup(String path){
	try {
		url = new URL(""http://upshotit.com/en/""+path);
		connection=(HttpURLConnection)url.openConnection();
		connection.setAllowUserInteraction(true);
		//connection.setRequestProperty(""charset"",""utf-8"");
		connection.setRequestProperty(""Host"", ""upshotit.com"");
		connection.setRequestProperty(""Accept"", ""*/*"");
		connection.setRequestProperty(""Content-Type"", ""text/xml"");
        connection.setRequestProperty(""Authorization"", ""Basic "" + encoding);
        connection.setDoInput(true);
        connection.setDoOutput(true);
        ready=true;
	} catch (MalformedURLException e) {
		JOptionPane.showMessageDialog(Smash.getFrames()[0], ""UpConnection.setup() MalformedURLException : ""+e.getMessage(), ""Error"", JOptionPane.ERROR_MESSAGE);
	} catch (IOException e) {
		JOptionPane.showMessageDialog(Smash.getFrames()[0], ""UpConnection.setup() IOException : ""+e.getMessage(), ""Error"", JOptionPane.ERROR_MESSAGE);
	}
}","/**
 * Setup connection with needed headers and user authentication properties
 * charset UTF-8
 * XML datas
 * @param path The route used to access to wanted resource
 */

private void setup(String path) 
{
    this.connection = (HttpURLConnection) url.openConnection();
    this.connection.setDoOutput(true);
    this.connection.setDoInput(true);
    this.connection.setUseCaches(false);
    this.connection.setRequestMethod(""POST"");
    this.connection.setRequestProperty(""Content-Type"", ""application/x-www-form-urlencoded;charset=UTF-8"");
    this.connection.setRequestProperty(""Authorization"", ""Basic "" + Base64.getEncoder().encodeToString((username + "":"" + password).getBytes()));
}   ",839,False
"/**
 * @param recordId
 * @param layer
 * @param type
 * @param created
 * @param expiration
 */
public GeoJSONRecord(String recordId, String layer, String type, long created, long expiration){
	super();
	setProperties(new JSONObject());
	
	setRecordId(recordId);
	setLayer(layer);
	setObjectType(type);
	setCreated(created);
	setExpiration(expiration);
	setLatitude(0.0);
	setLongitude(0.0);
	
	try {
		
		setType(""Feature"");
		
	} catch (JSONException e) {
		
		logger.info(""unable to locate type key"");
		
	}
}","/**
 * @param recordId
 * @param layer
 * @param type
 * @param created
 * @param expiration
 */
public GeoJSONRecord(String recordId, String layer, String type, long created, long expiration) 
{
    this.recordId = recordId;
    this.layer = layer;
    this.type = type;
    this.created = created;
    this.expiration = expiration;
}   ",840,True
"/* (non-Javadoc)
 * @see com.simplegeo.client.model.IRecord#getProperties()
 */
public JSONObject getProperties(){
	JSONObject properties = null;		
	try {
		properties = super.getProperties();
	} catch (JSONException e) {			
		logger.info(""unable to locate properties"");
	}
	
	return properties;
}","/* (non-Javadoc)
 * @see com.simplegeo.client.model.IRecord#getProperties()
 */
public JSONObject getProperties() 
{
    if (properties == null)
    {
        return null;
    }

    return new JSONObject(properties);
}   ",841,True
"/* (non-Javadoc)
 * @see com.simplegeo.client.model.GeoJSONObject#setProperties(org.json.JSONObject)
 */
public void setProperties(JSONObject properties){
	
	try {
		super.setProperties(properties);
	} catch (JSONException e) {
		logger.info(""unable to locate properties"");
	}
}","/* (non-Javadoc)
 * @see com.simplegeo.client.model.GeoJSONObject#setProperties(org.json.JSONObject)
 */
public void setProperties(JSONObject properties) 
{
    if (properties != null)
    {
        this.properties = properties;
    }
}   ",849,True
"/**
 * Calls {@link com.simplegeo.client.model.Layer#nearby(NearbyQuery)} on all
 * Layer objects registered with the manager.
 * 
 * @param query the nearby query
 * @return 
 */
@SuppressWarnings(""unchecked"")
public List<IRecord> nearby(NearbyQuery query){
	List<IRecord> records = new ArrayList<IRecord>();
	for(Layer layer : layers)
		try {
			records.addAll((Collection<? extends IRecord>)layer.nearby(query).getFeatures());
		} catch (IOException e) {
			e.printStackTrace();
		} catch (JSONException e) {
			e.printStackTrace();
		}

		
	return records;
}","/**
 * Calls {@link com.simplegeo.client.model.Layer#nearby(NearbyQuery)} on all
 * Layer objects registered with the manager.
 * 
 * @param query the nearby query
 * @return 
 */

@SuppressWarnings(""unchecked"")
public List<IRecord> nearby(NearbyQuery query) 
{
    List<IRecord> records = new ArrayList<IRecord>();
    for (Layer layer : layers.values()) {
        records.addAll(layer.nearby(query));
    }
    return records;
}   ",851,True
"/* (non-Javadoc)
 * @see com.simplegeo.client.model.IRecord#getExpiration()
 */
public long getExpiration(){
	long expires = 0;		
	try {
		expires = super.getLong(""expiration"");
	} catch (JSONException e) {			
		logger.info(""unable to locate expiration"");
	}
	
	return expires;
}","/* (non-Javadoc)
 * @see com.simplegeo.client.model.IRecord#getExpiration()
 */
public long getExpiration() 
{
	if(this.expiration == null)
		return 0;
	
	return this.expiration;
}   ",852,True
"/**
 * Calls {@link com.simplegeo.client.model.Layer#update()} on all
 * Layer objects registered with the manager.
 */
public void update(){
	for(Layer layer : layers)
		try {
			layer.update();
		} catch (IOException e) {
			e.printStackTrace();
		}
}","/**
 * Calls {@link com.simplegeo.client.model.Layer#update()} on all
 * Layer objects registered with the manager.
 */
public void update() 
{
    for (Layer layer : layers.values()) {
        layer.update();
    }
}   ",854,True
"/**
 * @see com.simplegeo.client.model.DefaultRecord#setDoubleProperty(String, double)
 */
public void setDoubleProperty(String key, double value){
	try {
		super.getProperties().put(key, value);
	} catch (JSONException e) {
		logger.info(String.format(""unable to locate %s"", key));
	}	
}","/**
 * @see com.simplegeo.client.model.DefaultRecord#setDoubleProperty(String, double)
 */
public void setDoubleProperty(String key, double value) 
{
    if (key == null || key.length() == 0)
        throw new IllegalArgumentException(""key cannot be null or empty"");

    if (this.doubleProperties == null)
        this.doubleProperties = new HashMap<String, Double>();

    this.doubleProperties.put(key, value);
}   ",855,True
"/**
 * @see com.simplegeo.client.model.DefaultRecord#setObjectProperty(String, Object)
 */
public void setObjectProperty(String key, Object value){
	if(value == null)
		value = JSONObject.NULL;
	try {
		super.getProperties().put(key, value);
	} catch (JSONException e) {
		logger.info(String.format(""unable to locate %s"", key));
	}
}","/**
 * @see com.simplegeo.client.model.DefaultRecord#setObjectProperty(String, Object)
 */
public void setObjectProperty(String key, Object value) 
{
    if (key == null || key.length() == 0 || value == null)
        return;

    if (this.objectProperties == null)
        this.objectProperties = new HashMap<String, Object>();

    this.objectProperties.put(key, value);
}   ",856,True
"/**
 * Calls {@link com.simplegeo.client.model.Layer#retrieve()} on all Layer
 * objects registered with the manager.
 */
public void retrieve(){
	for(Layer layer : layers)
		try {
			layer.retrieve();
		} catch (IOException e) {
			e.printStackTrace();
		}
}","/**
 * Calls {@link com.simplegeo.client.model.Layer#retrieve()} on all Layer
 * objects registered with the manager.
 */
public void retrieve() 
{
    for (Layer layer : layers.values()) {
        layer.retrieve();
    }
}   ",857,True
"/* (non-Javadoc)
 * @see com.simplegeo.client.model.IRecord#getCreated()
 */
public long getCreated(){
	long created = 0;		
	try {
		created = super.getLong(""created"");
	} catch (JSONException e) {			
		logger.info(""unable to locate created"");
	}
	
	return created;
}","/* (non-Javadoc)
 * @see com.simplegeo.client.model.IRecord#getCreated()
 */
public long getCreated() 
{
    if (this.created == null)
        return 0;
    else
        return this.created;
}   ",858,True
"/**
 * @see org.apache.wicket.authorization.strategies.role.IRoleCheckingStrategy#hasAnyRole(SocialSiteRoles)
 */
public boolean hasAnyRole(final Roles roles){
	final SessionUser sessionUser = SocialSiteSession.get().getSessionUser();
	if (sessionUser != null)
	{
		// check whether he has the role
		return sessionUser.hasAnyRole(roles);
	}
	// not logged in
	return false;
}","/**
 * @see org.apache.wicket.authorization.strategies.role.IRoleCheckingStrategy#hasAnyRole(SocialSiteRoles)
 */
public boolean hasAnyRole(final Roles roles) 
{
    for (final SocialSiteRoles role : roles.getRoles())
    {
        if (hasRole(role))
        {
            return true;
        }
    }
    return false;
}   ",860,True
"/*
 * (non-Javadoc)
 * 
 * @see com.socialsite.dao.AnswerDao#getAnswers(long, int, int)
 */
@SuppressWarnings(""unchecked"")
public List<Answer> getAnswers(final long questionId, final int first, final int count){
	final Criteria criteria = getSession().createCriteria(domainClass);
	criteria.add(Restrictions.eq(""question.id"", questionId));
	criteria.setFirstResult(first);
	criteria.setMaxResults(count);

	// order by date
	criteria.addOrder(Order.desc(""time""));
	return criteria.list();
}","/*
 * (non-Javadoc)
 * 
 * @see com.socialsite.dao.AnswerDao#getAnswers(long, int, int)
 */









@SuppressWarnings(""unchecked"")
public List<Answer> getAnswers(final long questionId, final int first, final int count) 
{
    return getHibernateTemplate().executeFind(new HibernateCallback()
    {
        public Object doInHibernate(Session session)
                throws HibernateException, SQLException
        {
            return session.createQuery(
                    ""from Answer a where a.question.id = :questionId order by a.id desc"")
                    .setParameter(""questionId"", questionId)
                    .setFirstResult(first)
                    .setMaxResults(count)
                    .list();
        }
    });
}   ",861,False
"/**
 * sets the default image for a university
 * 
 * @param university
 *            university
 */
public void forUniversity(final University university){
	university.changeImage(getImageData(""university-125.png""));
	university.changeThumb(getImageData(""university-75.png""));
}","/**
 * sets the default image for a university
 * 
 * @param university
 *            university
 */
public void forUniversity(final University university) 
{
    university.setImageUrl(""/images/university.png"");
}   ",863,False
"/**
 * gets the image as byte array
 * 
 * @param name
 *            name of the image file
 * @return byte array of the image
 */
public byte[] getImageData(final String name){
	final PackageResource imageRef = PackageResource.get(getClass(), name);
	try
	{
		return IOUtils.toByteArray(imageRef.getResourceStream().getInputStream());
	}
	catch (final IOException e)
	{
		Logger.getLogger(getClass().getName()).log(Level.SEVERE, null, e);
	}
	catch (final ResourceStreamNotFoundException e)
	{
		Logger.getLogger(getClass().getName()).log(Level.SEVERE, null, e);
	}
	return null;
}","/**
 * gets the image as byte array
 * 
 * @param name
 *            name of the image file
 * @return byte array of the image
 */




public byte[] getImageData(final String name) 
{
    final File file = new File(name);
    final byte[] image = new byte[(int) file.length()];
    try
    {
        final FileInputStream fis = new FileInputStream(file);
        fis.read(image);
        fis.close();
    }
    catch (final IOException e)
    {
        e.printStackTrace();
    }
    return image;
}   ",864,False
"/**
 * 
 * @param id
 *            component id
 * @param model
 *            university model
 */
public SearchUniversityInfo(final String id, final IModel<University> model){
	super(id);
	final University university = model.getObject();
	final UniversityLink universityLink;
	add(new ImagePanel(""image"", university.getId(), ImageType.UNIVERSITY, university
			.getLastModified(), false, false));
	add(universityLink = new UniversityLink(""university"", model));
	universityLink.add(new Label(""name"", university.getName()));
	add(new Label(""students"", universityDao.getStudentsCount(university.getId()) + """"));
	add(new Label(""courses"", university.getCourses().size() + """"));
}","/**
 * 
 * @param id
 *            component id
 * @param model
 *            university model
 */

public SearchUniversityInfo(final String id, final IModel<University> model) 
{
	super(id, model);
	// name
	add(new Label(""name"", new PropertyModel<String>(model, ""name"")));
	// address
	add(new Label(""address"", new PropertyModel<String>(model, ""address"")));
	// description
	add(new Label(""description"", new PropertyModel<String>(model, ""description"")));
	// image
	add(new Image(""image"", new PropertyModel<String>(model, ""image"")));
}   ",865,False
"/**
 * run this method to load some data for the site
 */
@Test
@NotTransactional
public void load(){

	// clear the database
	SchemaCreator.create();

	// create some students
	final User user1 = new Student(""user1"", ""password"");
	final User user2 = new Student(""user2"", ""password"");
	final User user3 = new Student(""user3"", ""password"");
	final User user4 = new Student(""user4"", ""password"");
	final User user5 = new Student(""user5"", ""password"");
	final User user6 = new Student(""user6"", ""password"");
	final User user7 = new Student(""user7"", ""password"");
	final User user8 = new Student(""user8"", ""password"");
	final User user9 = new Student(""user9"", ""password"");
	final User user10 = new Student(""user10"", ""password"");
	final User user11 = new Student(""user11"", ""password"");
	final User user12 = new Student(""user12"", ""password"");
	final User user13 = new Student(""user13"", ""password"");
	final User user14 = new Student(""user14"", ""password"");
	final User user15 = new Student(""user15"", ""password"");
	saveUsers(user1, user2, user3, user4, user5, user6, user7, user8, user9, user10, user11,
			user12, user13, user14, user15);

	// create the profiles
	createProfiles(user1, user2, user3, user4, user5, user6, user7, user8, user9, user10,
			user11, user12, user13, user14, user15);
	// add some friends for all users
	setFriend(user1, user2, user3, user4, user6, user7, user8, user9, user10, user11, user12);
	setFriend(user2, user3, user4, user5, user6, user7, user8, user9, user10, user12);
	setFriend(user3, user5);
	saveUsers(user1, user2, user3, user4, user5, user6, user7, user8, user9, user10, user11,
			user12, user13, user14, user15);

	// create admin for university
	final Admin admin1 = new Admin(""admin1"", ""password"");
	final Admin admin2 = new Admin(""admin2"", ""password"");
	final Admin admin3 = new Admin(""admin3"", ""password"");
	final Admin admin4 = new Admin(""admin4"", ""password"");
	final Admin admin5 = new Admin(""admin5"", ""password"");
	final Admin admin6 = new Admin(""admin6"", ""password"");
	final Admin admin7 = new Admin(""admin7"", ""password"");
	final Admin admin8 = new Admin(""admin8"", ""password"");
	final Admin admin9 = new Admin(""admin9"", ""password"");
	final Admin admin10 = new Admin(""admin10"", ""password"");
	final Admin admin11 = new Admin(""admin11"", ""password"");
	final Admin admin12 = new Admin(""admin12"", ""password"");
	final Admin admin13 = new Admin(""admin13"", ""password"");

	saveUsers(admin1, admin2, admin3, admin4, admin5, admin6, admin7, admin8, admin9, admin10,
			admin11, admin12, admin13);
	createProfiles(admin1, admin2, admin3, admin4, admin5, admin6, admin7, admin8, admin9,
			admin10, admin11, admin12, admin13);

	// create universities
	final University university1 = new University(""University1"", admin1);
	final University university2 = new University(""University2"", admin2);
	final University university3 = new University(""University3"", admin2);
	final University university4 = new University(""University4"", admin2);
	final University university5 = new University(""University5"", admin2);
	final University university6 = new University(""University6"", admin2);
	final University university7 = new University(""University7"", admin2);
	final University university8 = new University(""University8"", admin2);
	final University university9 = new University(""University9"", admin2);
	final University university10 = new University(""University10"", admin2);
	final University university11 = new University(""University11"", admin2);
	final University university12 = new University(""University12"", admin2);
	final University university13 = new University(""University13"", admin2);
	final University university14 = new University(""University14"", admin2);
	final University university15 = new University(""University15"", admin2);

	setDefaultImage(university1, university2, university3, university4, university5,
			university6, university7, university8, university9, university10, university11,
			university12, university13, university14, university15);
	saveUniversities(university1, university2, university3, university4, university5,
			university6, university7, university8, university9, university10, university11,
			university12, university13, university14, university15);

	// staffs
	final Staff staff1 = new Staff(""staff1"", ""password"", university1);
	final Staff staff2 = new Staff(""staff2"", ""password"", university2);
	final Staff staff3 = new Staff(""staff3"", ""password"", university2);
	final Staff staff4 = new Staff(""staff4"", ""password"", university2);
	final Staff staff5 = new Staff(""staff5"", ""password"", university2);
	final Staff staff6 = new Staff(""staff6"", ""password"", university2);
	final Staff staff7 = new Staff(""staff7"", ""password"", university2);
	final Staff staff8 = new Staff(""staff8"", ""password"", university2);
	final Staff staff9 = new Staff(""staff9"", ""password"", university2);
	final Staff staff10 = new Staff(""staff10"", ""password"", university2);
	final Staff staff11 = new Staff(""staff11"", ""password"");
	final Staff staff12 = new Staff(""staff12"", ""password"", university3);
	final Staff staff13 = new Staff(""staff13"", ""password"", university3);
	final Staff staff14 = new Staff(""staff14"", ""password"", university3);
	final Staff staff15 = new Staff(""staff15"", ""password"", university4);
	final Staff staff16 = new Staff(""staff16"", ""password"", university4);
	final Staff staff17 = new Staff(""staff17"", ""password"", university4);
	final Staff staff18 = new Staff(""staff18"", ""password"", university6);
	final Staff staff19 = new Staff(""staff19"", ""password"", university6);
	final Staff staff20 = new Staff(""staff20"", ""password"", university7);
	final Staff staff21 = new Staff(""staff21"", ""password"", university8);
	final Staff staff22 = new Staff(""staff22"", ""password"", university9);
	final Staff staff23 = new Staff(""staff23"", ""password"", university10);
	final Staff staff24 = new Staff(""staff24"", ""password"", university2);
	final Staff staff25 = new Staff(""staff25"", ""password"", university2);
	final Staff staff26 = new Staff(""staff26"", ""password"", university2);
	final Staff staff27 = new Staff(""staff27"", ""password"", university2);
	final Staff staff28 = new Staff(""staff28"", ""password"", university2);
	final Staff staff29 = new Staff(""staff29"", ""password"", university2);
	final Staff staff30 = new Staff(""staff30"", ""password"", university2);
	final Staff staff31 = new Staff(""staff32"", ""password"", university2);


	saveUsers(staff1, staff2, staff3, staff4, staff5, staff6, staff7, staff8, staff9, staff10,
			staff11, staff12, staff13, staff14, staff15, staff16, staff17, staff18, staff19,
			staff20, staff21, staff22, staff23, staff24, staff25, staff26, staff27, staff28,
			staff29, staff30, staff31);
	saveUniversities(university1, university2, university3, university4, university5,
			university6, university7, university8, university9, university10, university11,
			university12, university13, university14, university15);
	createProfiles(staff1, staff2, staff3, staff4, staff5, staff6, staff7, staff8, staff9,
			staff10, staff11, staff12, staff13, staff14, staff15, staff16, staff17, staff18,
			staff19, staff20, staff21, staff22, staff23, staff24, staff25, staff26, staff27,
			staff28, staff29, staff30, staff31);


	// courses
	final Course course1 = new Course(""course1"", staff1);
	final Course course2 = new Course(""course2"", staff2);
	final Course course3 = new Course(""course3"", staff3);
	final Course course4 = new Course(""course4"", staff1);
	final Course course5 = new Course(""course5"", staff1);
	final Course course6 = new Course(""course6"", staff1);
	final Course course7 = new Course(""course7"", staff4);
	final Course course8 = new Course(""course8"", staff5);
	final Course course9 = new Course(""course9"", staff6);
	final Course course10 = new Course(""course10"", staff7);
	final Course course11 = new Course(""course11"", staff8);
	final Course course12 = new Course(""course12"", staff4);
	final Course course13 = new Course(""course13"", staff23);
	final Course course14 = new Course(""course14"", staff12);
	final Course course15 = new Course(""course15"", staff3);
	final Course course16 = new Course(""course16"", staff3);
	final Course course17 = new Course(""course17"", staff3);
	final Course course18 = new Course(""course18"", staff3);
	final Course course19 = new Course(""course19"", staff3);
	final Course course20 = new Course(""course20"", staff3);
	final Course course21 = new Course(""course21"", staff3);
	final Course course22 = new Course(""course22"", staff17);
	final Course course23 = new Course(""course23"", staff7);
	final Course course24 = new Course(""course24"", staff7);
	final Course course25 = new Course(""course25"", staff7);
	final Course course26 = new Course(""course26"", staff7);
	final Course course27 = new Course(""course27"", staff7);
	final Course course28 = new Course(""course28"", staff7);
	final Course course29 = new Course(""course29"", staff1);
	final Course course30 = new Course(""course30"", staff1);
	final Course course31 = new Course(""course31"", staff1);
	final Course course32 = new Course(""course32"", staff1);
	final Course course33 = new Course(""course33"", staff1);
	final Course course34 = new Course(""course34"", staff1);
	final Course course35 = new Course(""course35"", staff1);
	final Course course36 = new Course(""course36"", staff1);
	final Course course37 = new Course(""course37"", staff1);
	final Course course38 = new Course(""course38"", staff1);
	final Course course39 = new Course(""course39"", staff1);
	setDefaultImage(course1, course2, course3, course4, course5, course6, course7, course8,
			course9, course10, course11, course12, course13, course14, course15, course16,
			course17, course16, course17, course18, course19, course20, course21, course22,
			course23, course24, course25, course26, course27, course28, course29, course30,
			course31, course32, course33, course34, course35, course36, course37, course38,
			course39);
	saveCourses(course1, course2, course3, course4, course5, course6, course7, course8,
			course9, course10, course11, course12, course13, course14, course15, course16,
			course17, course16, course17, course18, course19, course20, course21, course22,
			course23, course24, course25, course26, course27, course28, course29, course30,
			course31, course32, course33, course34, course35, course36, course37, course38,
			course39);
	saveUniversities(university1, university2, university3, university4, university5,
			university6, university7, university8, university9, university10, university11,
			university12, university13, university14, university15);


	joinCourse(user1, course1, course10, course3, course4, course5, course6, course7, course8,
			course9, course10);
	joinCourse(user2, course1, course10, course3, course4, course5, course6, course7, course8,
			course9, course10);
	joinCourse(user3, course1, course10, course3, course4, course5, course6, course7, course8,
			course9, course10);
	joinCourse(user4, course1, course10, course3, course21, course5, course6, course7, course8,
			course9, course10);
	joinCourse(user5, course1, course12, course3, course22, course5, course6, course7, course8,
			course9, course10);
	joinCourse(user6, course1, course16, course3, course4, course5, course6, course7, course8,
			course9, course10);
	joinCourse(user7, course1, course17, course3, course23, course5, course6, course7, course8,
			course9, course10);
	joinCourse(user8, course1, course19, course3, course22, course5, course6, course7, course8,
			course9, course10);
	joinCourse(user9, course1, course20, course3, course11, course5, course6, course7, course8,
			course9, course10);
	joinCourse(user10, course1, course10, course3, course4, course5, course6, course7, course8,
			course9, course10);
	joinCourse(user11, course1, course10, course3, course4, course5, course6, course7, course8,
			course9, course10);


	// Questions
	final Question question1 = new Question(""sample Question1"", course1, user1);
	question1.setText(""<b>This is a sample Question1</b><em>this is em</em><p>new paragraph"");
	final Question question2 = new Question(""sample Question2"", course1, user1);
	question2.setText(""This is a sample Question2"");
	saveQuestion(question1, question2);

	final QuestionInfoMsg questioninfoMsg1 = new QuestionInfoMsg();
	questioninfoMsg1.setQuestion(question1);
	questioninfoMsg1.setUsers(new HashSet<User>(course1.getStudents()));
	questioninfoMsg1.setTime(new Date());
	final QuestionInfoMsg questioninfoMsg2 = new QuestionInfoMsg();
	questioninfoMsg2.setQuestion(question2);
	questioninfoMsg2.setUsers(new HashSet<User>(course1.getStudents()));
	questioninfoMsg2.setTime(new Date());
	saveMessage(questioninfoMsg1, questioninfoMsg2);


	// Answers
	final Answer answer1 = new Answer(question1, user2);
	answer1.setText(""this is a sample answer1"");
	final Answer answer2 = new Answer(question1, user3);
	answer2.setText(""this is a sample answer2"");
	saveAnswers(answer1, answer2);


	// messages
	final InfoMsg infoMsg1 = new InfoMsg();
	infoMsg1.setMessage(""This is a info message"");
	infoMsg1.setSender(user1);
	// multicast
	infoMsg1.addUser(user2);
	infoMsg1.addUser(user3);
	infoMsg1.addUser(user4);
	infoMsg1.addUser(user5);
	infoMsg1.setTime(new Date());

	final InfoMsg infoMsg2 = new InfoMsg();
	infoMsg2.setMessage(""Hi to all friends"");
	infoMsg2.setSender(user1);
	// if you take the set from the user and assign it to the message
	// hibernate removes the set from the user(???).So create a new Set
	infoMsg2.setUsers(new HashSet<User>(user1.getFriends()));
	infoMsg2.setTime(new Date());

	final InfoMsg infoMsg3 = new InfoMsg();
	infoMsg3.setMessage("" user1"");
	infoMsg3.setSender(user2);
	infoMsg3.addUser(user1);
	infoMsg3.setTime(new Date());

	// friend reques message
	final FriendRequestMsg frnRqMsg = new FriendRequestMsg();
	frnRqMsg.setSender(user5);
	frnRqMsg.addUser(user1);
	frnRqMsg.setMessage(""Hai User1"");
	frnRqMsg.setTime(new Date());

	saveMessage(infoMsg1, infoMsg2, infoMsg3, frnRqMsg);


}","/**
 * run this method to load some data for the site
 */
@Test
@NotTransactional
public void load() 
{
    // load some data for the site
    // create a user
    User user = new User();
    user.setName(""John Doe"");
    user.setEmail(""john@example.com"");
    user.setPassword(""password"");
    userService.save(user);

    // create a post
    Post post = new Post();
    post.setTitle(""My First Post"");
    post.setContent(""This is my first blog post."");
    post.setUser(user);
    postService.save(post);

    // create a comment
    Comment comment = new Comment();
    comment.setContent(""Great post!"");
    comment.setUser(user);
    comment.setPost(post);
    commentService.save(comment);
}   ",866,True
"/**
 * creates a detachable Domain object
 * 
 * @param domain
 *            detachable Domain object
 * @param dao
 *            Dao to acces the Domain object
 */
public EntityModel(final T domain, final AbstractDao<T> dao){
	super(domain);
	this.dao = dao;
}","/**
 * creates a detachable Domain object
 * 
 * @param domain
 *            detachable Domain object
 * @param dao
 *            Dao to acces the Domain object
 */
public EntityModel(final T domain, final AbstractDao<T> dao) 
{
    this.domain = domain;
    this.dao = dao;
}   ",868,True
"/**
 * returns the Domain if available or fetch it from the database
 * 
 * @return Domain
 */
@Override
protected T load(){
	if (domain == null)
	{
		domain = dao.load(id);
	}
	return domain;
}","/**
 * returns the Domain if available or fetch it from the database
 * 
 * @return Domain
 */
@Override
protected T load() 
{
    if (this.domain == null)
    {
        this.domain = this.getDomain();
    }

    return this.domain;
}   ",870,True
"/**
 * @see com.socialsite.dao.MessageDao#getMessage(User, int, int)
 */
@SuppressWarnings(""unchecked"")
public List<T> getMessage(final User user, final int first, final int count){
	final Query query = getSession().createQuery(
			"" select m from Message m , User u ""
					+ "" where u = :user and u member of m.users order by m.time desc"");
	query.setParameter(""user"", user);
	query.setFirstResult(first);
	query.setMaxResults(count);
	return query.list();
}","/**
 * @see com.socialsite.dao.MessageDao#getMessage(User, int, int)
 */






@SuppressWarnings(""unchecked"")
public List<T> getMessage(final User user, final int first, final int count) 
{
    return (List<T>) getHibernateTemplate().execute(new HibernateCallback()
    {
        public Object doInHibernate(Session session) throws HibernateException
        {
            Query query = session.createQuery(""from "" + persistentClass.getName() + "" as model where model.user = :user order by model.id desc"");
            query.setParameter(""user"", user);
            query.setFirstResult(first);
            query.setMaxResults(count);
            return query.list();
        }
    });
}   ",873,False
"/*
 * (non-Javadoc)
 * 
 * @see
 * com.socialsite.dao.hibernate.AbstractImageDaoImpl#getLastModifiedTime
 * (long)
 */
@Override
public Date getLastModifiedTime(final long id){
	final Criteria criteria = getSession().createCriteria(User.class);
	criteria.add(Restrictions.idEq(id));
	criteria.setProjection(Projections.property(""lastModified""));
	return (Date)criteria.uniqueResult();
}","/*
 * (non-Javadoc)
 * 
 * @see
 * com.socialsite.dao.hibernate.AbstractImageDaoImpl#getLastModifiedTime
 * (long)
 */
@Override
public Date getLastModifiedTime(final long id) 
{
    final Criteria criteria = this.getSession().createCriteria(Image.class);
    criteria.add(Restrictions.eq(""id"", id));
    criteria.setProjection(Projections.property(""lastModified""));
    return (Date)criteria.uniqueResult();
}   ",874,True
"/*
 * (non-Javadoc)
 * 
 * @see com.socialsite.image.AbstractImageResource#getImageDao()
 */
@Override
public AbstractImageDao<Course> getImageDao(){
	if (courseDao == null)
	{
		// inject the spring dao
		InjectorHolder.getInjector().inject(this);
	}
	return courseDao;
}","/*
 * (non-Javadoc)
 * 
 * @see com.socialsite.image.AbstractImageResource#getImageDao()
 */
@Override
public AbstractImageDao<Course> getImageDao() 
{
    return courseImageDao;
}   ",876,True
"/**
 * I cann't send email through smtp. So here i am sending mail through a
 * proxy server. To send email through smtp server change this
 * implementation
 * 
 * @param email
 */
public void send(final Email email){
	// TODO this should run asynchronously
	// handle multiple receivers
	addParam(""receiver"", email.getReceivers().get(0));
	// someone is going to send email using this thing
	addParam(""secret"", ""dontMESSwithme"");
	addParam(""msg"", email.getMessage());
	addParam(""subject"", email.getSubject());


	try
	{

		final URL url = new URL(ACTIVATE_URL + emailURL.toString());
		final BufferedReader reader = new BufferedReader(
				new InputStreamReader(url.openStream()));
		String line;
		final StringBuffer reply = new StringBuffer();
		while ((line = reader.readLine()) != null)
		{
			reply.append(line);
		}
		reader.close();

		if (!reply.toString().equals(""message send successfully""))
		{
			// message sending failed
			logger.severe(""Could not send Email"");
			logger.severe(reply.toString());
			logger.severe(""URL"" + ACTIVATE_URL + emailURL.toString());
		}
		else
		{
			logger.info(""email send successfully"");
		}

	}
	catch (final MalformedURLException e)
	{
		logger.log(Level.SEVERE, """", e);
	}
	catch (final IOException e)
	{
		logger.log(Level.SEVERE, """", e);
	}
}","/**
 * I cann't send email through smtp. So here i am sending mail through a
 * proxy server. To send email through smtp server change this
 * implementation
 * 
 * @param email
 */


public void send(final Email email) 
{
    try
    {
        MimeMessage message = new MimeMessage(session);
        message.setFrom(new InternetAddress(email.getFrom()));
        message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(email.getTo()));
        message.setSubject(email.getSubject());
        message.setText(email.getMessage());

        Transport.send(message);
    }
    catch (MessagingException e)
    {
        e.printStackTrace();
    }
}   ",877,False
"/**
 * changes the thumb
 * 
 * @param thumb
 *            thumb data in byte[]
 */
public void changeThumb(final byte[] thumb){
	this.thumb = thumb;
	setLastModified(new Date());
}","/**
 * changes the thumb
 * 
 * @param thumb
 *            thumb data in byte[]
 */
public void changeThumb(final byte[] thumb) 
{
    if (thumb != null)
    {
        this.thumb = thumb;
    }
    else
    {
        this.thumb = null;
    }
}   ",879,False
"/**
 * Copies an array.
 */
public static final void arraycopy(String[] from, int from_idx, int[] to, int to_idx, int length){
	while (length-- > 0)		
		to[to_idx++] = Integer.parseInt(from[from_idx++].trim());
}","/**
 * Copies an array.
 */
public static final void arraycopy(String[] from, int from_idx, int[] to, int to_idx, int length) 
{
    for (int i = 0; i < length; i++)
    {
        to[to_idx + i] = Integer.parseInt(from[from_idx + i]);
    }
}   ",882,True
"/**	Inserts the specified element at the specified position in this array. 
 * 
 * @param index the index in the array. If index is larger than the current size,
 *	the array grows automatically.
 * @param element the element to be inserted
 * @exception IndexOutOfBoundsException if index < 0
 */
public void add(int index, int element){
	if (index<0)
		throw new IndexOutOfBoundsException();
	
	if (index>=fSize) {
		ensureCapacity(index+1);
		fSize = index+1;
	}
	else {
		ensureCapacity(fSize+1);
		System.arraycopy(fArray,index, fArray,index+1, fSize-index);
		fSize++;
	}
	fArray[index] = element;
}","/**	Inserts the specified element at the specified position in this array. 
 * 
 * @param index the index in the array. If index is larger than the current size,
 *	the array grows automatically.
 * @param element the element to be inserted
 * @exception IndexOutOfBoundsException if index < 0
 */
public void add(int index, int element) 
{
	if (index < 0)
		throw new IndexOutOfBoundsException();
	if (index >= size)
	{
		ensureCapacityHelper(index + 1);
		size = index + 1;
	}
	int numMoved = size - index;
	if (numMoved > 0)
		System.arraycopy(elementData, index, elementData, index + 1, numMoved);
	elementData[index] = element;
}   ",883,False
"/**	Returns the element at the specified position in this array (startin at 0).
 * 
 * @param index the index in the array
 * @exception IndexOutOfBoundsException if index < 0 or index >= size()
 */
public int get(int index){
	if (index < 0 || index >= fSize)
		throw new IndexOutOfBoundsException(""index: "" + index + "" - size: "" + fSize);
	return fArray[index];
}","/**	Returns the element at the specified position in this array (startin at 0).
 * 
 * @param index the index in the array
 * @exception IndexOutOfBoundsException if index < 0 or index >= size()
 */
public int get(int index) 
{
	if (index < 0 || index >= size())
	{
		throw new IndexOutOfBoundsException();
	}
	return array[index];
}   ",884,True
"/** Removes the element at the specified position in this list. 
 * 
 * @param index the position in the list
 */
public int remove(int index){
	int result = get(index);
	removeRange(index,index+1);
	return result;
}","/** Removes the element at the specified position in this list. 
 * 
 * @param index the position in the list
 */
public int remove(int index) 
{
    if (index < 0 || index >= size)
    {
        throw new IndexOutOfBoundsException(""Index: "" + index + "", Size: "" + size);
    }

    int removedElement = elements[index];
    System.arraycopy(elements, index + 1, elements, index, size - index - 1);
    size--;

    return removedElement;
}   ",885,False
"/**	Returns an int[] array containing all of the elements in this list in the
 * correct order.
 */
public int[] toArray(){
	int[] copy = new int[fSize];
	System.arraycopy(fArray,0, copy,0,fSize);
	return copy;
}","/**	Returns an int[] array containing all of the elements in this list in the
 * correct order.
 */
public int[] toArray() 
{
	int[] result = new int[size];
	Node current = head;
	for (int i = 0; i < size; i++)
	{
		result[i] = current.data;
		current = current.next;
	}
	return result;
}   ",886,True
"/**	Returns a copy of this IntArray instance. 
 */
public Object clone(){
	IntArray clone = new IntArray(fArray.length);
	clone.addAll(0, fArray,0,fSize);
	return clone;
}","/**	Returns a copy of this IntArray instance. 
 */
public Object clone() 
{
	IntArray copy = new IntArray(this.length);
	System.arraycopy(this.array, 0, copy.array, 0, this.length);
	return copy;
}   ",887,True
"/**	Returns a String representation of this array. Elements are separated by commas
 * and enclosed in parenthesis. An empty array returns ""()"".
 * <p>
 * Example: ""(1,2,3,4)""
 */
public String toString(){
	StringBuffer buf = new StringBuffer(""("");
	buf.append(arrayToString(fArray,0,fSize,"",""));
	buf.append("")"");
	return buf.toString();
}","/**	Returns a String representation of this array. Elements are separated by commas
 * and enclosed in parenthesis. An empty array returns ""()"".
 * <p>
 * Example: ""(1,2,3,4)""
 */
public String toString() 
{
	String result = ""("";
	for (int i = 0; i < size; i++)
	{
		if (i > 0)
			result += "", "";
		result += data[i];
	}
	result += "")"";
	return result;
}   ",890,True
"/**	Searches for the first occurence of the given argument. 
 * 
 * @param elem the element to look for
 */
public int indexOf(int elem){
	for (int i=0; i<fSize; i++)
		if (fArray[i]==elem)
			return i;
	return -1;
}","/**	Searches for the first occurence of the given argument. 
 * 
 * @param elem the element to look for
 */
public int indexOf(int elem) 
{
	int index = -1;
	for(int i = 0; i < size; i++)
	{
		if(array[i] == elem)
		{
			index = i;
			break;
		}
	}
	return index;
}   ",892,True
"/**	Returns a String representation of this array. Elements are separated by commas
 * and enclosed in parenthesis. An empty array returns ""null"".
 * <p>
 * Example: ""(1,2,3,4)""
 */
public static String toString(IntArray array){
	if (array==null || array.isEmpty())
		return null;
	else
		return array.toString();
}","/**	Returns a String representation of this array. Elements are separated by commas
 * and enclosed in parenthesis. An empty array returns ""null"".
 * <p>
 * Example: ""(1,2,3,4)""
 */
public static String toString(IntArray array) 
{
    if (array == null)
        return ""null"";

    StringBuilder sb = new StringBuilder();
    sb.append(""("");

    for (int i = 0; i < array.size(); i++)
    {
        sb.append(array.get(i));
        if (i < array.size() - 1)
            sb.append("", "");
    }

    sb.append("")"");
    return sb.toString();
}   ",893,True
"/**	Inserts a subset of the elements in the specified array into this array, 
 * starting at the specified position. 
 * 
 * @param index the index in this array where the new elements will be inserted
 * @param elems the new elements
 * @param start the start index in elements
 * @param length the number of elements to be added
 * 
 * @exception IndexOutOfBoundsException if index < 0, or start+length > elements.length
 */
public void addAll(int index, int[] elems, int start, int length){
	if (elems==null)
		return;
	
	if (index<0)
		throw new IndexOutOfBoundsException();
	
	if (index>=fSize) {
		ensureCapacity(index+length);
		fSize = index+length;
	}
	else {
		ensureCapacity(fSize + length);
		System.arraycopy(fArray,index, fArray,index+length, fSize-index);
		fSize += length;
	}
	System.arraycopy(elems,0, fArray,start,length);
}","/**	Inserts a subset of the elements in the specified array into this array, 
 * starting at the specified position. 
 * 
 * @param index the index in this array where the new elements will be inserted
 * @param elems the new elements
 * @param start the start index in elements
 * @param length the number of elements to be added
 * 
 * @exception IndexOutOfBoundsException if index < 0, or start+length > elements.length
 */
public void addAll(int index, int[] elems, int start, int length) 
{
	if (index < 0 || start+length > elems.length)
		throw new IndexOutOfBoundsException();
	if (length == 0)
		return;
	ensureCapacity(size+length);
	System.arraycopy(array, index, array, index+length, size-index);
	System.arraycopy(elems, start, array, index, length);
	size += length;
}   ",895,True
"// -------- Methods ---------------------------------------------------------
public static BookEntry merge(BookEntry entry1, BookEntry entry2){
	BookEntry merged_entry = new BookEntry();
	merged_entry.move = entry1.move;
	merged_entry.add(entry1);
	merged_entry.add(entry2);
	return merged_entry;
}","// -------- Methods ---------------------------------------------------------
public static BookEntry merge(BookEntry entry1, BookEntry entry2) 
{
    BookEntry mergedEntry = new BookEntry(entry1.getName(), 0, 0);
    mergedEntry.addLocations(entry1.getLocations());
    mergedEntry.addLocations(entry2.getLocations());
    return mergedEntry;
}   ",896,False
"/** sets the capacity of the array
 */
protected void allocate(int newCapacity){
	if (newCapacity == fArray.length) return;

	int[] copy = new int[newCapacity];
	System.arraycopy(fArray,0, copy,0, fSize);
	fArray = copy;
}","/** sets the capacity of the array
 */
protected void allocate(int newCapacity) 
{
    Object[] newArray = new Object[newCapacity];
    System.arraycopy(array, 0, newArray, 0, Math.min(array.length, newCapacity));
    array = newArray;
}   ",898,True
"/**
 * Deletes all {@link Node}s that do not have at least one
 * {@link Relationship} from the Neo4j instance.
 * 
 * @param transNeo
 *            {@link GraphDatabaseService} representing a Neo4j instance
 */
public static void removeOrphanNodes(GraphDatabaseService transNeo){

	long time = System.currentTimeMillis();
	System.out.printf(""Deleting orphan nodes..."");

	long deletedNodes = 0;

	Transaction tx = transNeo.beginTx();

	try {
		for (Node node : transNeo.getAllNodes()) {

			if (node.hasRelationship() == true)
				continue;

			node.delete();

			if (++deletedNodes % Consts.STORE_BUF == 0) {
				tx.success();
				tx.finish();
				tx = transNeo.beginTx();
			}

		}

		tx.success();
	} catch (Exception e) {
		e.printStackTrace();
	} finally {
		tx.finish();
	}

	// PRINTOUT
	System.out.printf(""Deleted [%d]...%s"", deletedNodes, getTimeStr(System
			.currentTimeMillis()
			- time));

}","/**
 * Deletes all {@link Node}s that do not have at least one
 * {@link Relationship} from the Neo4j instance.
 * 
 * @param transNeo
 *            {@link GraphDatabaseService} representing a Neo4j instance
 */

public static void removeOrphanNodes(GraphDatabaseService transNeo) 
{
    try (Transaction tx = transNeo.beginTx())
    {
        ResourceIterator<Node> allNodes = transNeo.getAllNodes().iterator();
        while (allNodes.hasNext())
        {
            Node node = allNodes.next();
            if (!node.hasRelationship())
            {
                node.delete();
            }
        }
        tx.success();
    }
}   ",902,True
"/**
 * Creates a Neo4j instance and populates it from the contents of a GML
 * (.gml) file. GML files are basically an ASCII version of the GraphML
 * format.
 * 
 * @param transNeo
 *            {@link GraphDatabaseService} representing a Neo4j instance
 * @param gmlPath
 *            {@link String} representing path to .gml file
 */
public static void writeNeoFromGML(GraphDatabaseService transNeo,
		String gmlPath){

	try {
		GraphReader parser = new GMLParserDirected(new File(gmlPath));
		Partitioner partitioner = new PartitionerAsSingle((byte) -1);
		GraphDatabaseServicesWriter dbWrapper = GraphDatabaseServicesWriter
				.createTransactionalWrapper(transNeo);
		storePartitionedNodesAndRelsToNeo(dbWrapper, parser, partitioner);
		dbWrapper.shutdownIndex();
	} catch (Exception e) {
		e.printStackTrace();
	}

}","/**
 * Creates a Neo4j instance and populates it from the contents of a GML
 * (.gml) file. GML files are basically an ASCII version of the GraphML
 * format.
 * 
 * @param transNeo
 *            {@link GraphDatabaseService} representing a Neo4j instance
 * @param gmlPath
 *            {@link String} representing path to .gml file
 */
public static void writeNeoFromGML(GraphDatabaseService transNeo,
		String gmlPath) 
{
	// Create a new transaction
	try (Transaction tx = transNeo.beginTx())
	{
		// Create a new GMLReader instance
		GMLReader gmlReader = new GMLReader(transNeo);

		// Read the GML file
		gmlReader.read(gmlPath);

		// Commit the transaction
		tx.success();
	}
}	",904,True
"/**
 * Deletes duplicate {@link Relationship}s (all but one {@link Relationship}
 * between any two {@link Node}s). Useful for reducing the size of a Neo4j
 * instance while maintaining the same basic connectivity/structure.
 * {@link Direction} is considered when identifying duplicates.
 * {@link RelationshipType} is NOT considered (they are all regarded as
 * equal).
 * 
 * @param transNeo
 *            {@link GraphDatabaseService} representing a Neo4j instance
 * @param direction
 *            {@link Direction} which defines what a duplicate is. If
 *            direction equals {@link Direction#OUTGOING} then all but one
 *            outgoing {@link Relationship}s between any two {@link Node}s
 *            are kept. In this case two {@link Relationship}s may exist
 *            between a pair of {@link Node}s. If direction equals
 *            {@link Direction#BOTH} then all but one {@link Relationship}
 *            of any direction between any two {@link Node} s is kept.
 */
public static void removeDuplicateRelationships(
		GraphDatabaseService transNeo, Direction direction){

	long time = System.currentTimeMillis();
	System.out.printf(""Deleting duplicate relationships..."");

	int deletedRels = 0;

	Transaction tx = transNeo.beginTx();

	try {
		for (Node node : transNeo.getAllNodes()) {

			HashSet<Long> neighbourIds = new HashSet<Long>();

			for (Relationship relationship : node
					.getRelationships(direction)) {

				Node neighbour = relationship.getOtherNode(node);

				// Neighbour has not been seen previously
				if (neighbourIds.add(neighbour.getId()) == true)
					continue;

				relationship.delete();

				if (++deletedRels % Consts.STORE_BUF == 0) {
					tx.success();
					tx.finish();
					tx = transNeo.beginTx();
				}

			}

		}

		tx.success();
	} catch (Exception e) {
		e.printStackTrace();
	} finally {
		tx.finish();
	}

	// PRINTOUT
	System.out.printf(""Deleted [%d]...%s"", deletedRels, getTimeStr(System
			.currentTimeMillis()
			- time));

}","/**
 * Deletes duplicate {@link Relationship}s (all but one {@link Relationship}
 * between any two {@link Node}s). Useful for reducing the size of a Neo4j
 * instance while maintaining the same basic connectivity/structure.
 * {@link Direction} is considered when identifying duplicates.
 * {@link RelationshipType} is NOT considered (they are all regarded as
 * equal).
 * 
 * @param transNeo
 *            {@link GraphDatabaseService} representing a Neo4j instance
 * @param direction
 *            {@link Direction} which defines what a duplicate is. If
 *            direction equals {@link Direction#OUTGOING} then all but one
 *            outgoing {@link Relationship}s between any two {@link Node}s
 *            are kept. In this case two {@link Relationship}s may exist
 *            between a pair of {@link Node}s. If direction equals
 *            {@link Direction#BOTH} then all but one {@link Relationship}
 *            of any direction between any two {@link Node} s is kept.
 */


public static void removeDuplicateRelationships(
		GraphDatabaseService transNeo, Direction direction) 
{
	Transaction tx = transNeo.beginTx();
	try
	{
		ResourceIterable<Node> nodes = transNeo.getAllNodes();
		for (Node node : nodes)
		{
			Iterable<Relationship> rels = node.getRelationships();
			for (Relationship rel : rels)
			{
				Node otherNode = rel.getOtherNode(node);
				Iterable<Relationship> otherRels = otherNode.getRelationships(
						rel.getType(), direction);
				for (Relationship otherRel : otherRels)
				{
					if (otherRel != rel)
					{
						otherRel.delete();
					}
				}
			}
		}
		tx.success();
	}
	finally
	{
		tx.finish();
	}
}	",908,True
"/**
 * Creates a Neo4j instance and populates it from the contents of a dataset
 * with a proprietry binary file format, which contains user
 * follows/following connectivity data from Twitter. The file was obtained
 * by crawling Twitter for 300 hours. Allocates {@link Node}s to
 * partitions/clusters. Allocation scheme is defined by the
 * {@link Partitioner} parameter.
 * 
 * @param transNeo
 *            {@link GraphDatabaseService} representing a Neo4j instance
 * @param twitterPath
 *            {@link String} representing path to Twitter dataset
 * @param partitioner
 *            implementation of {@link Partitioner} that defines
 *            cluster/partition allocation scheme
 */
public static void writeNeoFromTwitterDatasetAndPtn(
		GraphDatabaseService transNeo, String twitterPath,
		Partitioner partitioner){

	try {
		GraphReader parser = new TwitterParser(new File(twitterPath));
		GraphDatabaseServicesWriter dbWrapper = GraphDatabaseServicesWriter
				.createTransactionalWrapper(transNeo);
		storePartitionedNodesAndRelsToNeo(dbWrapper, parser, partitioner);
		dbWrapper.shutdownIndex();
	} catch (Exception e) {
		e.printStackTrace();
	}

}","/**
 * Creates a Neo4j instance and populates it from the contents of a dataset
 * with a proprietry binary file format, which contains user
 * follows/following connectivity data from Twitter. The file was obtained
 * by crawling Twitter for 300 hours. Allocates {@link Node}s to
 * partitions/clusters. Allocation scheme is defined by the
 * {@link Partitioner} parameter.
 * 
 * @param transNeo
 *            {@link GraphDatabaseService} representing a Neo4j instance
 * @param twitterPath
 *            {@link String} representing path to Twitter dataset
 * @param partitioner
 *            implementation of {@link Partitioner} that defines
 *            cluster/partition allocation scheme
 */


public static void writeNeoFromTwitterDatasetAndPtn(
		GraphDatabaseService transNeo, String twitterPath,
		Partitioner partitioner) 
{
	// Create a new transaction for the Neo4j instance
	try (Transaction tx = transNeo.beginTx())
	{
		// Get the reference to the database service
		Database db = transNeo.getDb();

		// Create a new node for the root user
		Node root = db.createNode();
		root.setProperty(""name"", ""root"");

		// Create a new node for the user
		Node user = db.createNode();
		user.setProperty(""name"", ""user"");

		// Create a new relationship between the root and user
		Relationship follows = root.createRelationshipTo(user, RelTypes.FOLLOWS);
		follows.setProperty(""name"", ""follows"");

		// Get the path to the Twitter dataset
		Path path = Paths.get(twitterPath);

		// Iterate over the files in the dataset
		for (Path file : Files.newDirectoryStream(path))
		{
			// Read the contents of the file
			byte[] bytes = Files.readAllBytes(file);

			// Create a new node for the follower
			Node follower = db.createNode();
			follower.setProperty(""name"", ""follower"");

			// Create a new relationship between the follower and user
			Relationship followsFollower = follower.createRelationshipTo(user, RelTypes.FOLLOWS);
			followsFollower.setProperty(""name"", ""follows"");

			// Allocate the follower to a partition
			int partition = partitioner.getPartition(follower.getId(), 2);
			follower.setProperty(""partition"", partition);

			// Process the binary file data
			processBinaryFileData(bytes, follower);
		}

		// Commit the transaction
		tx.success();
	}
}	",909,False
"/**
 * Creates a GML (.gml) file and populates it with the representation of the
 * current Neo4j instance. All {@link Node} and {@link Relationship}
 * properties are written to the GML file.
 * 
 * @param transNeo
 *            {@link GraphDatabaseService} representing a Neo4j instance
 * @param gmlPath
 *            {@link String} representing path to .gml file
 */
public static void writeGMLFull(GraphDatabaseService transNeo,
		String gmlPath){

	try {
		File gmlFile = new File(gmlPath);
		GraphWriter gmlWriterFull = new GMLWriterUndirectedFull(gmlFile);
		writeGraphToFile(transNeo, gmlWriterFull);
	} catch (Exception e) {
		e.printStackTrace();
	}

}","/**
 * Creates a GML (.gml) file and populates it with the representation of the
 * current Neo4j instance. All {@link Node} and {@link Relationship}
 * properties are written to the GML file.
 * 
 * @param transNeo
 *            {@link GraphDatabaseService} representing a Neo4j instance
 * @param gmlPath
 *            {@link String} representing path to .gml file
 */
public static void writeGMLFull(GraphDatabaseService transNeo,
		String gmlPath) 
{
	GmlWriter gmlWriter = new GmlWriter(transNeo, gmlPath);
	gmlWriter.writeGMLFull();
}	",910,True
"/**
 * Calculates graph metrics for the current Neo4j instance and appends the
 * results to a comma separated metrics (.met) file.
 * 
 * @param transNeo
 *            {@link GraphDatabaseService} representing a Neo4j instance
 * @param metricsPath
 *            {@link String} representing path to .met file
 * @param timeStep
 *            {@link Long} representing the time-step/iteration related to
 *            these metrics
 */
public static void appendMetricsCSV(GraphDatabaseService transNeo,
		String metricsPath, Long timeStep){

	try {
		// PRINTOUT
		long time = System.currentTimeMillis();
		System.out.printf(""Appending Metrics CSV File..."");

		File metricsFile = new File(metricsPath);
		MetricsWriterUndirected.appendMetricsCSV(transNeo, metricsFile,
				timeStep);

		// PRINTOUT
		System.out.printf(""%s"", getTimeStr(System.currentTimeMillis()
				- time));
	} catch (Exception e) {
		e.printStackTrace();
	}

}","/**
 * Calculates graph metrics for the current Neo4j instance and appends the
 * results to a comma separated metrics (.met) file.
 * 
 * @param transNeo
 *            {@link GraphDatabaseService} representing a Neo4j instance
 * @param metricsPath
 *            {@link String} representing path to .met file
 * @param timeStep
 *            {@link Long} representing the time-step/iteration related to
 *            these metrics
 */

public static void appendMetricsCSV(GraphDatabaseService transNeo,
		String metricsPath, Long timeStep) 
{
	// Get the current time in milliseconds
	long time = System.currentTimeMillis();

	// Open a FileWriter to append to the metrics file
	FileWriter fw;
	try
	{
		fw = new FileWriter(metricsPath, true);

		// Get the number of nodes and relationships in the graph
		long numNodes = getNumNodes(transNeo);
		long numRels = getNumRels(transNeo);

		// Write the metrics to the file
		fw.append(timeStep + "","" + time + "","" + numNodes + "","" + numRels + ""\n"");
		fw.flush();
		fw.close();
	}
	catch (IOException e)
	{
		e.printStackTrace();
	}
}	",912,True
"/**
 * Creates a Chaco (.graph) file and partition (.ptn) files, populates them
 * with the representation of the current Neo4j instance. Chaco files are
 * assumed to be undirected, this means edges are duplicated in each
 * direction.
 * 
 * @param transNeo
 *            {@link GraphDatabaseService} representing a Neo4j instance
 * @param chacoPath
 *            {@link String} representing path to .graph file
 * @param chacoType
 *            {@link ChacoType} specifies whether node and/or edge weights
 *            are written to the chaco file
 * @param ptnPath
 *            {@link String} representing path to .ptn file
 */
public static void writeChacoAndPtn(GraphDatabaseService transNeo,
		String chacoPath, ChacoType chacoType, String ptnPath){

	try {
		File chacoFile = new File(chacoPath);
		File ptnFile = new File(ptnPath);
		GraphWriter chacoPtnWriter = ChacoPtnWriterFactory
				.getChacoPtnWriter(chacoType, chacoFile, ptnFile);
		writeGraphToFile(transNeo, chacoPtnWriter);
	} catch (Exception e) {
		e.printStackTrace();
	}

}","/**
 * Creates a Chaco (.graph) file and partition (.ptn) files, populates them
 * with the representation of the current Neo4j instance. Chaco files are
 * assumed to be undirected, this means edges are duplicated in each
 * direction.
 * 
 * @param transNeo
 *            {@link GraphDatabaseService} representing a Neo4j instance
 * @param chacoPath
 *            {@link String} representing path to .graph file
 * @param chacoType
 *            {@link ChacoType} specifies whether node and/or edge weights
 *            are written to the chaco file
 * @param ptnPath
 *            {@link String} representing path to .ptn file
 */
public static void writeChacoAndPtn(GraphDatabaseService transNeo,
		String chacoPath, ChacoType chacoType, String ptnPath) 
{
	// Create a new ChacoWriter instance
	ChacoWriter chacoWriter = new ChacoWriter(transNeo, chacoPath, chacoType);

	// Write the Chaco file
	chacoWriter.writeChacoFile();

	// Create a new PtnWriter instance
	PtnWriter ptnWriter = new PtnWriter(transNeo, ptnPath);

	// Write the partition file
	ptnWriter.writePtnFile();
}	",913,True
"/**
 * Creates a Neo4j instance and populates it from the contents of a dataset
 * with a proprietry binary file format, which contains user
 * follows/following connectivity data from Twitter. The file was obtained
 * by crawling Twitter for 300 hours.
 * 
 * @param transNeo
 *            {@link GraphDatabaseService} representing a Neo4j instance
 * @param twitterPath
 *            {@link String} representing path to Twitter dataset
 */
public static void writeNeoFromTwitterDataset(
		GraphDatabaseService transNeo, String twitterPath){

	try {
		GraphReader parser = new TwitterParser(new File(twitterPath));
		Partitioner partitioner = new PartitionerAsSingle((byte) -1);
		GraphDatabaseServicesWriter dbWrapper = GraphDatabaseServicesWriter
				.createTransactionalWrapper(transNeo);
		storePartitionedNodesAndRelsToNeo(dbWrapper, parser, partitioner);
		dbWrapper.shutdownIndex();
	} catch (Exception e) {
		e.printStackTrace();
	}

}","/**
 * Creates a Neo4j instance and populates it from the contents of a dataset
 * with a proprietry binary file format, which contains user
 * follows/following connectivity data from Twitter. The file was obtained
 * by crawling Twitter for 300 hours.
 * 
 * @param transNeo
 *            {@link GraphDatabaseService} representing a Neo4j instance
 * @param twitterPath
 *            {@link String} representing path to Twitter dataset
 */




public static void writeNeoFromTwitterDataset(
		GraphDatabaseService transNeo, String twitterPath) 
{
	File twitterFile = new File(twitterPath);
	if (!twitterFile.exists())
	{
		System.err.println(""Twitter dataset file not found"");
		return;
	}

	try (Transaction tx = transNeo.beginTx())
	{
		try (BufferedReader br = new BufferedReader(new FileReader(twitterFile)))
		{
			String line;
			while ((line = br.readLine()) != null)
			{
				String[] parts = line.split("" "");
				if (parts.length == 2)
				{
					long from = Long.parseLong(parts[0]);
					long to = Long.parseLong(parts[1]);
					Node fromNode = transNeo.findNode(Labels.User, ""id"", from);
					Node toNode = transNeo.findNode(Labels.User, ""id"", to);
					if (fromNode != null && toNode != null)
					{
						fromNode.createRelationshipTo(toNode, RelTypes.FOLLOWS);
					}
				}
			}
		}
		tx.success();
	}
	catch (IOException e)
	{
		e.printStackTrace();
	}
}	",914,True
"/**
 * Creates a Neo4j instance, populates it from the contents of a Chaco
 * (.graph) file, then allocates {@link Node}s to partitions/clusters. Chaco
 * files are basically persistent adjacency lists. Partition/cluster
 * allocation is defined by the contents of a .ptn file. This method is only
 * included for convenience/ease of use.
 * {@link NeoFromFile#writeNeoFromChacoAndPtn(GraphDatabaseService, String, Partitioner)}
 * can achieve the same thing.
 * 
 * @param transNeo
 *            {@link GraphDatabaseService} representing a Neo4j instance
 * @param graphPath
 *            {@link String} representing path to .graph file
 * @param ptnPath
 *            {@link String} representing path to .ptn file
 */
public static void writeNeoFromChacoAndPtn(GraphDatabaseService transNeo,
		String graphPath, String ptnPath){

	try {
		GraphReader parser = ChacoParserFactory.getChacoParser(graphPath);
		Partitioner partitioner = new PartitionerAsFile(new File(ptnPath));
		GraphDatabaseServicesWriter dbWrapper = GraphDatabaseServicesWriter
				.createTransactionalWrapper(transNeo);
		storePartitionedNodesAndRelsToNeo(dbWrapper, parser, partitioner);
		dbWrapper.shutdownIndex();
	} catch (Exception e) {
		e.printStackTrace();
	}

}","/**
 * Creates a Neo4j instance, populates it from the contents of a Chaco
 * (.graph) file, then allocates {@link Node}s to partitions/clusters. Chaco
 * files are basically persistent adjacency lists. Partition/cluster
 * allocation is defined by the contents of a .ptn file. This method is only
 * included for convenience/ease of use.
 * {@link NeoFromFile#writeNeoFromChacoAndPtn(GraphDatabaseService, String, Partitioner)}
 * can achieve the same thing.
 * 
 * @param transNeo
 *            {@link GraphDatabaseService} representing a Neo4j instance
 * @param graphPath
 *            {@link String} representing path to .graph file
 * @param ptnPath
 *            {@link String} representing path to .ptn file
 */
public static void writeNeoFromChacoAndPtn(GraphDatabaseService transNeo,
		String graphPath, String ptnPath) 
{
	NeoFromFile.writeNeoFromChaco(transNeo, graphPath);
	NeoFromFile.allocateNodesFromPtn(transNeo, ptnPath);
}	",915,True
"/**
 * Deletes all {@link Relationship}s of the specified
 * {@link RelationshipType} values (as given by the {@link String} values in
 * relTypes parameter) from the Neo4j instance.
 * 
 * @param transNeo
 *            {@link GraphDatabaseService} representing a Neo4j instance
 * @param relTypes
 *            {@link HashSet} of {@link RelationshipType} representing the
 *            {@link Relationship}s that should be deleted
 */
public static void removeRelationshipsByType(GraphDatabaseService transNeo,
		HashSet<String> relTypes){

	long time = System.currentTimeMillis();
	System.out.printf(""Deleting relationships by type..."");

	int deletedRels = 0;

	Transaction tx = transNeo.beginTx();

	try {
		for (Node node : transNeo.getAllNodes()) {

			if (relTypes.size() <= 0)
				break;

			for (Relationship relationship : node
					.getRelationships(Direction.OUTGOING)) {

				// Don't delete Relationships of this type
				if (relTypes.contains(relationship.getType().name()) == false)
					continue;

				relationship.delete();

				if (++deletedRels % Consts.STORE_BUF == 0) {
					tx.success();
					tx.finish();
					tx = transNeo.beginTx();
				}

			}

		}

		tx.success();
	} catch (Exception e) {
		e.printStackTrace();
	} finally {
		tx.finish();
	}

	// PRINTOUT
	System.out.printf(""Deleted [%d]...%s"", deletedRels, getTimeStr(System
			.currentTimeMillis()
			- time));

}","/**
 * Deletes all {@link Relationship}s of the specified
 * {@link RelationshipType} values (as given by the {@link String} values in
 * relTypes parameter) from the Neo4j instance.
 * 
 * @param transNeo
 *            {@link GraphDatabaseService} representing a Neo4j instance
 * @param relTypes
 *            {@link HashSet} of {@link RelationshipType} representing the
 *            {@link Relationship}s that should be deleted
 */
public static void removeRelationshipsByType(GraphDatabaseService transNeo,
		HashSet<String> relTypes) 
{
	for (String relType : relTypes)
	{
		String query = ""MATCH ()-[r:"" + relType + ""]->() DELETE r"";
		transNeo.execute(query);
	}
}	",916,True
"/**
 * Martin's code, moved from neo4j_partitioned_api. Takes a normal Neo4j
 * instance {@link GraphDatabaseService} as input, creates a new partitioned
 * version {@link PGraphDatabaseService} in the specified directory, then
 * copies all data from the input instance into the new instance.
 * {@link Node}s must have a {@link Consts#COLOR} attribute as this is used
 * to decide which partition each {@link Node} is stored in.
 * 
 * @param transNeo
 *            {@link GraphDatabaseService} representing the regular Neo4j
 *            instance
 * @param pdbPath
 *            {@link String} specifying the directory where partitioned
 *            Neo4j instance should be created
 * @return {@link PGraphDatabaseService}
 */
public static PGraphDatabaseService writePNeoFromNeo(String pdbPath,
		GraphDatabaseService transNeo){

	System.out.println(""Converting Neo4j to PNeo4j"");

	// PGraphDatabaseService partitionedTransNeo = new
	// PGraphDatabaseServiceImpl(
	// pdbPath, 0);
	PGraphDatabaseService partitionedTransNeo = new PGraphDatabaseServiceSIM(
			pdbPath, 0);

	ArrayList<Long> nodeIDs = new ArrayList<Long>();

	// load all instance ids
	HashSet<Long> instIDs = new HashSet<Long>();
	for (Long instID : partitionedTransNeo.getInstancesIDs()) {
		instIDs.add(instID);
	}

	// PRINTOUT
	long time = System.currentTimeMillis();
	System.out.printf(""\tCounting Nodes..."");

	// counts all nodes
	Transaction tx = transNeo.beginTx();
	try {
		for (Node n : transNeo.getAllNodes()) {
			// ignore reference node
			if (n.getId() == 0)
				continue;

			nodeIDs.add(n.getId());
		}
		tx.success();
	} finally {
		tx.finish();
	}

	int nodesInSystem = nodeIDs.size();
	int nodeCount;
	int stepSize = 1000;
	int stepCount;

	Iterator<Long> idIter;

	// PRINTOUT
	System.out.printf(""[%d]...%s"", nodesInSystem, getTimeStr(System
			.currentTimeMillis()
			- time));

	nodeCount = 0;
	stepCount = 0;
	idIter = nodeIDs.iterator();
	while (idIter.hasNext()) {
		tx = transNeo.beginTx();
		try {

			// PRINTOUT
			time = System.currentTimeMillis();
			System.out.printf(""\tCreating Nodes..."");

			// my own transaction
			Transaction pTx = partitionedTransNeo.beginTx();
			try {
				while (idIter.hasNext() && stepCount < stepSize) {
					Node n = transNeo.getNodeById(idIter.next());

					long targetInst = (Byte) n.getProperty(Consts.COLOR);
					long gid = n.getId();

					// create instance if not yet existing
					if (!instIDs.contains(targetInst)) {
						partitionedTransNeo.addInstance(targetInst);
						instIDs.add(targetInst);
					}
					Node newN = partitionedTransNeo.createNodeOn(gid,
							targetInst);

					for (String key : n.getPropertyKeys()) {
						newN.setProperty(key, n.getProperty(key));
					}

					stepCount++;
					nodeCount++;
				}
				stepCount = 0;

				// PRINTOUT
				System.out.printf(""[%d/%d]...%s"", nodeCount, nodesInSystem,
						getTimeStr(System.currentTimeMillis() - time));

				pTx.success();
			} finally {
				pTx.finish();
			}
			tx.success();
		} finally {
			tx.finish();
		}
	}

	nodeCount = 0;
	stepCount = 0;
	idIter = nodeIDs.iterator();
	while (idIter.hasNext()) {
		tx = transNeo.beginTx();
		try {

			// PRINTOUT
			time = System.currentTimeMillis();
			System.out.printf(""\tCreating Relationships on Nodes..."");

			// my own transaction
			Transaction pTx = partitionedTransNeo.beginTx();
			try {
				while (idIter.hasNext() && stepCount < stepSize) {
					Node n = transNeo.getNodeById(idIter.next());

					long curN = n.getId();
					Node srtNode = partitionedTransNeo.getNodeById(curN);

					for (Relationship rs : n
							.getRelationships(Direction.OUTGOING)) {

						long endNodeGID = rs.getEndNode().getId();
						Node endNode = partitionedTransNeo
								.getNodeById(endNodeGID);
						Relationship newRs = srtNode.createRelationshipTo(
								endNode, rs.getType());

						// copy all properties
						for (String key : rs.getPropertyKeys()) {
							newRs.setProperty(key, rs.getProperty(key));
						}
					}
					stepCount++;
					nodeCount++;
				}
				stepCount = 0;

				// PRINTOUT
				System.out.printf(""[%d/%d]...%s"", nodeCount, nodesInSystem,
						getTimeStr(System.currentTimeMillis() - time));

				pTx.success();
			} finally {
				pTx.finish();
			}
			tx.success();
		} finally {
			tx.finish();
		}
	}
	transNeo.shutdown();

	return partitionedTransNeo;
}","/**
 * Martin's code, moved from neo4j_partitioned_api. Takes a normal Neo4j
 * instance {@link GraphDatabaseService} as input, creates a new partitioned
 * version {@link PGraphDatabaseService} in the specified directory, then
 * copies all data from the input instance into the new instance.
 * {@link Node}s must have a {@link Consts#COLOR} attribute as this is used
 * to decide which partition each {@link Node} is stored in.
 * 
 * @param transNeo
 *            {@link GraphDatabaseService} representing the regular Neo4j
 *            instance
 * @param pdbPath
 *            {@link String} specifying the directory where partitioned
 *            Neo4j instance should be created
 * @return {@link PGraphDatabaseService}
 */
public static PGraphDatabaseService writePNeoFromNeo(String pdbPath,
		GraphDatabaseService transNeo) 
{
	PGraphDatabaseService pdb = null;
	try
	{
		pdb = new PGraphDatabaseService(pdbPath);
	}
	catch (IOException e)
	{
		e.printStackTrace();
	}
	// Copy all nodes
	for (Node node : transNeo.getAllNodes())
	{
		pdb.createNode(node.getId(), node.getLabels(), node.getProperties());
	}
	// Copy all relationships
	for (Relationship rel : transNeo.getAllRelationships())
	{
		pdb.createRelationship(rel.getId(), rel.getStartNode(),
				rel.getEndNode(), rel.getType(), rel.getProperties());
	}
	return pdb;
}	",917,False
"/**
 * Deletes a specified number of {@link Node}s by selecting them from among
 * all {@link Node}s and then deleting them from the Neo4j instance.
 * Selection is performed uniformly random.
 * 
 * @param transNeo
 *            {@link GraphDatabaseService} representing a Neo4j instance
 * @param percNodesToKeep
 *            percentage of {@link Node}s that should not be deleted
 */
public static void removeRandomNodes(GraphDatabaseService transNeo,
		double percNodesToKeep){

	long time = System.currentTimeMillis();
	long flushTime = System.currentTimeMillis();

	System.out.println(""Deleting random nodes..."");

	int deletedRelsCount = 0;
	int deletedNodesCount = 0;
	int storeBuff = 0;

	Transaction tx = transNeo.beginTx();

	try {
		Random rand = new Random();

		for (Node node : transNeo.getAllNodes()) {

			if (rand.nextDouble() < percNodesToKeep)
				continue;

			for (Relationship rel : node.getRelationships()) {
				rel.delete();
				deletedRelsCount++;
				storeBuff++;
			}

			node.delete();
			deletedNodesCount++;
			storeBuff++;

			if (storeBuff >= Consts.STORE_BUF) {
				storeBuff = 0;

				tx.success();
				tx.finish();
				tx = transNeo.beginTx();

				// if ((deletedRelsCount + deletedNodesCount) % 1000000 ==
				// 0) {
				System.out.printf(""\t[%d,%d]...%s"", deletedNodesCount,
						deletedRelsCount, getTimeStr(System
								.currentTimeMillis()
								- flushTime));
				flushTime = System.currentTimeMillis();
				// }
			}

		}

		tx.success();
	} catch (Exception e) {
		e.printStackTrace();
	} finally {
		tx.finish();
	}

	// PRINTOUT
	System.out
			.printf(""\tDeleted [%d,%d]...%s"", deletedNodesCount,
					deletedRelsCount, getTimeStr(System.currentTimeMillis()
							- time));

}","/**
 * Deletes a specified number of {@link Node}s by selecting them from among
 * all {@link Node}s and then deleting them from the Neo4j instance.
 * Selection is performed uniformly random.
 * 
 * @param transNeo
 *            {@link GraphDatabaseService} representing a Neo4j instance
 * @param percNodesToKeep
 *            percentage of {@link Node}s that should not be deleted
 */
public static void removeRandomNodes(GraphDatabaseService transNeo,
		double percNodesToKeep) 
{
	long numNodes = countNodes(transNeo);
	long numNodesToDelete = (long) (numNodes * (1 - percNodesToKeep));
	System.out.println(""Deleting "" + numNodesToDelete + "" nodes"");

	try (Transaction tx = transNeo.beginTx())
	{
		for (int i = 0; i < numNodesToDelete; i++)
		{
			long nodeId = selectRandomNode(transNeo);
			Node node = transNeo.getNodeById(nodeId);
			node.delete();
		}
		tx.success();
	}
}	",919,True
"// Search for an elemnt in the tree
public int Search(int v_key){
  boolean cont;
  int ifound;
  Tree current_node;
  int key_aux;

  current_node = this;
  cont = true;
  ifound = 0;
  while (cont) {
    key_aux = current_node.GetKey();
    if (v_key < key_aux) {
      if (current_node.GetHas_Left()) {
        current_node = current_node.GetLeft();
      } else {
        cont = false;
      }
    } else if (key_aux < v_key) {
      if (current_node.GetHas_Right()) {
        current_node = current_node.GetRight();
      } else {
        cont = false;
      }
    } else {
      ifound = 1;
      cont = false;
    }
  }
  return ifound;
}","// Search for an elemnt in the tree
public int Search(int v_key) 
{
    if (v_key == this.key)
        return this.key;
    else if (v_key < this.key && this.left != null)
        return this.left.Search(v_key);
    else if (v_key > this.key && this.right != null)
        return this.right.Search(v_key);
    else
        return -1;
}   ",921,True
"// Print the elements of the tree
public boolean RecPrint(Tree node){
  boolean ntb;

  if (node.GetHas_Left()) {
    //auxtree01 = node.GetLeft() ;
    //ntb = this.RecPrint(auxtree01);
    ntb = this.RecPrint(node.GetLeft());
  } else {
    ntb = true;
  }
  System.out.println(node.GetKey());
  if (node.GetHas_Right()) {
    //auxtree01 = node.GetRight() ;
    //ntb = this.RecPrint(auxtree01);
    ntb = this.RecPrint(node.GetRight());
  } else {
    ntb = true;
  }
  return true;
}","// Print the elements of the tree
public boolean RecPrint(Tree node) 
{
    if(node == null)
    {
        return false;
    }
    System.out.print(node.data + "" "");
    RecPrint(node.left);
    RecPrint(node.right);
    return true;
}   ",922,True
"/** Constructor with message and reason. */
public TokenMgrError(String message, int reason){
  super(message);
  errorCode = reason;
}","/** Constructor with message and reason. */
public TokenMgrError(String message, int reason) 
{
    super();
    this.message = message;
    this.reason = reason;
}   ",926,True
"// Invoke the method to really print the tree elements
public boolean Print(){
  Tree current_node;
  boolean ntb;

  current_node = this;
  ntb = this.RecPrint(current_node);
  return true;
}","// Invoke the method to really print the tree elements
public boolean Print() 
{
    if (this.root == null)
    {
        return false;
    }
    else
    {
        this.root.Print();
        return true;
    }
}   ",927,True
"// Insert a new element in the tree
public boolean Insert(int v_key){
  Tree new_node;
  boolean ntb;
  boolean cont;
  int key_aux;
  Tree current_node;

  new_node = new Tree();
  ntb = new_node.Init(v_key);
  current_node = this;
  cont = true;
  while (cont) {
    key_aux = current_node.GetKey();
    if (v_key < key_aux) {
      if (current_node.GetHas_Left()) {
        current_node = current_node.GetLeft();
      } else {
        cont = false;
        ntb = current_node.SetHas_Left(true);
        ntb = current_node.SetLeft(new_node);
      }
    } else {
      if (current_node.GetHas_Right()) {
        current_node = current_node.GetRight();
      } else {
        cont = false;
        ntb = current_node.SetHas_Right(true);
        ntb = current_node.SetRight(new_node);
      }
    }
  }
  return true;
}","// Insert a new element in the tree
public boolean Insert(int v_key) 
{
    if (root == null) {
        root = new Node(v_key);
        return true;
    }
    return root.Insert(v_key);
}   ",928,False
"// Update the right child with rn
public boolean SetRight(Tree rn){
  right = rn;
  return true;
}","// Update the right child with rn
public boolean SetRight(Tree rn) 
{
    if (right == null)
    {
        right = rn;
        return true;
    }
    else
    {
        return false;
    }
}   ",929,True
"/** Get the next Token. */
public static Token getNextToken(){
  Token specialToken = null;
  Token matchedToken;
  int curPos = 0;

  EOFLoop :
  for (;;)
  {
   try
   {
      curChar = input_stream.BeginToken();
   }
   catch(java.io.IOException e)
   {
      jjmatchedKind = 0;
      matchedToken = jjFillToken();
      matchedToken.specialToken = specialToken;
      return matchedToken;
   }

   try { input_stream.backup(0);
      while (curChar <= 32 && (0x100003600L & (1L << curChar)) != 0L)
         curChar = input_stream.BeginToken();
   }
   catch (java.io.IOException e1) { continue EOFLoop; }
   jjmatchedKind = 0x7fffffff;
   jjmatchedPos = 0;
   curPos = jjMoveStringLiteralDfa0_0();
   if (jjmatchedKind != 0x7fffffff)
   {
      if (jjmatchedPos + 1 < curPos)
         input_stream.backup(curPos - jjmatchedPos - 1);
      if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
      {
         matchedToken = jjFillToken();
         matchedToken.specialToken = specialToken;
         return matchedToken;
      }
      else
      {
         if ((jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
         {
            matchedToken = jjFillToken();
            if (specialToken == null)
               specialToken = matchedToken;
            else
            {
               matchedToken.specialToken = specialToken;
               specialToken = (specialToken.next = matchedToken);
            }
         }
         continue EOFLoop;
      }
   }
   int error_line = input_stream.getEndLine();
   int error_column = input_stream.getEndColumn();
   String error_after = null;
   boolean EOFSeen = false;
   try { input_stream.readChar(); input_stream.backup(1); }
   catch (java.io.IOException e1) {
      EOFSeen = true;
      error_after = curPos <= 1 ? """" : input_stream.GetImage();
      if (curChar == '\n' || curChar == '\r') {
         error_line++;
         error_column = 0;
      }
      else
         error_column++;
   }
   if (!EOFSeen) {
      input_stream.backup(1);
      error_after = curPos <= 1 ? """" : input_stream.GetImage();
   }
   throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
  }
}","/** Get the next Token. */
public static Token getNextToken() 
{
    if (currentToken == null)
    {
        currentToken = new Token();
    }
    return currentToken;
}   ",930,False
"/**
 * Replaces unprintable characters by their escaped (or unicode escaped)
 * equivalents in the given string
 */
protected static final String addEscapes(String str){
  StringBuffer retval = new StringBuffer();
  char ch;
  for (int i = 0; i < str.length(); i++) {
    switch (str.charAt(i))
    {
      case 0 :
        continue;
      case '\b':
        retval.append(""\\b"");
        continue;
      case '\t':
        retval.append(""\\t"");
        continue;
      case '\n':
        retval.append(""\\n"");
        continue;
      case '\f':
        retval.append(""\\f"");
        continue;
      case '\r':
        retval.append(""\\r"");
        continue;
      case '\""':
        retval.append(""\\\"""");
        continue;
      case '\'':
        retval.append(""\\\'"");
        continue;
      case '\\':
        retval.append(""\\\\"");
        continue;
      default:
        if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
          String s = ""0000"" + Integer.toString(ch, 16);
          retval.append(""\\u"" + s.substring(s.length() - 4, s.length()));
        } else {
          retval.append(ch);
        }
        continue;
    }
  }
  return retval.toString();
}","/**
 * Replaces unprintable characters by their escaped (or unicode escaped)
 * equivalents in the given string
 */
protected static final String addEscapes(String str) 
{
    StringBuilder retval = new StringBuilder();
    char ch;
    for (int i = 0; i < str.length(); i++)
    {
        ch = str.charAt(i);
        // remove escapes
        if (ch == '\\')
        {
            retval.append('\\');
            retval.append('\\');
            continue;
        }
        switch (ch)
        {
            case '\b':
                retval.append('\\');
                retval.append('b');
                break;
            case '\t':
                retval.append('\\');
                retval.append('t');
                break;
            case '\n':
                retval.append('\\');
                retval.append('n');
                break;
            case '\f':
                retval.append('\\');
                retval.append('f');
                break;
            case '\r':
                retval.append('\\');
                retval.append('r');
                break;
            default:
                if (ch < ' ' || (ch >= '\u0080' && ch < '\u00a0') || (ch >= '\u2000' && ch < '\u2100'))
                {
                    retval.append('\\');
                    retval.append('u');
                    retval.append(Integer.toHexString(ch));
                }
                else
                {
                    retval.append(ch);
                }
        }
    }
    return retval.toString();
}   ",934,False
"/** Reinitialise parser. */
static public void ReInit(SimpleCharStream stream, int lexState){
   ReInit(stream);
   SwitchTo(lexState);
}","/** Reinitialise parser. */
static public void ReInit(SimpleCharStream stream, int lexState) 
{
    yybuffer = stream;
    yybufferpos = 0;
    yy_at_bol  = true;
    yy_lexical_state = lexState;
}   ",935,True
"/**
 * Returns a detailed message for the Error when it is thrown by the
 * token manager to indicate a lexical error.
 * Parameters :
 *    EOFSeen     : indicates if EOF caused the lexical error
 *    curLexState : lexical state in which this error occurred
 *    errorLine   : line number when the error occurred
 *    errorColumn : column number when the error occurred
 *    errorAfter  : prefix that was seen before this error occurred
 *    curchar     : the offending character
 * Note: You can customize the lexical error message by modifying this method.
 */
protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar){
  return(""Lexical error at line "" +
        errorLine + "", column "" +
        errorColumn + "".  Encountered: "" +
        (EOFSeen ? ""<EOF> "" : (""\"""" + addEscapes(String.valueOf(curChar)) + ""\"""") + "" ("" + (int)curChar + ""), "") +
        ""after : \"""" + addEscapes(errorAfter) + ""\"""");
}","/**
 * Returns a detailed message for the Error when it is thrown by the
 * token manager to indicate a lexical error.
 * Parameters :
 *    EOFSeen     : indicates if EOF caused the lexical error
 *    curLexState : lexical state in which this error occurred
 *    errorLine   : line number when the error occurred
 *    errorColumn : column number when the error occurred
 *    errorAfter  : prefix that was seen before this error occurred
 *    curchar     : the offending character
 * Note: You can customize the lexical error message by modifying this method.
 */
protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) 
{
    StringBuffer sb = new StringBuffer();

    if (EOFSeen) {
        sb.append(""Error: Unexpected end of file. "");
    } else {
        sb.append(""Error: Unexpected character '"").append(curChar).append(""' ("").append((int)curChar).append(""). "");
    }

    sb.append(""At line "").append(errorLine).append("", column "").append(errorColumn).append("". "");
    sb.append(""Seen so far: "").append(errorAfter);

    return sb.toString();
}   ",938,True
"/**
 * Constructs a new, empty Bundle.
 */
public Bundle(){
    mMap = new HashMap<String, Object>();
    mClassLoader = getClass().getClassLoader();
}","/**
 * Constructs a new, empty Bundle.
 */
public Bundle() 
{
    this(new HashMap<String, Object>());
}   ",941,True
"/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a Bundle value, or null
 */
public Bundle getBundle(String key){
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (Bundle) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""Bundle"", e);
        return null;
    }
}","/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a Bundle value, or null
 */
public Bundle getBundle(String key) 
{
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (Bundle)o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""Bundle"", e);
        return null;
    }
}   ",942,True
"/**
 * Inserts a short array value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a short array object, or null
 */
public void putShortArray(String key, short[] value){
    unparcel();
    mMap.put(key, value);
}","/**
 * Inserts a short array value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a short array object, or null
 */
public void putShortArray(String key, short[] value) 
{
    if (key == null) {
        throw new NullPointerException(""key must not be null"");
    }

    putObject(key, value);
}   ",943,True
"/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a String value, or null
 */
public String getString(String key){
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (String) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""String"", e);
        return null;
    }
}","/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a String value, or null
 */
public String getString(String key) 
{
    Object value = get(key);
    if (value == null)
    {
        return null;
    }
    else if (value instanceof String)
    {
        return (String)value;
    }
    else
    {
        throw new IllegalStateException(
            ""Value for key "" + key + "" is not a String: "" + value);
    }
}   ",944,True
"/**
 * Returns the value associated with the given key, or (char) 0 if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @return a char value
 */
public char getChar(String key, char defaultValue){
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return defaultValue;
    }
    try {
        return (Character) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""Character"", defaultValue, e);
        return defaultValue;
    }
}","/**
 * Returns the value associated with the given key, or (char) 0 if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @return a char value
 */
public char getChar(String key, char defaultValue) 
{
    Object value = get(key);
    if (value instanceof Character)
    {
        return ((Character) value).charValue();
    }
    else
    {
        return defaultValue;
    }
}   ",948,True
"/**
 * Returns the value associated with the given key, or 0 if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @return an int value
 */
public int getInt(String key){
    unparcel();
    return getInt(key, 0);
}","/**
 * Returns the value associated with the given key, or 0 if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @return an int value
 */
public int getInt(String key) 
{
    Object value = get(key);
    if (value instanceof Integer)
    {
        return (Integer) value;
    }
    else
    {
        return 0;
    }
}   ",949,False
"/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a Serializable value, or null
 */
public Serializable getSerializable(String key){
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (Serializable) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""Serializable"", e);
        return null;
    }
}","/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a Serializable value, or null
 */
public Serializable getSerializable(String key) 
{
    Object value = get(key);
    if (value == null)
    {
        return null;
    }
    else if (value instanceof Serializable)
    {
        return (Serializable)value;
    }
    else
    {
        throw new IllegalStateException(""Value of key "" + key + "" is not a Serializable: "" + value);
    }
}   ",950,False
"/**
 * Returns the value associated with the given key, or defaultValue if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @return a byte value
 */
public Byte getByte(String key, byte defaultValue){
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return defaultValue;
    }
    try {
        return (Byte) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, ""Byte"", defaultValue, e);
        return defaultValue;
    }
}","/**
 * Returns the value associated with the given key, or defaultValue if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @return a byte value
 */
public Byte getByte(String key, byte defaultValue) 
{
    try
    {
        return ((Byte) get(key)).byteValue();
    }
    catch (ClassCastException e)
    {
        return defaultValue;
    }
    catch (NullPointerException e)
    {
        return defaultValue;
    }
}   ",951,True
"/**
 * Assert that two views are top aligned, that is that their top edges
 * are on the same y location, with respect to the specified margin.
 *
 * @param first The first view
 * @param second The second view
 * @param margin The margin between the first view and the second view
 */
static public void assertTopAligned(View first, View second, int margin){
    int[] xy = new int[2];
    first.getLocationOnScreen(xy);
    int firstTop = xy[1];

    second.getLocationOnScreen(xy);
    int secondTop = xy[1];

    assertEquals(""views are not top aligned"", Math.abs(firstTop - secondTop), margin);
}","/**
 * Assert that two views are top aligned, that is that their top edges
 * are on the same y location, with respect to the specified margin.
 *
 * @param first The first view
 * @param second The second view
 * @param margin The margin between the first view and the second view
 */
static public void assertTopAligned(View first, View second, int margin) 
{
    int firstTop = first.getTop();
    int secondTop = second.getTop();
    assertEquals(""views are not top aligned"", firstTop, secondTop, margin);
}   ",953,True
"/**
 * Assert that two views are left aligned, that is that their left edges
 * are on the same x location.
 *
 * @param first The first view
 * @param second The second view
 */
static public void assertLeftAligned(View first, View second){
    int[] xy = new int[2];
    first.getLocationOnScreen(xy);
    int firstLeft = xy[0];

    second.getLocationOnScreen(xy);
    int secondLeft = xy[0];

    assertEquals(""views are not left aligned"", firstLeft, secondLeft);
}","/**
 * Assert that two views are left aligned, that is that their left edges
 * are on the same x location.
 *
 * @param first The first view
 * @param second The second view
 */
static public void assertLeftAligned(View first, View second) 
{
    Assert.assertEquals(""Views are not left aligned"", first.getLeft(), second.getLeft());
}   ",956,True
"/**
 * Removes all elements from the mapping of this Bundle.
 */
public void clear(){
    unparcel();
    mMap.clear();
    mHasFds = false;
    mFdsKnown = true;
}","/**
 * Removes all elements from the mapping of this Bundle.
 */
public void clear() 
{
    synchronized (this)
    {
        if (mMap != null)
        {
            mMap.clear();
        }
    }
}   ",957,False
"/**
 * Assert that two views are left aligned, that is that their left edges
 * are on the same x location, with respect to the specified margin.
 *
 * @param first The first view
 * @param second The second view
 * @param margin The margin between the first view and the second view
 */
static public void assertLeftAligned(View first, View second, int margin){
    int[] xy = new int[2];
    first.getLocationOnScreen(xy);
    int firstLeft = xy[0];

    second.getLocationOnScreen(xy);
    int secondLeft = xy[0];

    assertEquals(""views are not left aligned"", Math.abs(firstLeft - secondLeft), margin);
}","/**
 * Assert that two views are left aligned, that is that their left edges
 * are on the same x location, with respect to the specified margin.
 *
 * @param first The first view
 * @param second The second view
 * @param margin The margin between the first view and the second view
 */
static public void assertLeftAligned(View first, View second, int margin) 
{
    int firstLeft = first.getLeft();
    int secondLeft = second.getLeft();
    int expectedLeft = firstLeft + first.getWidth() + margin;
    assertEquals(""views are not left aligned"", expectedLeft, secondLeft);
}   ",958,False
"/**
 * Returns the value associated with the given key, or (byte) 0 if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @return a byte value
 */
public byte getByte(String key){
    unparcel();
    return getByte(key, (byte) 0);
}","/**
 * Returns the value associated with the given key, or (byte) 0 if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @return a byte value
 */
public byte getByte(String key) 
{
    Object value = map.get(key);
    if (value instanceof Byte)
    {
        return ((Byte) value).byteValue();
    }
    else
    {
        return (byte) 0;
    }
}   ",959,False
"/**
 * Overridden for performance reasons.
 * See the <a href=""#override"">Implementation Note</a> 
 * for more information.
 */
@Override
public boolean isOpaque(){ 
    Color back = getBackground();
    Component p = getParent(); 
    if (p != null) { 
        p = p.getParent(); 
    }
    boolean colorMatch = (back != null) && (p != null) && 
    back.equals(p.getBackground()) && 
    p.isOpaque();
    return !colorMatch && super.isOpaque(); 
}","/**
 * Overridden for performance reasons.
 * See the <a href=""#override"">Implementation Note</a> 
 * for more information.
 */
@Override
public boolean isOpaque() 
{
    return false;
}   ",960,False
"/**
 * Sets the dimensions of the available space for layout to {@code size}.
 */
@Override
	public void setSize(Dimension size){
		if(initialized == false)
			setInitializer(new RandomLocationTransformer<Functionality.Node>(size));
		super.setSize(size);
	}","/**
 * Sets the dimensions of the available space for layout to {@code size}.
 */
@Override
	public void setSize(Dimension size) 
{
	if (size == null)
	{
		throw new IllegalArgumentException(""size cannot be null"");
	}
	this.size = new Dimension(size);
	invalidate();
}	",962,True
"/**
 * Create and return a table
 * 
 * @return JTable
 */
private static List<String> processQueryString(String str){
	int b = 0;
	int parStartIndex = -1;
	int normStartIndex = 0;

	List<String> terms = new ArrayList<String>();

	for (int i = 0; i < str.length(); i++) {
		if (str.charAt(i) == '""') {
			if (b == 0) {
				parStartIndex = i + 1;
				b = 1;
			} else {
				terms.add(str.substring(parStartIndex, i));
				parStartIndex = -1;
				b = 0;
				normStartIndex = i + 1;
			}
		} else {
			if (str.charAt(i) == ' ' && b == 0) {
				if (normStartIndex < i) {
					terms.add(str.substring(normStartIndex, i));

				}

				normStartIndex = i + 1;
			}
		}
	}

	if (normStartIndex < str.length()) {
		terms.add(str.substring(normStartIndex, str.length()));
	}

	return terms;
}","/**
 * Create and return a table
 * 
 * @return JTable
 */



private static List<String> processQueryString(String str) 
{
    List<String> list = new ArrayList<String>();
    StringTokenizer st = new StringTokenizer(str, "" "");
    while (st.hasMoreTokens())
    {
        list.add(st.nextToken());
    }
    return list;
}   ",963,True
"/**
 * Constructor for a SpringLayout for a raw graph with associated component.
 *
 * @param g the {@code Graph} to lay out
 * @param length_function provides a length for each edge
 */
public SpringLayoutWeighted(Graph<Functionality.Node,Functionality.Edge> g, Transformer<Functionality.Edge, Integer> length_function){
    super(g);
    this.lengthFunction = length_function;
}","/**
 * Constructor for a SpringLayout for a raw graph with associated component.
 *
 * @param g the {@code Graph} to lay out
 * @param length_function provides a length for each edge
 */
public SpringLayoutWeighted(Graph<Functionality.Node,Functionality.Edge> g, Transformer<Functionality.Edge, Integer> length_function) 
{
    this.g = g;
    this.length_function = length_function;
    this.component = new Component();
}   ",965,True
"/*private Set<String> getNEText(Set<NamedEntity> sne)
{
	NamedEntity ne;
	Set<String> ret = new HashSet<String>();
	for (Iterator<NamedEntity> it = sne.iterator(); it.hasNext(); )
	{
		ne = it.next();
		ret.add(ne.getText());
		
	}
	return ret;
}*/
private String makeStringForStringMap(Map<String, Boolean> sneID, String color){
	String text = """";
	String ne;
	for (Iterator<String> it = sneID.keySet().iterator(); it.hasNext(); )
	{
		ne = it.next();
		if (sneID.get(ne))
		{
			text += ""<span style=\""color:"" + color + ""\"">"" + ne + ""</span><br/>"";
		}
		else
		{
			text += ""<span style=\""color:"" + color + ""\""><b>"" + ne + ""</b></span><br/>"";				
		}
	}
	return text;
}","/*private Set<String> getNEText(Set<NamedEntity> sne)
{
	NamedEntity ne;
	Set<String> ret = new HashSet<String>();
	for (Iterator<NamedEntity> it = sne.iterator(); it.hasNext(); )
	{
		ne = it.next();
		ret.add(ne.getText());
		
	}
	return ret;
}*/
private String makeStringForStringMap(Map<String, Boolean> sneID, String color) 
{
	String ret = """";
	for (Map.Entry<String, Boolean> entry : sneID.entrySet())
	{
		ret += entry.getKey() + "" "" + color + "" "" + entry.getValue() + ""\n"";
	}
	return ret;
}	",966,True
"/**
 * @param args
 */
public static void main(String[] args){

	gui = new CastroGUI();
	gui.init();
}","/**
 * @param args
 */
public static void main(String[] args) 
{
    int i = 0;
    while (i < 5)
    {
        System.out.println(""Hello World"");
        i++;
    }
}   ",969,False
"/** Creates a new instance of MarkNeightboursVertexedge StrokeMenuItem */
public MarkNeightboursMenuItem(){
	super(""Mark Neighbors"");
	this.addActionListener(new ActionListener(){
		@SuppressWarnings(""unchecked"")
		public void actionPerformed(ActionEvent e) {
			VertexColorTransformer.vctInstance.setMarkedNodes(vertex.getNeighborsMap());
			visComp.repaint();
		}
	});
}","/** Creates a new instance of MarkNeightboursVertexedge StrokeMenuItem */


public MarkNeightboursMenuItem() 
{
    super(""Mark Neightbours"");
    this.addActionListener(new ActionListener()
    {
        public void actionPerformed(ActionEvent e)
        {
            markNeightbours();
        }
    });
}   ",971,True
"/**
 * Implements the VertexMenuListener interface.
 * @param v 
 * @param visComp 
 */
public void setVertexAndView(Functionality.Node v, VisualizationViewer visComp){
	this.vertex = v;
	this.visComp = visComp;
	this.setText(""Mark Neightbours"");
	System.err.println(""Mark neightboursMenuItem!!!!!!"");


}","/**
 * Implements the VertexMenuListener interface.
 * @param v 
 * @param visComp 
 */
public void setVertexAndView(Functionality.Node v, VisualizationViewer visComp) 
{
    this.v = v;
    this.visComp = visComp;
}   ",975,True
"/**
 * Creates the field editors. Field editors are abstractions of
 * the common GUI blocks needed to manipulate various types
 * of preferences. Each field editor knows how to save and
 * restore itself.
 */
public void createFieldEditors(){
	/*addField(new DirectoryFieldEditor(PreferenceConstants.P_PATH, 
			""&Directory preference:"", getFieldEditorParent()));
	addField(
		new BooleanFieldEditor(
			PreferenceConstants.P_BOOLEAN,
			""&An example of a boolean preference"",
			getFieldEditorParent()));

	addField(new RadioGroupFieldEditor(
			PreferenceConstants.P_CHOICE,
		""An example of a multiple-choice preference"",
		1,
		new String[][] { { ""&Choice 1"", ""choice1"" }, {
			""Choice 2"", ""choice2"" }
	}, getFieldEditorParent()));*/
	String configLocation=ResourcesPlugin.getWorkspace().getRoot().getRawLocation().toOSString();
	
	//try {
		//config = new Config(configLocation+""\\.coed\\config.ini"");
		config = Activator.getDefault().getController().getConfig();
	//} catch (InvalidConfigFileException e) {
		// TODO Auto-generated catch block
		//e.printStackTrace();
	//}
	e1=new StringFieldEditor(PreferenceConstants.P_STRING1, ""Username"", getFieldEditorParent());
	e2=new StringFieldEditor(PreferenceConstants.P_STRING2, ""Password"", getFieldEditorParent());
	e3=new StringFieldEditor(PreferenceConstants.P_STRING3, ""Server Hostname"", getFieldEditorParent());
	e4=new StringFieldEditor(PreferenceConstants.P_STRING4, ""Server Port"", getFieldEditorParent());
	
	addField(e4);		  
	addField(e2);			
	addField(e3);			
	addField(e1);			
}","/**
 * Creates the field editors. Field editors are abstractions of
 * the common GUI blocks needed to manipulate various types
 * of preferences. Each field editor knows how to save and
 * restore itself.
 */
public void createFieldEditors() 
{
    String[][] fileTypeNames = {
        { ""Java source"", ""*.java"" },
        { ""All files"", ""*.*"" }
    };

    // Create the file type field editor.
    fileTypeEditor = new RadioGroupFieldEditor(
        PreferencesConstants.P_FILE_TYPE,
        ""File type:"",
        1,
        fileTypeNames,
        container);
    addField(fileTypeEditor);

    // Create the output folder field editor.
    outputFolderEditor = new DirectoryFieldEditor(
        PreferencesConstants.P_OUTPUT_FOLDER,
        ""&Output folder:"",
        container);
    addField(outputFolderEditor);
}   ",980,False
"/**
 * removes a session from the serverfile. if the removed session was the
 * last one registered on this serverfile, the serverfile will be deleted
 * from the managar. if the specified file is not in the manager, no action
 * is taken
 * 
 * @param sf
 * @param s
 */
public void removeSessionFromFile(ServerFile sf, Session s){
	if (files.containsKey(sf.getPath())) {
		sf.removeSession(s);
		if (sf.getNrOfSessions() == 0)
			files.remove(sf.getPath());
	}
}","/**
 * removes a session from the serverfile. if the removed session was the
 * last one registered on this serverfile, the serverfile will be deleted
 * from the managar. if the specified file is not in the manager, no action
 * is taken
 * 
 * @param sf
 * @param s
 */
public void removeSessionFromFile(ServerFile sf, Session s) 
{
    if (sf.containsSession(s))
    {
        sf.removeSession(s);
        if (sf.getSessionCount() == 0)
        {
            removeServerFile(sf);
        }
    }
}   ",986,True
"/*
 * (non-Javadoc)
 * @see org.eclipse.ui.plugin.AbstractUIPlugin#start(org.osgi.framework.BundleContext)
 */
public void start(BundleContext context) throws Exception{
	super.start(context);
	plugin = this;
	controller = new Controller();
	imageRegistry = new ImageRegistry();
	//TODO: add icons
	/* smthg like:
	 URL myUrl=	new URL(MyPlugin.getInstance().getDescriptor().getInstallURL(),""images/my_action.gif"");
	 ImageDescriptor id = ImageDescriptor.createFromURL(myUrl);
	 imageRegisrty.put(name, image);....
	 */
}","/*
 * (non-Javadoc)
 * @see org.eclipse.ui.plugin.AbstractUIPlugin#start(org.osgi.framework.BundleContext)
 */
public void start(BundleContext context) throws Exception 
{
    super.start(context);
    plugin = this;
    try
    {
        tracker = new Tracker(context, this);
        tracker.open();
    }
    catch (Exception e)
    {
        plugin = null;
        throw e;
    }
}   ",987,False
"/**
 * Alters a table's contents and returns the number of rows affected
 * Throws SQLException when query is unsuccessful
 * @param q - the string representing the query
 * @return the number of rows affected
 */
public int alter(String q)throws SQLException{
	Statement stat = conn.createStatement();
	return stat.executeUpdate(q);
}","/**
 * Alters a table's contents and returns the number of rows affected
 * Throws SQLException when query is unsuccessful
 * @param q - the string representing the query
 * @return the number of rows affected
 */

public int alter(String q)throws SQLException 
{
    Statement s = conn.createStatement();
    int rows = s.executeUpdate(q);
    s.close();
    return rows;
}   ",988,True
"/*
 * (non-Javadoc)
 * @see org.eclipse.ui.plugin.AbstractUIPlugin#stop(org.osgi.framework.BundleContext)
 */
public void stop(BundleContext context) throws Exception{
	plugin = null;
	super.stop(context);
}","/*
 * (non-Javadoc)
 * @see org.eclipse.ui.plugin.AbstractUIPlugin#stop(org.osgi.framework.BundleContext)
 */
public void stop(BundleContext context) throws Exception 
{
    plugin = null;
    super.stop(context);
}   ",993,True
"/**
 * Synchronized access method that returns an array of all the ServerFiles
 * that are in this FileManager(i.e. the online files)
 * 
 * @return array of ServerFile objects
 */
public ServerFile[] getAllLiveFiles(){
	ServerFile[] result = new ServerFile[files.size()];
	int i = 0;
	synchronized (files) {
		for (Map.Entry<Integer, ServerFile> entry : files.entrySet()) {
			result[i] = entry.getValue();
			i++;
		}
	}
	return result;
}","/**
 * Synchronized access method that returns an array of all the ServerFiles
 * that are in this FileManager(i.e. the online files)
 * 
 * @return array of ServerFile objects
 */
public ServerFile[] getAllLiveFiles() 
{
    synchronized (files)
    {
        ServerFile[] temp = new ServerFile[files.size()];
        return files.toArray(temp);
    }
}   ",994,True
"//when trying to acces a change out of range
public void testGetChangeAt(){
		CoedFileChange chg1 = new CoedFileChange(new TextModification(1,10,""abcdefghij""), new Date());
		queue.enQueueChange(chg1);
		assertTrue(queue.getChangeAt(0).equals(chg1.getMod()));
		assertNull(queue.getChangeAt(10));
	}","//when trying to acces a change out of range
public void testGetChangeAt() 
{
    try
    {
        Change change = new Change(0, 0, 0, 0);
        change.getChangeAt(1);
        fail(""Expected IndexOutOfBoundsException"");
    }
    catch (IndexOutOfBoundsException e)
    {
        // Expected exception
    }
}   ",995,True
"/* (non-Javadoc)
 * @see org.eclipse.ui.IWorkbenchPreferencePage#init(org.eclipse.ui.IWorkbench)
 */
public boolean performOk(){
	config.setString(""user.password"", e2.getStringValue());
	config.setString(""server.host"",e3.getStringValue());
	config.setString(""server.port"",e4.getStringValue());
	config.setString(""user.name"",e1.getStringValue());
	
	 config.writeConfigFile();
	
	return true;
}","/* (non-Javadoc)
 * @see org.eclipse.ui.IWorkbenchPreferencePage#init(org.eclipse.ui.IWorkbench)
 */
public boolean performOk() 
{
    if (this.isDirty)
    {
        this.isDirty = false;
        return true;
    }
    else
    {
        return false;
    }
}   ",997,False
"/**
 * Read a serialized object from a file
 * @param filename the file to read from
 * @return the object read from the file or null if an error occurred
 */
public static Object readObjectFromFile(String filename){
	//deserialize the the file
      
	try {
		//use buffering
		InputStream file = new FileInputStream( filename );
		InputStream buffer = new BufferedInputStream( file );
		ObjectInput input = new ObjectInputStream ( buffer );
		try {
			//display its data
			return input.readObject();
		} finally {
			input.close();
		}
	} catch(ClassNotFoundException ex){
		ex.printStackTrace();
	} catch(IOException ex){
		ex.printStackTrace();
	}
	return null;
    }","/**
 * Read a serialized object from a file
 * @param filename the file to read from
 * @return the object read from the file or null if an error occurred
 */





public static Object readObjectFromFile(String filename) 
{
    Object obj = null;
    try
    {
        FileInputStream fis = new FileInputStream(filename);
        BufferedInputStream bis = new BufferedInputStream(fis);
        ObjectInputStream ois = new ObjectInputStream(bis);
        obj = ois.readObject();
        ois.close();
    }
    catch (IOException | ClassNotFoundException e)
    {
        e.printStackTrace();
    }
    return obj;
}   ",998,True
"/**
 * Removes a file from the Manager
 * 
 * @param path
 *            the path of the file (key).
 */
public void removeFile(Integer id){
	if (files.containsKey(id))
		files.remove(id);
}","/**
 * Removes a file from the Manager
 * 
 * @param path
 *            the path of the file (key).
 */
public void removeFile(Integer id) 
{
    if (files.containsKey(id))
    {
        files.remove(id);
    }
}   ",999,True
"/**
 * Initialise an instance of the mechanics.
 */
public BattleMechanics(int bytes){
	if (bytes == 4) {
		m_random = new Random();
	} else {
		m_random = getRandomSource(bytes);
	}
}","/**
 * Initialise an instance of the mechanics.
 */

public BattleMechanics(int bytes) 
{
    this.bytes = bytes;
    this.battle = new Battle(bytes);
    this.player = new Player(bytes);
    this.enemy = new Enemy(bytes);
}   ",1000,True
"/**
 * Returns true if a fishing attempt was deemed successful(Will the player pull up any monster or find nothing?)
 * @param c
 * @param d
 * @param rod
 */
public boolean caughtFish(PlayerChar c, Direction d, int rod){
	int failureRate = 75;
	//Subtract the rod's power from the failure rate.
	failureRate -= rod;
	//If that tile is a water tile, determine if you pulled anything, if not, autofail(You can't fish on dry land)
	if(facingWater(c, d)) { //If facing water
		c.setFishing(true);		
		if((int)(Math.random()* 101) > failureRate) {
			return true;
		} else {
			return false;
		}
	} else {
		c.getTcpSession().write(""Ff""); // Tell the player he can't fish on land
	}
	return false;
}","/**
 * Returns true if a fishing attempt was deemed successful(Will the player pull up any monster or find nothing?)
 * @param c
 * @param d
 * @param rod
 */
public boolean caughtFish(PlayerChar c, Direction d, int rod) 
{
    if (d == Direction.UP)
    {
        if (c.getTile().getTileAtDirection(d).getMonster() != null)
        {
            return true;
        }
        else
        {
            return false;
        }
    }
    else
    {
        return false;
    }
}   ",1001,True
"/**
 * Returns the amount of EXP required to reach a level
 * based on a monster's EXP type
 * @param poke
 * @param level
 * @return
 */
public double getExpForLevel(Monster poke, int level){
	double exp = 0;
	switch (poke.getExpType()){
	case MEDIUM: 
		exp = (int)java.lang.Math.pow((double)level, 3);
		break;
	case ERRATIC: 
		double p = 0;
		switch (level % 3){
		case 0:
			p = 0;
			break;
		case 1:
			p = 0.008;
			break;
		case 2:
			p = 0.014;
			break;
		}
		if (level <= 50){
			exp = java.lang.Math.pow((double)level, 3) * ((100 - (double)level) / 50);
		} else if (level <= 68){
			exp = java.lang.Math.pow((double)level, 3) * ((150 - (double)level) / 50);
		} else if (level <= 98){
			exp = (java.lang.Math.pow((double)level, 3) *
					(1.274 - ((1/50) * ((double)level / 3)) - p));
		} else {
			exp = java.lang.Math.pow((double)level, 3) * ((160 - (double)level) / 50);
		}
		break;
	case FAST: 
		exp = 4 * java.lang.Math.pow((double)level, 3) / 5;
		break;
	case FLUCTUATING: 
		if (level <= 15){
			exp = java.lang.Math.pow((double)level, 3) * 
				((24 + (((double)level + 1) / 3)) / 50);
		} else if ((double)level <= 35){
			exp = java.lang.Math.pow((double)level, 3) * 
			((14 + (double)level) / 50);
		} else {
			exp = java.lang.Math.pow((double)level, 3) * 
			((32 + ((double)level / 2)) / 50);
		}    		
		break;
	case PARABOLIC: 
		exp = (6 * (java.lang.Math.pow((double)level, 3) / 5)) - 
		(15 * java.lang.Math.pow((double)level, 2)) + (100 * (double)level) - 140;
		break;
	case SLOW: 
		exp = 5 * java.lang.Math.pow((double)level, 3) / 4;;
		break;
	}
	return exp;
}","/**
 * Returns the amount of EXP required to reach a level
 * based on a monster's EXP type
 * @param poke
 * @param level
 * @return
 */
public double getExpForLevel(Monster poke, int level) 
{
    double exp = 0;
    switch(poke.getExpType())
    {
        case SLOW:
            exp = (4 * Math.pow(level, 3)) / 5;
            break;
        case MEDIUM_SLOW:
            exp = Math.pow(level, 3);
            break;
        case MEDIUM_FAST:
            exp = (6 * Math.pow(level, 3)) / 5 - 15 * Math.pow(level, 2) + 100 * level - 140;
            break;
        case FAST:
            exp = (8 * Math.pow(level, 3)) / 5;
            break;
    }
    return exp;
}   ",1002,False
"/**
 * Poison stays through switching out.
 */
public boolean switchOut(Monster p){
    m_turns = 1;
    return false;
}","/**
 * Poison stays through switching out.
 */
public boolean switchOut(Monster p) 
{
    if (p instanceof Poison)
    {
        return true;
    }
    return false;
}   ",1004,True
"/**
 * Returns a wild species for water
 * @return
 */
private String getWildSpeciesWater(){
	ArrayList<String> potentialSpecies = new ArrayList<String>();
	do {
		for (String species : m_waterMonsterChances.keySet()) {
			if (m_random.nextInt(101) < m_waterMonsterChances.get(species))
				potentialSpecies.add(species);
		}
	} while (potentialSpecies.size() <= 0);
	return potentialSpecies.get(m_random.nextInt(potentialSpecies.size()));
}","/**
 * Returns a wild species for water
 * @return
 */
private String getWildSpeciesWater() 
{
    String species = ""water"";
    return species;
}   ",1009,False
"/**
 * Starts an npc battle with the player if the player was challenged
 * @param p
 * @return
 */
public boolean isNpcBattle(PlayerChar p){
	NonPlayerChar n = null;
	for(int i = 0; i < m_npcs.size(); i++) {
		n = m_npcs.get(i);
		if(n != null && n.isTrainer() && !n.isGymLeader()) {
			/*
			 * For the npc to be able to challenge the player, the must be on the same
			 * axis as the player, the x axis or the y axis
			 */
			if(n.getX() == p.getX()) {
				/* Same column */
				if(n.getY() > p.getY()) {
					/* NPC is above the player */
					if(n.getFacing() == Direction.Up && n.canSee(p)) {
						NpcBattleLauncher l = new NpcBattleLauncher(n, p);
						l.start();
						return true;
					}
				} else {
					/* NPC is below the player */
					if(n.getFacing() == Direction.Down && n.canSee(p)) {
						NpcBattleLauncher l = new NpcBattleLauncher(n, p);
						l.start();
						return true;
					}
				}
			} else if(n.getY() == p.getY()) {
				/* Same row */
				if(n.getX() > p.getX()) {
					/* NPC is right of the player */
					if(n.getFacing() == Direction.Left && n.canSee(p)) {
						NpcBattleLauncher l = new NpcBattleLauncher(n, p);
						l.start();
						return true;
					}
				} else {
					/* NPC is left of the player */
					if(n.getFacing() == Direction.Right && n.canSee(p)) {
						NpcBattleLauncher l = new NpcBattleLauncher(n, p);
						l.start();
						return true;
					}
				}
			}
		}
	}
	return false;
}","/**
 * Starts an npc battle with the player if the player was challenged
 * @param p
 * @return
 */
public boolean isNpcBattle(PlayerChar p) 
{
    if (p.getNpcBattle() != null)
    {
        p.getNpcBattle().startBattle(p);
        return true;
    }
    return false;
}   ",1010,False
"/**
 * Allows a player to talk to the npc in front of them, if any
 * @param p
 */
public void talkToNpc(PlayerChar p){
	int x = 0, y = 0;
	switch(p.getFacing()) {
	case Up:
		x = p.getX();
		y = p.getY() - 32;
		break;
	case Down:
		x = p.getX();
		y = p.getY() + 32;
		break;
	case Left:
		x = p.getX() - 32;
		y = p.getY();
		break;
	case Right:
		x = p.getX() + 32;
		y = p.getY();
		break;
	default:
		break;
	}
	for(int i = 0; i < m_npcs.size(); i++) {
		if(m_npcs.get(i).getX() == x && m_npcs.get(i).getY() == y) {
			if (!(m_npcs.get(i) instanceof HMObject))
				p.setTalking(true);
			m_npcs.get(i).talkToPlayer(p);
			break;
		}
	}
}","/**
 * Allows a player to talk to the npc in front of them, if any
 * @param p
 */
public void talkToNpc(PlayerChar p) 
{
    Npc npc = p.getTile().getNpc();
    if (npc != null)
    {
        npc.talkTo(p);
    }
}   ",1011,True
"/**
 * Initialise the battle mechanics. Try to use the SecureRandom class for
 * the random number generator, with a seed from /dev/random. However, if
 * /dev/random is unavailable (e.g. if we are running on Windows) then an
 * instance of Random, seeded from the time, is used instead.
 *
 * For best results, use an operating system that supports /dev/random.
 */
public static Random getRandomSource(int bytes){
	try {
		return new SecureRandom(/*seed*/);
	} catch (Exception e) {
		System.out.println(""Could not use SecureRandom: "" + e.getMessage());
		return new Random();
	}
}","/**
 * Initialise the battle mechanics. Try to use the SecureRandom class for
 * the random number generator, with a seed from /dev/random. However, if
 * /dev/random is unavailable (e.g. if we are running on Windows) then an
 * instance of Random, seeded from the time, is used instead.
 *
 * For best results, use an operating system that supports /dev/random.
 */
public static Random getRandomSource(int bytes) 
{
    try
    {
        return new SecureRandom(new byte[bytes]);
    }
    catch (Exception e)
    {
        return new Random(System.currentTimeMillis());
    }
}   ",1012,True
"/**
 * Returns the weather id for the enforced weather on this map
 * @return
 */
public int getWeatherId(){
	if(m_forcedWeather != null) {
		switch(m_forcedWeather) {
		case NORMAL:
			return 0;
		case RAIN:
			return 1;
		case HAIL:
			return 2;
		case SANDSTORM:
			return 3;
		case FOG:
			return 4;
		default:
			return 0;
		}
	} else
		return 0;
}","/**
 * Returns the weather id for the enforced weather on this map
 * @return
 */
public int getWeatherId() 
{
    return weatherId;
}   ",1013,True
"/**
 * Returns a wild species for fishing
 * @return
 */
private String getWildSpeciesFish(){
	ArrayList<String> potentialSpecies = new ArrayList<String>();
	do {
		for (String species : m_fishMonsterChances.keySet()) {
			if (m_random.nextInt(101) < m_fishMonsterChances.get(species))
				potentialSpecies.add(species);
		}
	} while (potentialSpecies.size() <= 0);
	return potentialSpecies.get(m_random.nextInt(potentialSpecies.size()));
}","/**
 * Returns a wild species for fishing
 * @return
 */
private String getWildSpeciesFish() 
{
    int i = random.nextInt(2);
    switch (i)
    {
        case 0:
            return ""Salmon"";
        case 1:
            return ""Trout"";
        default:
            return ""Salmon"";
    }
}   ",1014,False
"/**
     * Sends a chat message to everyone of the same language
     * @param message
     * @param l
     */
public void sendChatMessage(String message, Language l){
            synchronized(m_players) {
                    Collection<PlayerChar> list = m_players.values();
                    for(PlayerChar p: list) {
                            if(p.getLanguage() == l) {
                                    TcpProtocolHandler.writeMessage(
                                                    p.getTcpSession(),
                                                    new ChatMessage(ChatMessageType.LOCAL, message));
                            }
                    }
            }
    }","/**
     * Sends a chat message to everyone of the same language
     * @param message
     * @param l
     */
public void sendChatMessage(String message, Language l) 
{
    for(Player p : players)
    {
        if(p.getLanguage() == l)
        {
            p.sendMessage(message);
        }
    }
}    ",1015,True
"/**
 * Returns true if the char is able to move
 * @param c
 * @param d
 */
public boolean moveChar(Char c, Direction d){
	int playerX = c.getX();
	int playerY = c.getY();
	int newX;
	int newY;

	switch(d) {
	case Up:
		newX = playerX / 32;
		newY = ((playerY + 8) - 32) / 32;
		if (playerY >= 1) {
			if (!isBlocked(newX, newY, Direction.Up)) {
				if(m_surf != null && m_surf.getTileAt(newX, newY) == '1') {
					if(c.isSurfing()) {
						return true;
					} else {
						if(c instanceof PlayerChar) {
							PlayerChar p = (PlayerChar) c;
							if(p.canSurf()) {
								p.setSurfing(true);
								return true;
							} else {
								return false;
							}
						}
					}
				} else {
					if(c.isSurfing())
						c.setSurfing(false);
					if(!isWarped(newX, newY, c))
						return true;
				}
			}
		} else {
			ServerMap newMap = m_mapMatrix.getMapByGamePosition(m_x, m_y - 1);
			if (newMap != null) {
				m_mapMatrix.moveBetweenMaps(c, this, newMap);
			}
		}
		break;
	case Down:
		newX = playerX / 32;
		newY = ((playerY + 8) + 32) / 32;
		if (playerY + 40 < m_heigth * 32) {
			if (!isBlocked(newX, newY, Direction.Down)) {
				if(m_surf != null && m_surf.getTileAt(newX, newY) == '1') {
					if(c.isSurfing()) {
						return true;
					} else {
						if(c instanceof PlayerChar) {
							PlayerChar p = (PlayerChar) c;
							if(p.canSurf()) {
								p.setSurfing(true);
								return true;
							} else {
								return false;
							}
						}
					}
				} else {
					if(c.isSurfing())
						c.setSurfing(false);
					if(!isWarped(newX, newY, c))
						return true;
				}
			}
		} else {
			ServerMap newMap = m_mapMatrix.getMapByGamePosition(m_x, m_y + 1);
			if (newMap != null) {
				m_mapMatrix.moveBetweenMaps(c, this, newMap);
			}
		}
		break;
	case Left:
		newX = (playerX - 32) / 32;
		newY = (playerY + 8) / 32;
		if (playerX >= 32) {
			if (!isBlocked(newX, newY, Direction.Left)) {
				if(m_surf != null && m_surf.getTileAt(newX, newY) == '1') {
					if(c.isSurfing()) {
						return true;
					} else {
						if(c instanceof PlayerChar) {
							PlayerChar p = (PlayerChar) c;
							if(p.canSurf()) {
								p.setSurfing(true);
								return true;
							} else {
								return false;
							}
						}
					}
				} else {
					if(c.isSurfing())
						c.setSurfing(false);
					if(!isWarped(newX, newY, c))
						return true;
				}
			}
		} else {
			ServerMap newMap = m_mapMatrix.getMapByGamePosition(m_x - 1, m_y);
			if (newMap != null) {
				m_mapMatrix.moveBetweenMaps(c, this, newMap);
			}
		}
		break;
	case Right:
		newX = (playerX + 32) / 32;
		newY = (playerY + 8) / 32;
		if (playerX + 32 < m_width * 32) {
			if (!isBlocked(newX, newY, Direction.Right)) {
				if(m_surf != null && m_surf.getTileAt(newX, newY) == '1') {
					if(c.isSurfing()) {
						return true;
					} else {
						if(c instanceof PlayerChar) {
							PlayerChar p = (PlayerChar) c;
							if(p.canSurf()) {
								p.setSurfing(true);
								return true;
							} else {
								return false;
							}
						}
					}
				} else {
					if(c.isSurfing())
						c.setSurfing(false);
					if(!isWarped(newX, newY, c))
						return true;
				}
			}
		} else {
			ServerMap newMap = m_mapMatrix.getMapByGamePosition(m_x + 1, m_y);
			if (newMap != null) {
				m_mapMatrix.moveBetweenMaps(c, this, newMap);
			}
		}
		break;
	}
	return false;
}","/**
 * Returns true if the char is able to move
 * @param c
 * @param d
 */
public boolean moveChar(Char c, Direction d) 
{
    if (c == null || d == null)
    {
        return false;
    }
    if (c instanceof Player)
    {
        return movePlayer((Player) c, d);
    }
    else if (c instanceof Enemy)
    {
        return moveEnemy((Enemy) c, d);
    }
    return false;
}   ",1016,False
"/**
 * Default constructor
 * @param map
 * @param x
 * @param y
 */
public ServerMap(Map map, int x, int y){
	m_x = x;
	m_y = y;
	m_heigth = map.getHeight();
	m_width = map.getWidth();
	/*
	 * Store all the map layers
	 */
	for(int i = 0; i < map.getTotalLayers(); i++) {
		if(map.getLayer(i).getName().equalsIgnoreCase(""Grass"")) {
			m_grass = new ServerTileLayer((TileLayer) map.getLayer(i));
		} else if(map.getLayer(i).getName().equalsIgnoreCase(""Collisions"")) {
			m_blocked = new ServerTileLayer((TileLayer) map.getLayer(i));
		} else if(map.getLayer(i).getName().equalsIgnoreCase(""LedgesLeft"")) {
			m_ledgesLeft = new ServerTileLayer((TileLayer) map.getLayer(i));
		} else if(map.getLayer(i).getName().equalsIgnoreCase(""LedgesRight"")) {
			m_ledgesRight = new ServerTileLayer((TileLayer) map.getLayer(i));
		} else if(map.getLayer(i).getName().equalsIgnoreCase(""LedgesDown"")) {
			m_ledgesDown = new ServerTileLayer((TileLayer) map.getLayer(i));
		} else if(map.getLayer(i).getName().equalsIgnoreCase(""Water"")) {
			m_surf = new ServerTileLayer((TileLayer) map.getLayer(i));
		}
	}
	
	m_players = new HashMap<String, PlayerChar>();
	m_npcs = new ArrayList<NonPlayerChar>();
	
	/*
	 * Load pvp settings
	 */
	try {
		String type = map.getProperties().getProperty(""pvp"");
		if(type.equalsIgnoreCase(""disabled"")) {
			m_pvpType = PvPType.DISABLED;
		} else if(type.equalsIgnoreCase(""enabled"")) {
			m_pvpType = PvPType.ENABLED;
		} else {
			m_pvpType = PvPType.ENFORCED;
		}
	} catch (Exception e) {
		m_pvpType = PvPType.ENABLED;
	}
	
	/*
	 * Add enforced weather if any
	 */
	try {
		if(x < -30) {
			if(x != -49 || y != -3) {
				m_forcedWeather = Weather.NORMAL;
			}
			else if(x!= -36 || y != -49) {
				   m_forcedWeather = Weather.NORMAL;
				}
		} else if(map.getProperties().getProperty(""forcedWeather"") != null && 
				!map.getProperties().getProperty(""forcedWeather"").equalsIgnoreCase("""")) {
			m_forcedWeather = Weather.valueOf(map.getProperties().getProperty(""forcedWeather""));
		}
	} catch (Exception e) {
		m_forcedWeather = null;
	}
	
	/*
	 * Load offsets
	 */
	try {
		m_xOffsetModifier = Integer.parseInt(map.getProperties().getProperty(""xOffsetModifier""));
	} catch (Exception e) {
		m_xOffsetModifier = 0;
	}
	try {
		m_yOffsetModifier = Integer.parseInt(map.getProperties().getProperty(""yOffsetModifier""));
	} catch (Exception e) {
		m_yOffsetModifier = 0;
	}
	
	/*
	 * Load wild monsters
	 */
	try {
		if(!map.getProperties().getProperty(""wildProbabilty"").equalsIgnoreCase("""")) {
			m_wildProbability = Integer.parseInt(map.getProperties().getProperty(""wildProbabilty""));
		} else {
			m_wildProbability = 28;
		}
	} catch (Exception e) {
		m_wildProbability = 28;
	}
	
	String[] species;
	String[] levels;
	//Daytime monsters
	try {
		if(!map.getProperties().getProperty(""dayPokemonChances"").equalsIgnoreCase("""")) {
			species = map.getProperties().getProperty(""dayPokemonChances"").split("";"");
			levels = map.getProperties().getProperty(""dayPokemonLevels"").split("";"");
			if (!species[0].equals("""") && !levels[0].equals("""") && species.length == levels.length) {
				m_dayMonsterChances = new HashMap<String, Integer>();
				m_dayMonsterLevels = new HashMap<String, int[]> ();
					for (int i = 0; i < species.length; i++) {
						String[] speciesInfo = species[i].split("","");
						m_dayMonsterChances.put(speciesInfo[0], Integer.parseInt(speciesInfo[1]));
						String[] levelInfo = levels[i].split(""-"");
						m_dayMonsterLevels.put(speciesInfo[0], new int[] {
								Integer.parseInt(levelInfo[0]),
								Integer.parseInt(levelInfo[1]) });
					}
			}
		}
	} catch (Exception e) {
		m_dayMonsterChances = null;
		m_dayMonsterLevels = null;
		species = new String[] { """" };
		levels = new String[] { """" };
	}
	//Nocturnal Monsters
	try {
		if(!map.getProperties().getProperty(""nightMonsterChances"").equalsIgnoreCase("""")) {
			species = map.getProperties().getProperty(""nightMonsterChances"").split("";"");
			levels = map.getProperties().getProperty(""nightMonsterLevels"").split("";"");
			if (!species[0].equals("""") && !levels[0].equals("""") && species.length == levels.length) {
				m_nightMonsterChances = new HashMap<String, Integer>();
				m_nightMonsterLevels = new HashMap<String, int[]> ();
					for (int i = 0; i < species.length; i++) {
						String[] speciesInfo = species[i].split("","");
						m_nightMonsterChances.put(speciesInfo[0], Integer.parseInt(speciesInfo[1]));
						String[] levelInfo = levels[i].split(""-"");
						m_nightMonsterLevels.put(speciesInfo[0], new int[] {
								Integer.parseInt(levelInfo[0]),
								Integer.parseInt(levelInfo[1]) });
					}
			}
		}
	} catch (Exception e) {
		m_nightMonsterChances = null;
		m_nightMonsterLevels = null;
		species = new String[] { """" };
		levels = new String[] { """" };
	}
	//Surf Pokemon
	try {
		if(!map.getProperties().getProperty(""waterMonsterChances"").equalsIgnoreCase("""")) {
			species = map.getProperties().getProperty(""waterMonsterChances"").split("";"");
			levels = map.getProperties().getProperty(""waterMonsterLevels"").split("";"");
			if (!species[0].equals("""") && !levels[0].equals("""") && species.length == levels.length) {
				m_waterMonsterChances = new HashMap<String, Integer>();
				m_waterMonsterLevels = new HashMap<String, int[]> ();
					for (int i = 0; i < species.length; i++) {
						String[] speciesInfo = species[i].split("","");
						m_waterMonsterChances.put(speciesInfo[0], Integer.parseInt(speciesInfo[1]));
						String[] levelInfo = levels[i].split(""-"");
						m_waterMonsterLevels.put(speciesInfo[0], new int[] {
								Integer.parseInt(levelInfo[0]),
								Integer.parseInt(levelInfo[1]) });
					}
			}
		}
	} catch (Exception e) {
		m_waterMonsterChances = null;
		m_waterMonsterLevels = null;
		species = new String[] { """" };
		levels = new String[] { """" };
	}
	//Fish Pokemon
	try {
		if(!map.getProperties().getProperty(""fishMonsterChances"").equalsIgnoreCase("""")) {
			species = map.getProperties().getProperty(""fishMonsterChances"").split("";"");
			levels = map.getProperties().getProperty(""fishMonsterLevels"").split("";"");
			if (!species[0].equals("""") && !levels[0].equals("""") && species.length == levels.length) {
				m_fishMonsterChances = new HashMap<String, Integer>();
				m_fishMonsterLevels = new HashMap<String, int[]> ();
					for (int i = 0; i < species.length; i++) {
						String[] speciesInfo = species[i].split("","");
						m_fishMonsterChances.put(speciesInfo[0], Integer.parseInt(speciesInfo[1]));
						String[] levelInfo = levels[i].split(""-"");
						m_fishMonsterLevels.put(speciesInfo[0], new int[] {
								Integer.parseInt(levelInfo[0]),
								Integer.parseInt(levelInfo[1]) });
					}
			}
		}
	} catch (Exception e) {
		m_fishMonsterChances = null;
		m_fishMonsterLevels = null;
		species = new String[] { """" };
		levels = new String[] { """" };
	}
}","/**
 * Default constructor
 * @param map
 * @param x
 * @param y
 */
public ServerMap(Map map, int x, int y) 
{
    this.map = map;
    this.x = x;
    this.y = y;
}   ",1017,False
"/**
 * Sends a packet to all players on the map
 * @param message
 */
public void sendToAll(K3RNELMessage m){
	synchronized(m_players) {
		Collection<PlayerChar> list = m_players.values();
		for(PlayerChar p: list) {
			TcpProtocolHandler.writeMessage(p.getTcpSession(), m);
		}
	}
}","/**
 * Sends a packet to all players on the map
 * @param message
 */

public void sendToAll(K3RNELMessage m) 
{
	for (int i = 0; i < players.size(); i++)
	{
		players.get(i).send(m);
	}
}   ",1018,True
"/**
 * Execute a generic command, which includes parsing the options for the
 * command and running the specific task.
 *
 * @param tokens - command arguments
 * @throws Exception
 */
public void execute(List<String> tokens) throws Exception{
    // Parse the options specified by ""-""
    parseOptions(tokens);

    if (isPrintHelp) {
        // Print the help file of the task
        printHelp();
    } else {
        // Run the specified task
        runTask(tokens);
    }
}","/**
 * Execute a generic command, which includes parsing the options for the
 * command and running the specific task.
 *
 * @param tokens - command arguments
 * @throws Exception
 */
public void execute(List<String> tokens) throws Exception 
{
    try
    {
        parseOptions(tokens);
        run();
    }
    catch (Exception e)
    {
        throw e;
    }
}   ",1020,True
"// big endian
public static int getInt(byte[] stream, int offset){
	return (((stream[offset] & 0x000000FF) << 24) | ((stream[offset + 1] & 0x000000FF) << 16) |
			((stream[offset + 2] & 0x000000FF) << 8) | (stream[offset + 3] & 0x000000FF));
}","// big endian
public static int getInt(byte[] stream, int offset) 
{
    int n = 0;
    for (int i = 0; i < 4; i++)
    {
        n <<= 8;
        n |= (stream[offset + i] & 0xFF);
    }
    return n;
}   ",1021,True
"/**
 * Parses for specific command task.
 *
 * @param tokens - command arguments
 * @throws Exception
 */
protected void runTask(List<String> tokens) throws Exception{

    // Process task token
    if (tokens.size() > 0) {
        Command command=null;
        String taskToken = tokens.remove(0);
        if (taskToken.equals(""start"")) {
            command = new StartCommand();
        } else if (taskToken.equals(""stop"")) {
            command = new ShutdownCommand();
        } else if (taskToken.equals(""help"")) {
            printHelp();
        } else {
            printHelp();
        }

        if( command!=null ) {
            command.execute(tokens);
        }
    } else {
        printHelp();
    }

}","/**
 * Parses for specific command task.
 *
 * @param tokens - command arguments
 * @throws Exception
 */
protected void runTask(List<String> tokens) throws Exception 
{
    if (tokens.size() < 1)
    {
        throw new Exception(""Invalid arguments"");
    }

    String command = tokens.get(0);
    if (command.equals(""add""))
    {
        this.runAdd(tokens);
    }
    else if (command.equals(""remove""))
    {
        this.runRemove(tokens);
    }
    else if (command.equals(""list""))
    {
        this.runList(tokens);
    }
    else if (command.equals(""help""))
    {
        this.runHelp(tokens);
    }
    else
    {
        throw new Exception(""Invalid command"");
    }
}   ",1022,True
"//getStringʽʱı
public static CharsetDecoder toDecoder(){
	Charset charset = Charset.forName(""gb2312"");
		return charset.newDecoder();
	}","//getStringʽʱı

public static CharsetDecoder toDecoder() 
{
    if (decoder == null)
    {
        decoder = Charset.forName(""UTF-8"").newDecoder();
    }
    return decoder;
}   ",1023,True
"/**
 * ճЭָ
 * @param msg ָ
 * @param fmt Ÿʽ
 * @return ָֽ֮б
 */
public static List<byte[]> splitLongMsg(String msg, int fmt){
		int max_length = LONG_MAXLENGTH;
		if (fmt == MessageConst.MSGFMT_ASCII)
			max_length = ASCII_MAXLENGTH;
		
		List<byte[]> result = new ArrayList<byte[]>();
		
		byte[] gbMsg = null;
		try {
			gbMsg = msg.getBytes(ENCODING);
		} catch (UnsupportedEncodingException e) {
		}
		
		if (gbMsg.length > max_length) {
			byte r = (byte) new Random().nextInt(256);
			byte[] header = new byte[] {0x05, 0x00, 0x03, r, 0x00, 0x00};
			// ָĳ
			int splitLen = max_length-header.length;
			
			byte[] ucs2Msg = null;
			try {
				ucs2Msg = msg.getBytes(UCS2_ENCODING);
			} catch (UnsupportedEncodingException e) {
				e.printStackTrace();
			}
			int size = ucs2Msg.length/splitLen + (ucs2Msg.length%splitLen == 0 ? 0 : 1);
			for (int i=0; i < size; i++) {
				// ȥֽںʣֽ
				int remainLen = ucs2Msg.length - i*splitLen;
				// i+1εĳ
				int len = header.length + (remainLen > splitLen ? splitLen : remainLen);
				byte[] b = new byte[len];
				
				header[header.length-2] = (byte) size;
				header[header.length-1] = (byte) (i+1);
				
				System.arraycopy(header, 0, b, 0, header.length);
				System.arraycopy(ucs2Msg, i*splitLen, b, header.length, b.length-header.length);
				result.add(b);
			}
		} else {
			result.add(gbMsg);
		}
		
		return result;
	}","/**
 * ճЭָ
 * @param msg ָ
 * @param fmt Ÿʽ
 * @return ָֽ֮б
 */


public static List<byte[]> splitLongMsg(String msg, int fmt) 
{
    List<byte[]> result = new ArrayList<byte[]>();
    byte[] data = msg.getBytes();
    int len = data.length;
    int count = (len + fmt - 1) / fmt;
    for (int i = 0; i < count; i++)
    {
        int start = i * fmt;
        int end = Math.min(start + fmt, len);
        result.add(Arrays.copyOfRange(data, start, end));
    }
    return result;
}   ",1026,True
"/**
 * ȴ0
 * @param wait ȴʱ䣬λ
 * @return {@code true} if the count reached zero and {@code false}
 *         if the waiting time elapsed before the count reached zero
 * @throws InterruptedException if the current thread is interrupted
 *         while waiting
 */
public synchronized boolean await(long wait) throws InterruptedException{
    boolean timeout = false;
    long remaining = wait;
    long start = System.currentTimeMillis();        

    while (count > 0 && !timeout) {
        wait(remaining);
        long elapsed = System.currentTimeMillis() - start;
        remaining = wait - elapsed;
        timeout = remaining <= 0;
    }

    return !timeout;
}","/**
 * ȴ0
 * @param wait ȴʱ䣬λ
 * @return {@code true} if the count reached zero and {@code false}
 *         if the waiting time elapsed before the count reached zero
 * @throws InterruptedException if the current thread is interrupted
 *         while waiting
 */
public synchronized boolean await(long wait) throws InterruptedException 
{
    while (count > 0)
    {
        wait(wait);
        if (count > 0)
        {
            return false;
        }
    }
    return true;
}   ",1028,True
"/**
 * @see java.lang.Object#hashCode()
 */
public int hashCode(){
	return new HashCodeBuilder(-2038111737, 1780350343).appendSuper(
			super.hashCode()).append(this.serviceCode)
			.append(this.provider.getId())
			.toHashCode();
}","/**
 * @see java.lang.Object#hashCode()
 */
public int hashCode() 
{
    int result = 17;
    result = 37 * result + (int) (Double.doubleToLongBits(x) ^ (Double.doubleToLongBits(x) >>> 32));
    result = 37 * result + (int) (Double.doubleToLongBits(y) ^ (Double.doubleToLongBits(y) >>> 32));
    return result;
}   ",1029,True
"/**
 * Handle the --all option.
 *
 * @param token - option token to handle
 * @param tokens - succeeding command arguments
 * @throws Exception
 */
protected void handleOption(String token, List<String> tokens) throws Exception{
    // Try to handle the options first
    if (token.equals(""--all"")) {
        isStopAllClients = true;
    } else {
        // Let the super class handle the option
        super.handleOption(token, tokens);
    }
}","/**
 * Handle the --all option.
 *
 * @param token - option token to handle
 * @param tokens - succeeding command arguments
 * @throws Exception
 */
protected void handleOption(String token, List<String> tokens) throws Exception 
{
    if (token.equals(""--all""))
    {
        handleAllOption();
    }
    else
    {
        super.handleOption(token, tokens);
    }
}   ",1030,False
"//Object תΪbyte[]
public static byte[] ObjectToByteArray(Object s) throws IOException{
	ByteArrayOutputStream byteStream = new ByteArrayOutputStream(20000000);
		ObjectOutputStream os = new ObjectOutputStream (new BufferedOutputStream(byteStream));
		os.writeObject(s);
		os.flush();
		byte[] buf  = byteStream.toByteArray();
		os.close();
		return buf;
	}","//Object תΪbyte[]

public static byte[] ObjectToByteArray(Object s) throws IOException 
{
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    ObjectOutputStream oos = new ObjectOutputStream(baos);
    oos.writeObject(s);
    oos.flush();
    return baos.toByteArray();
}   ",1032,False
"// ֺĶǰ(1/5)಻ܳ9
public static void main(String[] args) throws Exception{
       String orig = ""GB2312 ǺַͱĴţȫΪϢúֱַл񹲺͹"" +
               ""ұ׼ַܾһŰһһʵʩGB ǡꡱ ֵĺƴдGB2312 ַ (character set) ֻ¼ֺ֣Լһ㳣ĸͷţҪͨй½¼µȵء"";
       List<byte[]> lst = splitSimpleMsg(orig, MessageConst.MSGFMT_GB);

       for (byte[] b : lst) {
           System.out.println((new String(b, ""GB2312"")) + "", bytes: "" + b.length);
       }
   }","// ֺĶǰ(1/5)಻ܳ9
public static void main(String[] args) throws Exception 
{
    int i = 0;
    while (i < 5)
    {
        System.out.println(""������(1/5)����9"");
        i++;
    }
}   ",1036,False
"/**
 * Parse any option parameters in the command arguments specified by a '-'
 * as the first character of the token.
 *
 * @param tokens - command arguments
 * @throws Exception
 */
protected void parseOptions(List<String> tokens) throws Exception{
    while (!tokens.isEmpty()) {
        String token = tokens.remove(0);
        if (token.startsWith(""-"")) {
            // Token is an option
            handleOption(token, tokens);
        } else {
            // Push back to list of tokens
            tokens.add(0, token);
            return;
        }
    }
}","/**
 * Parse any option parameters in the command arguments specified by a '-'
 * as the first character of the token.
 *
 * @param tokens - command arguments
 * @throws Exception
 */
protected void parseOptions(List<String> tokens) throws Exception 
{
    List<String> newTokens = new ArrayList<String>();
    for (String token : tokens)
    {
        if (token.startsWith(""-""))
        {
            parseOption(token);
        }
        else
        {
            newTokens.add(token);
        }
    }
    tokens.clear();
    tokens.addAll(newTokens);
}   ",1039,True
"/**
	 * Translates from a byte to its corresponding
	 * message type value.
	 * @param type The enumerated type representation of the type of message.
	 * @return The byte representation of the type of message.
	 */
public static byte getMessageType(MessageType type){
		byte message;

		switch (type) {
			case PlayerMotion:
				message = PLAYER_MOTION;
				break;
			case MapChange:
				message = MAP_CHANGE;
				break;
			case ScoreUpdate:
				message = SCORE_UPDATE;
				break;
			case HealthUpdate:
				message = HEALTH_UPDATE;
				break;
			case Chat:
				message = CHAT_MESSAGE;
				break;
			case Death:
				message = DEATH_MESSAGE;
				break;
        case Login:
            message = LOGIN_MESSAGE;
            break;
        case PlayerJoin:
            message = PLAYER_JOIN;
            break;
        case PlayerLeave:
            message = PLAYER_LEAVE;
            break;
        case MulticastGroup:
            message = MULTI_MESSAGE;
            break;
        case Projectile:
            message = PJTILE_MESSAGE;
            break;
			default:
				message = UNDEFINED;
		}
		return message;
}","/**
	 * Translates from a byte to its corresponding
	 * message type value.
	 * @param type The enumerated type representation of the type of message.
	 * @return The byte representation of the type of message.
	 */
public static byte getMessageType(MessageType type) 
{
	switch (type)
	{
		case CHAT:
			return 0;
		case HANDSHAKE:
			return 1;
		case HANDSHAKE_RESPONSE:
			return 2;
		case ERROR:
			return 3;
		default:
			return -1;
	}
}	",1040,False
"/**
 * Start or restart the server.
 */
public void Start() throws SocketException{
    Stop();
    for (int i = 0; i < fListeners.size(); i++)
    {
        ((UDPListener) fListeners.get(i)).Start();
    }
}","/**
 * Start or restart the server.
 */

public void Start() throws SocketException 
{
    if (this.serverSocket == null)
    {
        this.serverSocket = new ServerSocket(this.port);
    }
    else
    {
        throw new IllegalStateException(""Server is already running"");
    }
}   ",1045,False
"/**
 * Dispose the server.
 * This method stops the server and disposes all the active members of this 
 * class. After calling this method you cannot re-start the server.
 */
public void Dispose(){
    Stop();
    fMyThreadPool.shutdown();
}","/**
 * Dispose the server.
 * This method stops the server and disposes all the active members of this 
 * class. After calling this method you cannot re-start the server.
 */
public void Dispose() 
{
    if (this.server != null)
    {
        this.server.Stop();
        this.server.Dispose();
        this.server = null;
    }
}   ",1047,True
"/**
 * Constructs a new Extasys UDP Server.
 * @param name is the name of the server.
 * @param description is the description of the server.
 * @param corePoolSize is the number of threads to keep in the pool, even if they are idle.
 * @param maximumPoolSize is the maximum number of threads to allow in the pool.
 */
public ExtasysUDPServer(String name, String description, int corePoolSize, int maximumPoolSize){
    fName = name;
    fDescription = description;
    fMyThreadPool = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, 2, TimeUnit.SECONDS, fThreadPoolQueue);
}","/**
 * Constructs a new Extasys UDP Server.
 * @param name is the name of the server.
 * @param description is the description of the server.
 * @param corePoolSize is the number of threads to keep in the pool, even if they are idle.
 * @param maximumPoolSize is the maximum number of threads to allow in the pool.
 */


public ExtasysUDPServer(String name, String description, int corePoolSize, int maximumPoolSize) 
{
    fName = name;
    fDescription = description;
    fCorePoolSize = corePoolSize;
    fMaximumPoolSize = maximumPoolSize;
    fThreadPool = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
}   ",1048,True
"/**
     * Constructor - Creates a new message.
     * @param type The type of message
     */
protected Message(MessageType type, byte playerId, int dataLength,
              boolean isAck){
header = new Header(type,DefaultGameId,playerId,isAck);
this.dataLength = dataLength;
    }","/**
     * Constructor - Creates a new message.
     * @param type The type of message
     */
protected Message(MessageType type, byte playerId, int dataLength,
              boolean isAck) 
{
    this.type = type;
    this.playerId = playerId;
    this.dataLength = dataLength;
    this.isAck = isAck;
}    ",1049,True
"/**
 * Stops and removes a UDP listener from this server.
 * @param name is the name of the UDP listener.
 */
public void RemoveListener(String name){
    for (int i = 0; i < fListeners.size(); i++)
    {
        if (((UDPListener) fListeners.get(i)).getName().equals(name))
        {
            ((UDPListener) fListeners.get(i)).Stop();
            fListeners.remove(i);
            break;
        }
    }
}","/**
 * Stops and removes a UDP listener from this server.
 * @param name is the name of the UDP listener.
 */
public void RemoveListener(String name) 
{
    if (this.listeners.containsKey(name))
    {
        this.listeners.get(name).Stop();
        this.listeners.remove(name);
    }
}   ",1051,True
"/**
 * Returns the total bytes received from this server.
 * @return the total bytes received from this server.
 */
public int getBytesIn(){
    int bytesIn = 0;
    try
    {
        for (int i = 0; i < fListeners.size(); i++)
        {
            try
            {
                bytesIn += ((UDPListener) fListeners.get(i)).getBytesIn();
            }
            catch (Exception ex)
            {
            }
        }
    }
    catch (Exception ex)
    {
    }
    return bytesIn;
}","/**
 * Returns the total bytes received from this server.
 * @return the total bytes received from this server.
 */
public int getBytesIn() 
{
    return bytesIn;
}   ",1053,False
"// Called when the mouse button is released
public void mouseReleased(MouseEvent e){
	if (e.getButton() != MouseEvent.BUTTON1) return;
	
	for (Widget w : widgetList)
	{
		if (!(w instanceof InteractiveWidget)) continue;
		InteractiveWidget iw = (InteractiveWidget) w;
		if (iw.getState() == InteractiveWidget.STATE_HOVERED) iw.trigger(e.getButton());
		iw.setState(InteractiveWidget.STATE_READY);
	}
}","// Called when the mouse button is released

public void mouseReleased(MouseEvent e) 
{
    if (e.getButton() == MouseEvent.BUTTON1)
    {
        leftDown = false;
    }
    else if (e.getButton() == MouseEvent.BUTTON3)
    {
        rightDown = false;
    }
}   ",1054,False
"/**
 * Returns the total bytes send from this server.
 * @return the total bytes send from this server.
 */
public int getBytesOut(){
    int bytesOut = 0;
    try
    {
        for (int i = 0; i < fListeners.size(); i++)
        {
            try
            {
                bytesOut += ((UDPListener) fListeners.get(i)).getBytesOut();
            }
            catch (Exception ex)
            {
            }
        }
    }
    catch (Exception ex)
    {
    }
    return bytesOut;
}","/**
 * Returns the total bytes send from this server.
 * @return the total bytes send from this server.
 */
public int getBytesOut() 
{
    return bytesOut;
}   ",1055,False
"/*
 * Allow the logger level to be set as a command-line paramater.
 * The default logger level is CONFIG by default.
 */
public static void initialiseLogger(String[] args){
	// Server application logging
  logger = Logger.getLogger(SERVER_LOGGER_NAME);

  // Get the log level from the command-line if one is supplied
  if (args.length > 0) {
    /*
     * Logger levels:
       * SEVERE (highest value)
       * WARNING
       * INFO
       * CONFIG
       * FINE
       * FINER
       * FINEST (lowest value)
     */

    String level = args[0].trim().toUpperCase();

    if (level.equals(""SEVERE"")) {
      logger.setLevel(Level.SEVERE);
    }
    else if (level.equals(""WARNING"")) {
      logger.setLevel(Level.WARNING);
    }
    else if (level.equals(""INFO"")) {
      logger.setLevel(Level.INFO);
    }
    else if (level.equals(""CONFIG"")) {
      logger.setLevel(Level.CONFIG);
    }
    else if (level.equals(""FINE"")) {
      logger.setLevel(Level.FINE);
    }
    else if (level.equals(""FINER"")) {
      logger.setLevel(Level.FINER);
    }
    else if (level.equals(""FINEST"")) {
      logger.setLevel(Level.FINEST);
    }
  }
  else {
    // Set the default log level if it is not specified
    logger.setLevel(Level.CONFIG);
  }

  try {
    logger.addHandler(new FileHandler(SERVER_LOG_PATH));
  }
  catch (IOException e) {
    e.printStackTrace();
	}
}","/*
 * Allow the logger level to be set as a command-line paramater.
 * The default logger level is CONFIG by default.
 */
public static void initialiseLogger(String[] args) 
{
    Level logLevel = Level.CONFIG;
    if (args.length > 0)
    {
        if (args[0].equalsIgnoreCase(""-debug""))
            logLevel = Level.FINE;
    }
    Logger.getLogger("""").setLevel(logLevel);
}   ",1056,True
"/** Creates new form OperatorConsole */
public OperatorConsole(){
    initComponents();
    setLocationRelativeTo(null);
    LoadPendingTickets();   

}","/** Creates new form OperatorConsole */
public OperatorConsole() 
{
    initComponents();
    this.setTitle(""Operator Console"");
    this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    this.setLocationRelativeTo(null);
    this.setVisible(true);
}   ",1061,True
"/**
 * Back up one character. This provides a sort of lookahead capability,
 * so that you can test for a digit or letter before attempting to parse
 * the next number or identifier.
 */
public void back() throws JSONException{
    if (useLastChar || index <= 0) {
        throw new JSONException(""Stepping back two steps is not supported"");
    }
    index -= 1;
    useLastChar = true;
}","/**
 * Back up one character. This provides a sort of lookahead capability,
 * so that you can test for a digit or letter before attempting to parse
 * the next number or identifier.
 */
public void back() throws JSONException 
{
    pos--;
}   ",1062,True
"/**
 * Returns the next XML meta token. This is used for skipping over <!...>
 * and <?...?> structures.
 * @return Syntax characters (<code>< > / = ! ?</code>) are returned as
 *  Character, and strings and names are returned as Boolean. We don't care
 *  what the values actually are.
 * @throws JSONException If a string is not properly closed or if the XML
 *  is badly structured.
 */
public Object nextMeta() throws JSONException{
    char c;
    char q;
    do {
        c = next();
    } while (Character.isWhitespace(c));
    switch (c) {
    case 0:
        throw syntaxError(""Misshaped meta tag"");
    case '<':
        return XML.LT;
    case '>':
        return XML.GT;
    case '/':
        return XML.SLASH;
    case '=':
        return XML.EQ;
    case '!':
        return XML.BANG;
    case '?':
        return XML.QUEST;
    case '""':
    case '\'':
        q = c;
        for (;;) {
            c = next();
            if (c == 0) {
                throw syntaxError(""Unterminated string"");
            }
            if (c == q) {
                return Boolean.TRUE;
            }
        }
    default:
        for (;;) {
            c = next();
            if (Character.isWhitespace(c)) {
                return Boolean.TRUE;
            }
            switch (c) {
            case 0:
            case '<':
            case '>':
            case '/':
            case '=':
            case '!':
            case '?':
            case '""':
            case '\'':
                back();
                return Boolean.TRUE;
            }
        }
    }
}","/**
 * Returns the next XML meta token. This is used for skipping over <!...>
 * and <?...?> structures.
 * @return Syntax characters (<code>< > / = ! ?</code>) are returned as
 *  Character, and strings and names are returned as Boolean. We don't care
 *  what the values actually are.
 * @throws JSONException If a string is not properly closed or if the XML
 *  is badly structured.
 */
public Object nextMeta() throws JSONException 
{
    char c;
    do
    {
        c = next();
        if (c == 0)
        {
            throw syntaxError(""Unexpected EOF"");
        }
    }
    while (c != '<' && c != '>' && c != '!' && c != '?' && c != '/');
    switch (c)
    {
        case '<':
            return '<';
        case '>':
            return '>';
        case '!':
            return !nextMeta();
        case '?':
            return nextXML();
        case '/':
            return '/';
    }
    return nextString(c);
}   ",1063,False
"/**
 * Get the next XML outer token, trimming whitespace. There are two kinds
 * of tokens: the '<' character which begins a markup tag, and the content
 * text between markup tags.
 *
 * @return  A string, or a '<' Character, or null if there is no more
 * source text.
 * @throws JSONException
 */
public Object nextContent() throws JSONException{
    char         c;
    StringBuffer sb;
    do {
        c = next();
    } while (Character.isWhitespace(c));
    if (c == 0) {
        return null;
    }
    if (c == '<') {
        return XML.LT;
    }
    sb = new StringBuffer();
    for (;;) {
        if (c == '<' || c == 0) {
            back();
            return sb.toString().trim();
        }
        if (c == '&') {
            sb.append(nextEntity(c));
        } else {
            sb.append(c);
        }
        c = next();
    }
}","/**
 * Get the next XML outer token, trimming whitespace. There are two kinds
 * of tokens: the '<' character which begins a markup tag, and the content
 * text between markup tags.
 *
 * @return  A string, or a '<' Character, or null if there is no more
 * source text.
 * @throws JSONException
 */
public Object nextContent() throws JSONException 
{
    char c;
    StringBuffer sb;
    do
    {
        c = next();
    } while (Character.isWhitespace(c));
    if (c == 0)
    {
        return null;
    }
    if (c == '<')
    {
        return Character.valueOf('<');
    }
    sb = new StringBuffer();
    for (; ; )
    {
        sb.append(c);
        c = next();
        if (Character.isWhitespace(c) || c == 0 || c == '<')
        {
            break;
        }
    }
    return sb.toString();
}   ",1064,True
"/**
 * This function aids loading of pending tickets from an array of tickets.
 */
public void LoadPendingTickets(){
     try{

    header = new Vector();
    header.add(""TicketID"");
    header.add(""StartTime"");
    header.add(""Query"");
    header.add(""Answer"");
    header.add(""Caller"");
    header.add(""Status"");

    dataRows = new Vector<Vector<String>>(); // Vector of rows
    
     
     ArrayList<Ticket> tickets  = Ticket.getPendingTickets(StaticMain.loggedinuser.getUserid());

      for( Ticket ticket : tickets)
       {
          Vector<String> cells = new Vector<String>();
          cells.add(Long.toString(ticket.getTicketid()));
          cells.add(ticket.getStartTime().toString());
          cells.add(Query.getQuery(ticket.getQueryid()).getDetails());
          cells.add(Answer.getAnswer(ticket.getAnserid()).getDetails());
          User user = User.getUser(ticket.getCallerid());
          cells.add(user.getFname()+ ""  "" + user.getLname());
          cells.add(Status.getStatus(ticket.getStatusid()).getDescr());
          dataRows.add(cells);

       }

       tbPendingTickets.setModel(new javax.swing.table.DefaultTableModel( dataRows,header));
     //  tbPendingTickets.setDefaultRenderer(Object.class, new MultiLineCellRenderer());


    } catch (Exception e) {

        System.out.println(e.getMessage());
        JOptionPane.showMessageDialog(this, ""Loading pending users failed!\n"", ""Error"", JOptionPane.ERROR_MESSAGE);
    }
}","/**
 * This function aids loading of pending tickets from an array of tickets.
 */
public void LoadPendingTickets() 
{
    // Iterate through the array of pending tickets
    for (int i = 0; i < pendingTickets.length; i++)
    {
        // Check if the current ticket is not null
        if (pendingTickets[i] != null)
        {
            // Load the ticket into the system
            LoadTicket(pendingTickets[i]);
        }
    }
}   ",1065,False
"/**
 * Get the text up but not including the specified character or the
 * end of line, whichever comes first.
 * @param  d A delimiter character.
 * @return   A string.
 */
public String nextTo(char d) throws JSONException{
    StringBuffer sb = new StringBuffer();
    for (;;) {
        char c = next();
        if (c == d || c == 0 || c == '\n' || c == '\r') {
            if (c != 0) {
                back();
            }
            return sb.toString().trim();
        }
        sb.append(c);
    }
}","/**
 * Get the text up but not including the specified character or the
 * end of line, whichever comes first.
 * @param  d A delimiter character.
 * @return   A string.
 */
public String nextTo(char d) throws JSONException 
{
    int start = this.pos;
    int end = this.text.indexOf(d, this.pos);
    if (end == -1)
    {
        end = this.text.length();
    }
    this.pos = end + 1;
    return this.text.substring(start, end);
}   ",1066,False
"/**
 * Return the characters up to the next close quote character.
 * Backslash processing is done. The formal JSON format does not
 * allow strings in single quotes, but an implementation is allowed to
 * accept them.
 * @param quote The quoting character, either
 *      <code>""</code>&nbsp;<small>(double quote)</small> or
 *      <code>'</code>&nbsp;<small>(single quote)</small>.
 * @return      A String.
 * @throws JSONException Unterminated string.
 */
public String nextString(char quote) throws JSONException{
    char c;
    StringBuffer sb = new StringBuffer();
    for (;;) {
        c = next();
        switch (c) {
        case 0:
        case '\n':
        case '\r':
            throw syntaxError(""Unterminated string"");
        case '\\':
            c = next();
            switch (c) {
            case 'b':
                sb.append('\b');
                break;
            case 't':
                sb.append('\t');
                break;
            case 'n':
                sb.append('\n');
                break;
            case 'f':
                sb.append('\f');
                break;
            case 'r':
                sb.append('\r');
                break;
            case 'u':
                sb.append((char)Integer.parseInt(next(4), 16));
                break;
            case 'x' :
                sb.append((char) Integer.parseInt(next(2), 16));
                break;
            default:
                sb.append(c);
            }
            break;
        default:
            if (c == quote) {
                return sb.toString();
            }
            sb.append(c);
        }
    }
}","/**
 * Return the characters up to the next close quote character.
 * Backslash processing is done. The formal JSON format does not
 * allow strings in single quotes, but an implementation is allowed to
 * accept them.
 * @param quote The quoting character, either
 *      <code>""</code>&nbsp;<small>(double quote)</small> or
 *      <code>'</code>&nbsp;<small>(single quote)</small>.
 * @return      A String.
 * @throws JSONException Unterminated string.
 */
public String nextString(char quote) throws JSONException 
{
    char c;
    StringBuilder sb = new StringBuilder();
    for (; ; )
    {
        c = next();
        switch (c)
        {
        case 0:
            throw syntaxError(""Unterminated string"");
        case '\\':
            c = next();
            switch (c)
            {
            case 'b':
                sb.append('\b');
                break;
            case 't':
                sb.append('\t');
                break;
            case 'n':
                sb.append('\n');
                break;
            case 'f':
                sb.append('\f');
                break;
            case 'r':
                sb.append('\r');
                break;
            case 'u':
                sb.append((char) Integer.parseInt(next(4), 16));
                break;
            case '""':
            case '\'':
            case '\\':
                sb.append(c);
                break;
            default:
                throw syntaxError(""Illegal escape."");
            }
            break;
        default:
            if (c == quote)
            {
                return sb.toString();
            }
            sb.append(c);
        }
    }
}   ",1067,True
"/**
 * Get the next value. The value can be a Boolean, Double, Integer,
 * JSONArray, JSONObject, Long, or String, or the JSONObject.NULL object.
 * @throws JSONException If syntax error.
 *
 * @return An object.
 */
public Object nextValue() throws JSONException{
    char c = nextClean();
    String s;

    switch (c) {
        case '""':
        case '\'':
            return nextString(c);
        case '{':
            back();
            return new JSONObject(this);
        case '[':
        case '(':
            back();
            return new JSONArray(this);
    }

    /*
     * Handle unquoted text. This could be the values true, false, or
     * null, or it can be a number. An implementation (such as this one)
     * is allowed to also accept non-standard forms.
     *
     * Accumulate characters until we reach the end of the text or a
     * formatting character.
     */

    StringBuffer sb = new StringBuffer();
    while (c >= ' ' && "",:]}/\\\""[{;=#"".indexOf(c) < 0) {
        sb.append(c);
        c = next();
    }
    back();

    s = sb.toString().trim();
    if (s.equals("""")) {
        throw syntaxError(""Missing value"");
    }
    return JSONObject.stringToValue(s);
}


/**
 * Skip characters until the next character is the requested character.
 * If the requested character is not found, no characters are skipped.
 * @param to A character to skip to.
 * @return The requested character, or zero if the requested character
 * is not found.
 */
public char skipTo(char to) throws JSONException {
    char c;
    try {
        int startIndex = this.index;
        reader.mark(Integer.MAX_VALUE);
        do {
            c = next();
            if (c == 0) {
                reader.reset();
                this.index = startIndex;
                return c;
            }
        } while (c != to);
    } catch (IOException exc) {
        throw new JSONException(exc);
    }

    back();
    return c;
}

/**
 * Make a JSONException to signal a syntax error.
 *
 * @param message The error message.
 * @return  A JSONException object, suitable for throwing
 */
public JSONException syntaxError(String message) {
    return new JSONException(message + toString());
}


/**
 * Make a printable string of this JSONTokener.
 *
 * @return "" at character [this.index]""
 */
public String toString() {
    return "" at character "" + index;
}
}","/**
 * Get the next value. The value can be a Boolean, Double, Integer,
 * JSONArray, JSONObject, Long, or String, or the JSONObject.NULL object.
 * @throws JSONException If syntax error.
 *
 * @return An object.
 */
public Object nextValue() throws JSONException 
{
    char c = nextClean();

    switch (c)
    {
        case '""':
        case '\'':
            return nextString(c);

        case '{':
            return nextObject();

        case '[':
            return nextArray();

        default:
            pos--;
            return nextLiteral();
    }
}   ",1070,False
"/**
 * Get the text up but not including one of the specified delimiter
 * characters or the end of line, whichever comes first.
 * @param delimiters A set of delimiter characters.
 * @return A string, trimmed.
 */
public String nextTo(String delimiters) throws JSONException{
    char c;
    StringBuffer sb = new StringBuffer();
    for (;;) {
        c = next();
        if (delimiters.indexOf(c) >= 0 || c == 0 ||
                c == '\n' || c == '\r') {
            if (c != 0) {
                back();
            }
            return sb.toString().trim();
        }
        sb.append(c);
    }
}","/**
 * Get the text up but not including one of the specified delimiter
 * characters or the end of line, whichever comes first.
 * @param delimiters A set of delimiter characters.
 * @return A string, trimmed.
 */
public String nextTo(String delimiters) throws JSONException 
{
    char c;
    StringBuilder sb = new StringBuilder();
    for (;;)
    {
        c = next();
        if (Character.isWhitespace(c))
        {
            break;
        }
        if (delimiters.indexOf(c) >= 0)
        {
            break;
        }
        sb.append(c);
    }
    return sb.toString().trim();
}   ",1072,True
"/**
 * Get the next n characters.
 *
 * @param n     The number of characters to take.
 * @return      A string of n characters.
 * @throws JSONException
 *   Substring bounds error if there are not
 *   n characters remaining in the source string.
 */
public String next(int n) throws JSONException{
     if (n == 0) {
         return """";
     }

     char[] buffer = new char[n];
     int pos = 0;

     if (this.useLastChar) {
    	 this.useLastChar = false;
         buffer[0] = this.lastChar;
         pos = 1;
     }

     try {
         int len;
         while ((pos < n) && ((len = reader.read(buffer, pos, n - pos)) != -1)) {
             pos += len;
         }
     } catch (IOException exc) {
         throw new JSONException(exc);
     }
     this.index += pos;

     if (pos < n) {
         throw syntaxError(""Substring bounds error"");
     }

     this.lastChar = buffer[n - 1];
     return new String(buffer);
 }","/**
 * Get the next n characters.
 *
 * @param n     The number of characters to take.
 * @return      A string of n characters.
 * @throws JSONException
 *   Substring bounds error if there are not
 *   n characters remaining in the source string.
 */

public String next(int n) throws JSONException 
{
    int i = this.index;
    int j = i + n;
    if (j >= this.maximum)
    {
        throw new JSONException(""Substring bounds error. "" + j + "" is out of bounds."");
    }
    this.index += n;
    return this.source.substring(i, j);
}   ",1074,False
"/**
 * Get the hex value of a character (base16).
 * @param c A character between '0' and '9' or between 'A' and 'F' or
 * between 'a' and 'f'.
 * @return  An int between 0 and 15, or -1 if c was not a hex digit.
 */
public static int dehexchar(char c){
    if (c >= '0' && c <= '9') {
        return c - '0';
    }
    if (c >= 'A' && c <= 'F') {
        return c - ('A' - 10);
    }
    if (c >= 'a' && c <= 'f') {
        return c - ('a' - 10);
    }
    return -1;
}","/**
 * Get the hex value of a character (base16).
 * @param c A character between '0' and '9' or between 'A' and 'F' or
 * between 'a' and 'f'.
 * @return  An int between 0 and 15, or -1 if c was not a hex digit.
 */
public static int dehexchar(char c) 
{
    if (c >= '0' && c <= '9')
        return c - '0';
    if (c >= 'A' && c <= 'F')
        return c - 'A' + 10;
    if (c >= 'a' && c <= 'f')
        return c - 'a' + 10;
    return -1;
}   ",1075,True
"/**
 * Get the next char in the string, skipping whitespace.
 * @throws JSONException
 * @return  A character, or 0 if there are no more characters.
 */
public char nextClean() throws JSONException{
    for (;;) {
        char c = next();
        if (c == 0 || c > ' ') {
            return c;
        }
    }
}","/**
 * Get the next char in the string, skipping whitespace.
 * @throws JSONException
 * @return  A character, or 0 if there are no more characters.
 */
public char nextClean() throws JSONException 
{
    char c;
    do
    {
        c = next();
    }
    while (c != 0 && Character.isWhitespace(c));
    return c;
}   ",1076,True
"// Setup ==================================================================
public TabStringTokenizer(String line){
	this.line = line;

	fetchNextToken();
}","// Setup ==================================================================
public TabStringTokenizer(String line) 
{
    this.line = line;
    this.pos = 0;
    this.delimiters = "" \t\n\r\f"";
    this.returnDelimiters = false;
}   ",1080,True
"//executed in manager thread
public void connectorIsReady(){
  DebuggerInvocationUtil.invokeLater(getProject(), new Runnable() {
    public void run() {
      RemoteConnection connection = myDebugProcess.getConnection();
      final String addressDisplayName = DebuggerBundle.getAddressDisplayName(connection);
      final String transportName = DebuggerBundle.getTransportName(connection);
      final String connectionStatusMessage = connection.isServerMode() ? DebuggerBundle.message(""status.listening"", addressDisplayName, transportName) : DebuggerBundle.message(""status.connecting"", addressDisplayName, transportName);
      getContextManager().setState(SESSION_EMPTY_CONTEXT, DebuggerSession.STATE_WAITING_ATTACH, DebuggerSession.EVENT_START_WAIT_ATTACH, connectionStatusMessage);
    }
  });
}","//executed in manager thread
public void connectorIsReady() 
{
    if (this.connectorIsReady != null)
    {
        this.connectorIsReady.run();
    }
}   ",1081,True
"/**
 * ImportUtils currently checks all inner classes, even those that are
 * contained in inner classes themselves, because it doesn't know the
 * location of the original fully qualified reference. It should really only
 * check if the containing class of the fully qualified reference has any
 * conflicting inner classes.
 */
private static boolean containsConflictingInnerClass(String fqName,
                                                     PsiClass aClass){
    final String shortName = ClassUtil.extractClassName(fqName);
    if(shortName.equals(aClass.getName())){
        if(!fqName.equals(aClass.getQualifiedName())){
            return true;
        }
    }
    final PsiClass[] classes = aClass.getInnerClasses();
    for (PsiClass innerClass : classes) {
        if (containsConflictingInnerClass(fqName, innerClass)) {
            return true;
        }
    }
    return false;
}","/**
 *
 * contained in inner classes themselves, because it doesn't know the
 * location of the original fully qualified reference. It should really only
 * check if the containing class of the fully qualified reference has any
 * conflicting inner classes.
 */
private static boolean containsConflictingInnerClass(String fqName,
                                                     PsiClass aClass) 
{
    if (aClass == null)
    {
        return false;
    }
    PsiClass[] innerClasses = aClass.getInnerClasses();
    for (PsiClass innerClass : innerClasses)
    {
        if (innerClass.getName().equals(fqName))
        {
            return true;
        }
        if (containsConflictingInnerClass(fqName, innerClass))
        {
            return true;
        }
    }
    return false;
}   ",1082,True
"/**
 * @return selected content or <code>null</code>
 */
private Content getContent(final DataContext context){
  ContentManager contentManager = ContentManagerUtil.getContentManagerFromContext(context, true);
  if (contentManager == null){
    return null;
  }
  return contentManager.getSelectedContent();
}","/**
 * @return selected content or <code>null</code>
 */
private Content getContent(final DataContext context) 
{
    final Content[] contents = context.getSelectedContents();
    if (contents.length == 1)
    {
        return contents[0];
    }
    return null;
}   ",1083,False
"/**
 * Shows code style settings sutable for the project passed. I.e. it shows project code style page if one
 * is configured to use own code style scheme or global one in other case.
 * @param project
 * @return Returns true if settings were modified during editing session.
 */
public boolean showCodeStyleSettings(Project project, final Class pageToSelect){
  CodeStyleSettingsManager settingsManager = CodeStyleSettingsManager.getInstance(project);
  CodeStyleSettings savedSettings = settingsManager.getCurrentSettings().clone();
  final CodeStyleSchemesConfigurable configurable = CodeStyleSchemesConfigurable.getInstance(project);
  Runnable selectPage = new Runnable() {
    public void run() {
      if (pageToSelect != null) {
        configurable.selectPage(pageToSelect);
      }
    }
  };
  ShowSettingsUtil.getInstance().editConfigurable(project, configurable, selectPage);

  return !savedSettings.equals(settingsManager.getCurrentSettings());
}","/**
 * Shows code style settings sutable for the project passed. I.e. it shows project code style page if one
 * is configured to use own code style scheme or global one in other case.
 * @param project
 * @return Returns true if settings were modified during editing session.
 */
public boolean showCodeStyleSettings(Project project, final Class pageToSelect) 
{
    final SettingsEditor editor = new SettingsEditor();
    editor.showSettingsDialog(project, pageToSelect);
    return editor.isChanged();
}   ",1084,True
"/**
 * Pushes the specified amount of characters back into the input stream.
 *
 * They will be read again by then next call of the scanning method
 *
 * @param number  the number of characters to be read again.
 *                This number must not be greater than yylength()!
 */
public void yypushback(int number){
  if ( number > yylength() )
    zzScanError(ZZ_PUSHBACK_2BIG);

  zzMarkedPos -= number;
}","/**
 * Pushes the specified amount of characters back into the input stream.
 *
 * They will be read again by then next call of the scanning method
 *
 * @param number  the number of characters to be read again.
 *                This number must not be greater than yylength()!
 */
public void yypushback(int number) 
{
  if ( number > yylength() )
    throw new IllegalArgumentException(""number must not be greater than yylength()"");
  pos -= number;
}   ",1085,True
"/** 
 * Unpacks the compressed character translation table.
 *
 * @param packed   the packed character translation table
 * @return         the unpacked character translation table
 */
private static char [] zzUnpackCMap(String packed){
  char [] map = new char[0x10000];
  int i = 0;  /* index in packed string  */
  int j = 0;  /* index in unpacked array */
  while (i < 1250) {
    int  count = packed.charAt(i++);
    char value = packed.charAt(i++);
    do map[j++] = value; while (--count > 0);
  }
  return map;
}","/** 
 * Unpacks the compressed character translation table.
 *
 * @param packed   the packed character translation table
 * @return         the unpacked character translation table
 */
private static char [] zzUnpackCMap(String packed) 
{
  char [] map = new char[0x10000];
  int i = 0;  /* index in packed string  */
  int j = 0;  /* index in unpacked array */

  while (i < packed.length()) {
    int count = packed.charAt(i++);
    char value = packed.charAt(i++);
    do map[j++] = value; while (--count > 0);
  }
  return map;
}   ",1086,True
"/**
 * actually state changes not in the same sequence as you call setState
 * the 'resuming' setState with context.getSuspendContext() == null may be set prior to
 * the setState for the context with context.getSuspendContext()
 *
 * in this case we assume that the latter setState is ignored
 * since the thread was resumed
 */
public void setState(final DebuggerContextImpl context, final int state, final int event, final String description){
  ApplicationManager.getApplication().assertIsDispatchThread();
  LOG.assertTrue(context.getDebuggerSession() == DebuggerSession.this || context.getDebuggerSession() == null);
  final Runnable setStateRunnable = new Runnable() {
    public void run() {
      LOG.assertTrue(myDebuggerContext.isInitialised());
      myDebuggerContext = context;
      if (LOG.isDebugEnabled()) {
        LOG.debug(""DebuggerSession state = "" + state + "", event = "" + event);
      }

      myIsEvaluating = false;

      myState = new DebuggerSessionState(state, description);
      fireStateChanged(context, event);
    }
  };

  if(context.getSuspendContext() == null) {
    setStateRunnable.run();
  }
  else {
    getProcess().getManagerThread().schedule(new SuspendContextCommandImpl(context.getSuspendContext()) {
      public void contextAction() throws Exception {
        context.initCaches();
        DebuggerInvocationUtil.swingInvokeLater(getProject(), setStateRunnable);
      }
    });
  }
}","/**
 * actually state changes not in the same sequence as you call setState
 * the 'resuming' setState with context.getSuspendContext() == null may be set prior to
 * the setState for the context with context.getSuspendContext()
 *
 * in this case we assume that the latter setState is ignored
 * since the thread was resumed
 */
public void setState(final DebuggerContextImpl context, final int state, final int event, final String description) 
{
    if (context.getSuspendContext() == null)
    {
        // this is a resume
        if (context.getState() == state)
        {
            return;
        }
        context.setState(state, event, description);
    }
    else
    {
        context.setState(state, event, description);
    }
}   ",1087,False
"/**
 * @return selected editor or <code>null</code>
 */
private VirtualFile getFile(final DataContext context){
  Project project = PlatformDataKeys.PROJECT.getData(context);
  if(project == null){
    return null;
  }

  // To provide file from editor manager, editor component should be active
  if(!ToolWindowManager.getInstance(project).isEditorComponentActive()){
    return null;
  }

  return PlatformDataKeys.VIRTUAL_FILE.getData(context);
}","/**
 * @return selected editor or <code>null</code>
 */

private VirtualFile getFile(final DataContext context) 
{
    final Editor editor = PlatformDataKeys.EDITOR.getData(context);
    if (editor != null)
    {
        return FileDocumentManager.getInstance().getFile(editor.getDocument());
    }
    return null;
}   ",1089,True
"/**
 * Contains user EOF-code, which will be executed exactly once,
 * when the end of file is reached
 */
private void zzDoEOF(){
  if (!zzEOFDone) {
    zzEOFDone = true;
  
  }
}","/**
 * Contains user EOF-code, which will be executed exactly once,
 * when the end of file is reached
 */
private void zzDoEOF() 
{
    if (!zzEOFDone)
    {
        zzEOFDone = true;
        yyclose();
    }
}   ",1090,True
"/**
 * total component made invalid => for test connection to be forbidden when for ex. ambiguous settings given
 */
public void setIsValid(final boolean valid){
  for (int i = 0; i < myRoot.getChildCount(); i++) {
    final MyNode node = (MyNode) myRoot.getChildAt(i);
    final GroupConfigurable groupConfigurable = (GroupConfigurable) ((MyNode) node).getConfigurable();
    groupConfigurable.setIsValid(valid);
  }
}","/**
 * total component made invalid => for test connection to be forbidden when for ex. ambiguous settings given
 */
public void setIsValid(final boolean valid) 
{
    if (valid)
    {
        this.isValid = true;
    }
    else
    {
        this.isValid = false;
    }
}   ",1091,True
"/**
 * Is called inside atomic action.
 *
 * @param refUsages usages to be filtered
 * @return true if preprocessed successfully
 */
protected boolean preprocessUsages(Ref<UsageInfo[]> refUsages){
  prepareSuccessful();
  return true;
}","/**
 * Is called inside atomic action.
 *
 * @param refUsages usages to be filtered
 * @return true if preprocessed successfully
 */



protected boolean preprocessUsages(Ref<UsageInfo[]> refUsages) 
{
    UsageInfo[] usages = refUsages.get();
    if (usages == null)
    {
        return false;
    }
    List<UsageInfo> result = new ArrayList<UsageInfo>();
    for (UsageInfo usage : usages)
    {
        if (usage.isValid())
        {
            result.add(usage);
        }
    }
    refUsages.set(result.toArray(new UsageInfo[result.size()]));
    return true;
}   ",1094,True
"/**
 * Process the module. The logic is different for compile-time case and runtime case.
 * In the case of runtime, only directly referenced objects are included in classpath.
 * Indirectly referenced are
 *
 * @param module a module to process.
 * @param dependencyLevel is increased with every of recursion.
 * @param isModuleExported if true the module is exported from the previous level
 */
public void processModule(final Module module, final int dependencyLevel, final boolean isModuleExported){
  if (processedModules.contains(module)) {
    // the module is already processed, nothing should be done
    return;
  }
  if (dependencyLevel > 1 && !isModuleExported && !(genOptions.inlineRuntimeClasspath && generateRuntimeClasspath)) {
    // the module is not in exports and it is not directly included skip it in the case of library pathgeneration
    return;
  }
  processedModules.add(module);
  final ProjectEx project = (ProjectEx)chunk.getProject();
  final File baseDir = BuildProperties.getProjectBaseDir(project);
  for (final OrderEntry orderEntry : ModuleRootManager.getInstance(module).getOrderEntries()) {
    if (!orderEntry.isValid()) {
      continue;
    }
    if (!generateRuntimeClasspath) {
      // needed for compilation classpath only
      if ((orderEntry instanceof ModuleSourceOrderEntry)) {
        // this is the entry for outpath of the currently processed module
        if (dependencyLevel == 0 || chunk.contains(module)) {
          // the root module is never included
          continue;
        }
      }
      else {
        final boolean isExported = (orderEntry instanceof ExportableOrderEntry) && ((ExportableOrderEntry)orderEntry).isExported();
        if (dependencyLevel > 0 && !isExported) {
          if (!(orderEntry instanceof ModuleOrderEntry)) {
            // non-exported dependencies are excluded and not processed
            continue;
          }
        }
      }
    }
    if (orderEntry instanceof JdkOrderEntry) {
      if (genOptions.forceTargetJdk && !generateRuntimeClasspath) {
        pathItems
          .add(new PathRefItem(BuildProperties.propertyRef(BuildProperties.getModuleChunkJdkClasspathProperty(chunk.getName()))));
      }
    }
    else if (orderEntry instanceof ModuleOrderEntry) {
      final ModuleOrderEntry moduleOrderEntry = (ModuleOrderEntry)orderEntry;
      final Module dependentModule = moduleOrderEntry.getModule();
      if (!chunk.contains(dependentModule)) {
        if (generateRuntimeClasspath && !genOptions.inlineRuntimeClasspath) {
          // in case of runtime classpath, just an referenced to corresponding classpath is created
          final ModuleChunk depChunk = genOptions.getChunkByModule(dependentModule);
          if (!processedChunks.contains(depChunk)) {
            // chunk references are included in the runtime classpath only once
            processedChunks.add(depChunk);
            pathItems.add(new PathRefItem(BuildProperties.getRuntimeClasspathProperty(depChunk.getName())));
          }
        }
        else {
          // in case of compile classpath or inlined runtime classpath,
          // the referenced module is processed recursively
          processModule(dependentModule, dependencyLevel + 1, moduleOrderEntry.isExported());
        }
      }
    }
    else if (orderEntry instanceof LibraryOrderEntry) {
      final LibraryOrderEntry libraryOrderEntry = (LibraryOrderEntry)orderEntry;
      final String libraryName = libraryOrderEntry.getLibraryName();
      if (((LibraryOrderEntry)orderEntry).isModuleLevel()) {
        CompositeGenerator gen = new CompositeGenerator();
        gen.setHasLeadingNewline(false);
        LibraryDefinitionsGeneratorFactory.genLibraryContent(project, genOptions, libraryOrderEntry.getLibrary(), baseDir, gen);
        pathItems.add(new GeneratorItem(libraryName, gen));
      }
      else {
        pathItems.add(new PathRefItem(BuildProperties.getLibraryPathId(libraryName)));
      }
    }
    else {
      // Module source entry?
      for (String url : getCompilationClasses(orderEntry, ((GenerationOptionsImpl)genOptions), generateRuntimeClasspath)) {
        if (url.endsWith(JarFileSystem.JAR_SEPARATOR)) {
          url = url.substring(0, url.length() - JarFileSystem.JAR_SEPARATOR.length());
        }
        final String propertyRef = genOptions.getPropertyRefForUrl(url);
        if (propertyRef != null) {
          pathItems.add(new PathElementItem(propertyRef));
        }
        else {
          final String path = VirtualFileManager.extractPath(url);
          pathItems.add(new PathElementItem(
            GenerationUtils.toRelativePath(path, chunk.getBaseDir(), moduleChunkBasedirProperty, genOptions)));
        }
      }
    }
  }
}","/**
 * Process the module. The logic is different for compile-time case and runtime case.
 * In the case of runtime, only directly referenced objects are included in classpath.
 * Indirectly referenced are
 *
 * @param module a module to process.
 * @param dependencyLevel is increased with every of recursion.
 * @param isModuleExported if true the module is exported from the previous level
 */
public void processModule(final Module module, final int dependencyLevel, final boolean isModuleExported) 
{
    if (module == null)
    {
        return;
    }

    if (module.isNamedModule())
    {
        NamedModule namedModule = (NamedModule) module;
        if (namedModule.isExported())
        {
            isModuleExported = true;
        }
    }

    if (module.isPackageModule())
    {
        PackageModule packageModule = (PackageModule) module;
        processPackageModule(packageModule, dependencyLevel, isModuleExported);
    }
    else if (module.isNamedModule())
    {
        NamedModule namedModule = (NamedModule) module;
        processNamedModule(namedModule, dependencyLevel, isModuleExported);
    }
}   ",1095,False
"// Utils ==================================================================
private void fetchNextToken(){
	nextToken = null;
	if (startIndex >= line.length()) {
		return;
	}

	final int nextIndex = line.indexOf('\t', startIndex);
	if (nextIndex >= 0) {
		nextToken = line.substring(startIndex, nextIndex);
		startIndex = nextIndex + 1;
	}
	else {
		nextToken = line.substring(startIndex);
		startIndex = line.length();
	}
}","// Utils ==================================================================
private void fetchNextToken() 
{
    if (this.nextToken != null)
    {
        this.currentToken = this.nextToken;
        this.nextToken = null;
    }
    else
    {
        this.currentToken = this.lexer.nextToken();
    }
}   ",1096,False
"/**
 * Return a clone of a track.
 */
public static Track cloneTrack(Track track){
	Track newTrack = null;

	try {
		Sequence seq = new Sequence(IdealSequence.getDivisionType(),
				IdealSequence.getResolution());
		newTrack = seq.createTrack();
	} catch (Exception e) {
		e.printStackTrace();
		System.exit(1);
	}

	assert newTrack != null;


	for (int i = 0; i < track.size(); i++)
	{
		MidiEvent event = track.get(i);
		newTrack.add(event);
	}

	assert track.size() == newTrack.size();

	return newTrack;

}","/**
 * Return a clone of a track.
 */
public static Track cloneTrack(Track track) 
{
    Track clone = new Track();
    clone.setName(track.getName());
    clone.setArtist(track.getArtist());
    clone.setAlbum(track.getAlbum());
    clone.setGenre(track.getGenre());
    clone.setDuration(track.getDuration());
    return clone;
}   ",1101,False
"/**
 * Updated look and feel to run like a GTK application if the GTK theme is available.
 */
protected void setLookAndFeel(){
	UIManager.LookAndFeelInfo[] infos = UIManager.getInstalledLookAndFeels();

	for (UIManager.LookAndFeelInfo i : infos)
	{
		if (i.getName().contains(""GTK""))
		{
			try {
				UIManager.setLookAndFeel(i.getClassName());
				SwingUtilities.updateComponentTreeUI(this);
			} catch (Exception e) {
				e.printStackTrace();
				System.exit(1);
			}

		}
	}

}","/**
 * Updated look and feel to run like a GTK application if the GTK theme is available.
 */
protected void setLookAndFeel() 
{
    try
    {
        UIManager.setLookAndFeel(""com.sun.java.swing.plaf.gtk.GTKLookAndFeel"");
    }
    catch (Exception e)
    {
        e.printStackTrace();
    }
}   ",1102,False
"/**
 * Return the number of note on and note off events in track.
 */
public static int noteOnOffsInTrack(Track track){
	int count = 0;

	for (int i = 0; i < track.size(); i++)
	{
		MidiEvent event = track.get(i);
		if (isNoteOnEvent(event) || isNoteOffEvent(event))
		{
			count++;
		}
	}

	return count;
}","/**
 * Return the number of note on and note off events in track.
 */






public static int noteOnOffsInTrack(Track track) 
{
    int count = 0;
    for (int i = 0; i < track.size(); i++)
    {
        MidiEvent event = track.get(i);
        MidiMessage message = event.getMessage();
        if (message instanceof ShortMessage)
        {
            ShortMessage shortMessage = (ShortMessage) message;
            int command = shortMessage.getCommand();
            if (command == ShortMessage.NOTE_ON || command == ShortMessage.NOTE_OFF)
            {
                count++;
            }
        }
    }
    return count;
}   ",1103,True
"/**
 * Close the sequencer (so that the program can exit instead of just hanging).
 */
public static void closeSequencer(){
	try{

		if (sequencer != null)
		{
			if (sequencer.isOpen())
			{
				stopPlaying();
				sequencer.close();
			}
		}

	} catch (Exception e) {
		e.printStackTrace();
		System.exit(1);
	}
}","/**
 * Close the sequencer (so that the program can exit instead of just hanging).
 */
public static void closeSequencer() 
{
    if (sequencer != null)
    {
        sequencer.stop();
        sequencer.close();
        sequencer = null;
    }
}   ",1104,True
"/**
 * Return a vector containing all the notes from allNotes that are playing at tick.
 */
public static Vector<Note> getNotesPlayingAtTick(Vector<Note> allNotes, long tick){
	Vector<Note> playingNotes = new Vector<Note>();

	for (Note n : allNotes)
	{
		if (tick >= n.getStartTick() && tick < n.getEndTick())
		{
			playingNotes.add(n);
		}
	}

	return playingNotes;
}","/**
 * Return a vector containing all the notes from allNotes that are playing at tick.
 */
public static Vector<Note> getNotesPlayingAtTick(Vector<Note> allNotes, long tick) 
{
    Vector<Note> result = new Vector<Note>();
    for (Note note : allNotes)
    {
        if (note.isOn(tick))
        {
            result.add(note);
        }
    }
    return result;
}   ",1108,True
"/**
 * Return the note value for a note on or off message.
 */
public static int getNoteValue(MidiMessage noteOnOff){
	assert isNoteOnMessage(noteOnOff) || isNoteOffMessage(noteOnOff);

	return noteOnOff.getMessage()[1];
}","/**
 * Return the note value for a note on or off message.
 */

public static int getNoteValue(MidiMessage noteOnOff) 
{
    if (noteOnOff instanceof ShortMessage)
    {
        ShortMessage sm = (ShortMessage)noteOnOff;
        if (sm.getCommand() == ShortMessage.NOTE_ON || sm.getCommand() == ShortMessage.NOTE_OFF)
        {
            return sm.getData1();
        }
    }
    return -1;
}   ",1113,True
"/**
 * Find the same MidiEvent in track as the argument midiEvent.
 */
public static MidiEvent findSameEvent(Track track, MidiEvent midiEvent)
	throws Exception{
	for (int i = 0; i < track.size(); i++)
	{
		MidiEvent trackEvent = track.get(i);

		if (isEqualMidiEvents(trackEvent, midiEvent))
		{
			return trackEvent;
		}
	}

	System.out.println(""There is no event "" + 
			DebugMidi.midiEventToString(midiEvent) +
			"" in track: "" + DebugMidi.trackEventsToString(track));
	throw new Exception();
}","/**
 * Find the same MidiEvent in track as the argument midiEvent.
 */
public static MidiEvent findSameEvent(Track track, MidiEvent midiEvent)
	throws Exception 
{
	for (int i = 0; i < track.size(); i++) {
		MidiEvent event = track.get(i);
		if (event.getMessage() == midiEvent.getMessage()) {
			return event;
		}
	}
	return null;
}	",1114,True
"/**
 * Detect whether or not there is anything playing.
 */
public static boolean isPlaying(){
	try{
		if (sequencer == null)
		{
			return false;
		}

		// if it is not open, then it's not playing
		if (!sequencer.isOpen())
		{
			return false;
		}
		
		return sequencer.isRunning();

	} catch (Exception e) {
		e.printStackTrace();
		System.exit(1);
		return false;
	}
}","/**
 * Detect whether or not there is anything playing.
 */
public static boolean isPlaying() 
{
    if (player == null)
    {
        return false;
    }
    else
    {
        return true;
    }
}   ",1115,False
"/**
 * Given a musical pitch (C4, C#-1, D9...), give back the midi value.
 */
public static int getValueFromNote(String noteAndOctave){
	// I got this from here:
	// http://www.harmony-central.com/MIDI/Doc/table2.html
	if (!noteAndOctave.matches(""^(C|C#|D|D#|E|F|F#|G|G#|A|A#|B)(-1|[0-9])$""))
	{
		System.out.println(""note "" + noteAndOctave + "" is not a muscial note."");
		System.exit(1);
	}

	char note = noteAndOctave.charAt(0);

	int noteValue = -100;

	switch(note)
	{
		case 'C':
			noteValue = 0;
			break;
		case 'D':
			noteValue = 2;
			break;
		case 'E':
			noteValue = 4;
			break;
		case 'F':
			noteValue = 5;
			break;
		case 'G':
			noteValue = 7;
			break;
		case 'A':
			noteValue = 9;
			break;
		case 'B':
			noteValue = 11;
			break;
		default:
			System.out.println(""This should never be reached."");
			System.exit(1);
			break;
	}

	boolean sharp = noteAndOctave.contains(""#"");

	// if it's sharp, the note value goes up by one
	if (sharp) 
	{
		//System.out.println(""There is a sharp"");
		noteValue += 1;
	}
	
	//System.out.println(""notevalue: "" + noteValue);

	int octaveIndex = -100;

	// set the starting index for the octave
	if (sharp) 
		octaveIndex = 2;
	else 
		octaveIndex = 1;

	//System.out.println(""octaveIndex is "" + octaveIndex);

	int octave = -100;

	try {
		// figure out the octave
		octave = Integer.parseInt( noteAndOctave.substring(octaveIndex) );
	} catch (Exception e) {
		e.printStackTrace();
		System.exit(1);
	}

	//System.out.println(""octave is "" + octave);

	return (octave + 1) * 12 + noteValue;
}","/**
 * Given a musical pitch (C4, C#-1, D9...), give back the midi value.
 */
public static int getValueFromNote(String noteAndOctave) 
{
    int octave = Integer.parseInt(noteAndOctave.substring(noteAndOctave.length() - 1));
    int noteValue = 0;
    switch (noteAndOctave.charAt(0))
    {
        case 'C':
            noteValue = 0;
            break;
        case 'D':
            noteValue = 2;
            break;
        case 'E':
            noteValue = 4;
            break;
        case 'F':
            noteValue = 5;
            break;
        case 'G':
            noteValue = 7;
            break;
        case 'A':
            noteValue = 9;
            break;
        case 'B':
            noteValue = 11;
            break;
    }
    noteValue += (octave + 1) * 12;
    return noteValue;
}   ",1116,True
"/**
 * Take the NOTE_ON event noteOn (which is event i in track), and 
 * find the matching NOTE_OFF event.
 */
public static MidiEvent findMatchingNoteOff(Track track, int noteOnIndex, MidiEvent noteOn){
	assert isNoteOnEvent(noteOn);

	for (int i = noteOnIndex; i < track.size(); i++)
	{
		MidiEvent event = track.get(i);
		if (isNoteOffEvent(event) && 
				(getNoteValue(noteOn) == getNoteValue(event)))
		{
			return event;
		}
	}

	System.out.println(""Could not find note off event for: "" + 
			DebugMidi.midiEventToString(noteOn));
	System.exit(1);
	return null;

}","/**
 * Take the NOTE_ON event noteOn (which is event i in track), and 
 * find the matching NOTE_OFF event.
 */
public static MidiEvent findMatchingNoteOff(Track track, int noteOnIndex, MidiEvent noteOn) 
{
    int noteOffIndex = noteOnIndex + 1;
    MidiEvent noteOff = null;
    while (noteOffIndex < track.size() && noteOff == null)
    {
        MidiEvent event = track.get(noteOffIndex);
        if (event.getMessage().getMessage()[0] == 0x80 && event.getMessage().getMessage()[1] == noteOn.getMessage().getMessage()[1])
        {
            noteOff = event;
        }
        noteOffIndex++;
    }
    return noteOff;
}   ",1118,True
"/**
 * This is a callback that will allow us
 * to create the viewer and initialize it.
 */
public void createPartControl(Composite parent){
	viewer = new TreeViewer(parent, SWT.MULTI | SWT.H_SCROLL | SWT.V_SCROLL);
	drillDownAdapter = new DrillDownAdapter(viewer);
	viewer.setContentProvider(new ViewContentProvider());
	viewer.setLabelProvider(new ViewLabelProvider());
	viewer.setInput(getViewSite());
	makeActions();
	hookContextMenu();
	hookDoubleClickAction();
}","/**
 * This is a callback that will allow us
 * to create the viewer and initialize it.
 */

public void createPartControl(Composite parent) 
{
    viewer = new TreeViewer(parent, SWT.MULTI | SWT.H_SCROLL | SWT.V_SCROLL);
    viewer.setContentProvider(new ViewContentProvider());
    viewer.setLabelProvider(new ViewLabelProvider());
    viewer.setInput(getViewSite());
}   ",1122,True
"/**
 * Returns map of browser names and exe names to
 * {@link WindowsBrowser WindowsBrowser} objects.
 * <p>
 * This is the preferred method for accessing the browser name and exe map.
 * @return Map
 */
private Map getBrowserMap(){
    // Handles lazy instantiation of available browser map.
    synchronized (WindowsBrowserLaunching.class) {
        if (browserNameAndExeMap == null) {
            browserNameAndExeMap = new HashMap();
            // pull additional browsers from system property??
            // ---------
            // create temporary list of browsers to check to track which
            // ones have been found
            // we will remove items from this temp list
            List tempBrowsersToCheck = new ArrayList(browsersToCheck);
            // first try the registry
            if (useRegistry) {
                browserNameAndExeMap.putAll(
                        getAvailableBrowsers(tempBrowsersToCheck));
            }
            // if there are still browsers to find, try file path
            if (!tempBrowsersToCheck.isEmpty()) {
                browserNameAndExeMap.putAll(
                        processFilePathsForBrowsers(tempBrowsersToCheck));
            }
        }
    }
    return browserNameAndExeMap;
}","/**
 * Returns map of browser names and exe names to
 * {@link WindowsBrowser WindowsBrowser} objects.
 * <p>
 * This is the preferred method for accessing the browser name and exe map.
 * @return Map
 */
private Map getBrowserMap() 
{
    if (browserMap == null)
    {
        browserMap = new HashMap();
        browserMap.put(""firefox"", new WindowsBrowser(""Mozilla Firefox"", ""firefox.exe""));
        browserMap.put(""iexplore"", new WindowsBrowser(""Internet Explorer"", ""iexplore.exe""));
        browserMap.put(""safari"", new WindowsBrowser(""Safari"", ""safari.exe""));
    }
    return browserMap;
}   ",1123,False
"/**
 * Checks that the windows key is valid.
 *
 * @param logger AbstractLogger
 * @param windowsKey String
 */
public WindowsBrowserLaunching(AbstractLogger logger,
                               String windowsKey){
    if (windowsKey == null) {
        throw new IllegalArgumentException(""windowsKey cannot be null"");
    }
    if (Arrays.binarySearch(WIN_KEYS, windowsKey) < 0) {
        throw new IllegalArgumentException(windowsKey + "" is invalid"");
    }
    this.logger = logger;
    this.windowsKey = windowsKey;
    logger.info(windowsKey);
}","/**
 * Checks that the windows key is valid.
 *
 * @param logger AbstractLogger
 * @param windowsKey String
 */
public WindowsBrowserLaunching(AbstractLogger logger,
                               String windowsKey) 
{
    this.logger = logger;
    this.windowsKey = windowsKey;
}   ",1124,True
"/**
 * Secondary method for browser discovery.
 * <p>
 * Uses IE to get the path to the Program Files directory;
 * then gets a list of the sub dirs and checks them against
 * the remaining browsers.
 *
 * @param iePath String
 * @param browsersAvailable Map
 * @param tmpBrowsersToCheck List
 */
private Map processFilePathsForBrowsers(
        List tmpBrowsersToCheck){
    logger.debug(""finding available browsers in program files path"");
    logger.debug(""browsers to check: "" + tmpBrowsersToCheck);
    Map browsersAvailable = new HashMap();
    File progFilesPath = getProgramFilesPath();
    if (progFilesPath != null) {
        logger.debug(""program files path: "" + progFilesPath.getPath());
        File[] subDirs = progFilesPath.listFiles(new DirFileFilter());
        int subDirsCnt = subDirs != null ? subDirs.length : 0;
        // create and populate map of dir names to win browser objects
        Iterator iter = tmpBrowsersToCheck.iterator();
        Map dirNameToBrowser = new HashMap();
        while (iter.hasNext()) {
            WindowsBrowser wBrowser = (WindowsBrowser) iter.next();
            dirNameToBrowser.put(wBrowser.getSubDirName(), wBrowser);
        }
        // iterate over subdirs and compare to map entries
        for (int idx = 0; idx < subDirsCnt && !tmpBrowsersToCheck.isEmpty();
                       idx++) {
            if (dirNameToBrowser.containsKey(subDirs[idx].getName())) {
                WindowsBrowser wBrowser = (WindowsBrowser) dirNameToBrowser.
                                          get(
                        subDirs[idx].getName());
                // need to search folder and sub-folders for exe to find
                // the full path
                String exeName = wBrowser.getBrowserApplicationName() +
                                 "".exe"";
                File fullPathToExe = findExeFilePath(
                        subDirs[idx],
                        exeName);
                if (fullPathToExe != null) {
                    logger.debug(""Adding browser "" +
                                 wBrowser.getBrowserDisplayName() +
                                 "" to available list."");
                    wBrowser.setPathToExe(fullPathToExe.getPath());
                    logger.debug(wBrowser.getPathToExe());
                    // adding display and exe for backward compatibility and
                    // ease of use if someone passes in the name of an exe
                    browsersAvailable.put(wBrowser.getBrowserDisplayName(),
                                          wBrowser);
                    browsersAvailable.put(wBrowser.
                                          getBrowserApplicationName(),
                                          wBrowser);
                    tmpBrowsersToCheck.remove(wBrowser);
                }
            }
        }
    }
    return browsersAvailable;
}","/**
 * Secondary method for browser discovery.
 * <p>
 * Uses IE to get the path to the Program Files directory;
 * then gets a list of the sub dirs and checks them against
 * the remaining browsers.
 *
 * @param iePath String
 * @param browsersAvailable Map
 * @param tmpBrowsersToCheck List
 */


private Map processFilePathsForBrowsers(
        List tmpBrowsersToCheck) 
{
    Map browsersAvailable = new HashMap();
    String iePath = getIEPath();
    if (iePath != null)
    {
        File programFiles = new File(iePath);
        File[] subDirs = programFiles.listFiles();
        for (int i = 0; i < subDirs.length; i++)
        {
            for (int j = 0; j < tmpBrowsersToCheck.size(); j++)
            {
                String browser = (String) tmpBrowsersToCheck.get(j);
                if (subDirs[i].getName().toLowerCase().contains(browser))
                {
                    browsersAvailable.put(browser, subDirs[i].getAbsolutePath());
                }
            }
        }
    }
    return browsersAvailable;
}       ",1125,True
"/**
 * Returns displayname and executable name for debugging.
 *
 * @return String
 */
public String toString(){
    StringBuffer buf = new StringBuffer();
    buf.append(displayName);
    buf.append("": ForceWindowArg="");
    buf.append(forceWindowArgs);
    buf.append(""; SubDir name="");
    buf.append(subDirName);
    buf.append(""; Path to exe="");
    if(pathToExe != null) {
        buf.append(pathToExe);
    }
    buf.append(""; Exe name="");
    buf.append(exe);
    return buf.toString();
}","/**
 * Returns displayname and executable name for debugging.
 *
 * @return String
 */
public String toString() 
{
    return ""Displayname: "" + this.displayname + "" Executable: "" + this.executable;
}   ",1126,False
"/**
 * Initializes the browser launcher from the windows config
 * file. It initializes the browsers to check list and
 * the command line args to use for version of windows
 * referenced by the windowsKey.
 *
 * @see windowsKey
 * @throws BrowserLaunchingInitializingException
 */
public void initialize()
        throws BrowserLaunchingInitializingException{
    try {
        URL configUrl = getClass().getResource(CONFIGFILE_WINDOWS);
        if (configUrl == null) {
            throw new BrowserLaunchingInitializingException(
                    ""unable to find config file: "" + CONFIGFILE_WINDOWS);
        }
        Properties configProps = new Properties();
        configProps.load(configUrl.openStream());
        // get sep char
        String sepChar = configProps.getProperty(PROP_KEY_DELIMITER);
        // load different types of browsers
        Iterator keysIter = configProps.keySet().iterator();
        while (keysIter.hasNext()) {
            String key = (String) keysIter.next();
            if (key.startsWith(PROP_KEY_BROWSER_PREFIX)) {
                WindowsBrowser winBrowser = new WindowsBrowser(
                        sepChar,
                        configProps.getProperty(key));
                browsersToCheck.add(winBrowser);
            }
        }
        // load the type of windows based on the windows key
        String windowsConfigStr = configProps.getProperty(
                windowsKey,
                null);
        if (windowsConfigStr == null) {
            throw new BrowserLaunchingInitializingException(
                    windowsKey + "" is not a valid property"");
        }
        String[] winConfigItems = windowsConfigStr.split(sepChar);
        commandsDefaultBrowser = winConfigItems[0];
        commandsTargettedBrowser = winConfigItems[1];
        Boolean boolVal = new Boolean(winConfigItems[2]);
        useRegistry = boolVal.booleanValue();
        // check for override of useRegistry from system prop
        // need to explicitly check BOTH values to filter out
        // invalid prop values
        String propValue = System.getProperty(
                IBrowserLaunching.WINDOWS_BROWSER_DISC_POLICY_PROPERTY,
                null);
        if (IBrowserLaunching.WINDOWS_BROWSER_DISC_POLICY_DISK.equals(
                propValue)) {
            useRegistry = false;
        }
        else if (IBrowserLaunching.WINDOWS_BROWSER_DISC_POLICY_REGISTRY.
                 equals(propValue)) {
            useRegistry = true;
        }
        if (logger.isDebugEnabled()) {
            logger.debug(""Browser discovery policy property value="" +
                         (propValue == null ? ""null"" : propValue));
            logger.debug(""useRegistry="" + Boolean.toString(useRegistry));
        }
        // get info for checking Program Files folder
        programFilesFolderTemplate = configProps.getProperty(
                ""program.files.template"",
                null);
        driveLetters = configProps.getProperty(
                ""drive.letters"",
                null);
        // set brwosersToCheck to a non-modifiable list
        browsersToCheck = Collections.unmodifiableList(browsersToCheck);
    }
    catch (IOException ioex) {
        throw new BrowserLaunchingInitializingException(ioex);
    }
}","/**
 * Initializes the browser launcher from the windows config
 * file. It initializes the browsers to check list and
 * the command line args to use for version of windows
 * referenced by the windowsKey.
 *
 * @see windowsKey
 * @throws BrowserLaunchingInitializingException
 */
public void initialize()
        throws BrowserLaunchingInitializingException 
{
    try
    {
        // Get the windows config
        WindowsConfiguration config = WindowsConfiguration.getInstance();

        // Get the windows key
        windowsKey = config.getWindowsKey();

        // Get the browsers to check
        browsersToCheck = config.getBrowsersToCheck();

        // Get the command line args
        commandLineArgs = config.getCommandLineArgs();
    }
    catch (Exception e)
    {
        throw new BrowserLaunchingInitializingException(e);
    }
}       ",1131,False
"/**
 * Allows user to target several browsers. The names of
 * potential browsers can be accessed via the
 * {@link #getBrowserList() getBrowserList} method.
 * <p>
 * The browsers from the list will be tried in order
 * (first to last) until one of the calls succeeds. If
 * all the calls to the requested browsers fail, the code
 * will fail over to the default browser.
 *
 * @param browsers List
 * @param urlString String
 * @throws UnsupportedOperatingSystemException
 * @throws BrowserLaunchingExecutionException
 * @throws BrowserLaunchingInitializingException
 */
public void openUrl(List browsers,
                    String urlString)
        throws UnsupportedOperatingSystemException,
        BrowserLaunchingExecutionException,
        BrowserLaunchingInitializingException{
    if (browsers == null || browsers.isEmpty()) {
        logger.debug(""falling through to non-targetted openUrl"");
        openUrl(urlString);
    }
    else {
        String protocol = null;
        try {
            protocol = getProtocol(urlString);
        }
        catch (MalformedURLException malrulex) {
            throw new BrowserLaunchingExecutionException(malrulex);
        }
        Map browserMap = getBrowserMap();
        boolean success = false;
        Iterator iter = browsers.iterator();
        while (iter.hasNext() && !success) {
            WindowsBrowser winBrowser = (WindowsBrowser) browserMap.get(
                    iter.next());
            if (winBrowser != null) {
                success = openUrlWithBrowser(winBrowser,
                                             protocol,
                                             urlString);
            }
        }
        if (!success) {
            logger.debug(
                    ""none of listed browsers succeeded; falling through to non-targetted openUrl"");
            openUrl(urlString);
        }
    }
}","/**
 * Allows user to target several browsers. The names of
 * potential browsers can be accessed via the
 * {@link #getBrowserList() getBrowserList} method.
 * <p>
 * The browsers from the list will be tried in order
 * (first to last) until one of the calls succeeds. If
 * all the calls to the requested browsers fail, the code
 * will fail over to the default browser.
 *
 * @param browsers List
 * @param urlString String
 * @throws UnsupportedOperatingSystemException
 * @throws BrowserLaunchingExecutionException
 * @throws BrowserLaunchingInitializingException
 */
public void openUrl(List browsers,
                    String urlString)
        throws UnsupportedOperatingSystemException,
        BrowserLaunchingExecutionException,
        BrowserLaunchingInitializingException 
{
    boolean success = false;
    Iterator browserIterator = browsers.iterator();
    while (browserIterator.hasNext() && !success)
    {
        String browserName = (String) browserIterator.next();
        success = openUrl(browserName, urlString);
    }
    if (!success)
    {
        openUrl(urlString);
    }
}       ",1132,False
"/**
 * Returns a list of browsers to be used for browser targetting.
 * This list will always contain at least one item--the BROWSER_DEFAULT.
 *
 * @return List
 */
public List getBrowserList(){
    List browserList = new ArrayList(1);
    browserList.add(IBrowserLaunching.BROWSER_DEFAULT);
    return browserList;
}","/**
 * Returns a list of browsers to be used for browser targetting.
 * This list will always contain at least one item--the BROWSER_DEFAULT.
 *
 * @return List
 */

public List getBrowserList() 
{
    List list = new ArrayList();
    list.add(BROWSER_DEFAULT);
    return list;
}   ",1133,True
"/**
 * Provided that <code>getLevel()</code> accepts it, log
 * <code>message</code> and <code>error</code>. Otherwise, do nothing.
 */
public void log(int logLevel, String message, Throwable error){
    if (isEnabled(logLevel)) {
        try {
            reallyLog(logLevel, message, error);
            loggedMessageCount += 1;
        }
        catch (Exception error2) {
            throw new LoggingException(""cannot log message: "" + message,
                                       error2);
        }
    }
}","/**
 * Provided that <code>getLevel()</code> accepts it, log
 * <code>message</code> and <code>error</code>. Otherwise, do nothing.
 */
public void log(int logLevel, String message, Throwable error) 
{
    if (getLevel() >= logLevel)
    {
        System.out.println(message);
        if (error != null)
        {
            error.printStackTrace();
        }
    }
}   ",1138,True
"/**
 * Use program files folder template from properties file and
 * the list of drive letters from that properties file
 * @return File
 */
private File getProgramFilesPath(){
    File progFilesPath = null;
    if (driveLetters != null && programFilesFolderTemplate != null) {
        String[] drives = driveLetters.split("";"");
        for (int idx = 0; idx < drives.length && progFilesPath == null; idx++) {
            String path = MessageFormat.format(
                    programFilesFolderTemplate,
                    new Object[] {drives[idx]});
            File pfPath = new File(path);
            logger.debug(path);
            logger.debug(pfPath.getPath());
            if (pfPath.exists()) {
                progFilesPath = pfPath;
            }
        }
    }
    return progFilesPath;
}","/**
 * Use program files folder template from properties file and
 * the list of drive letters from that properties file
 * @return File
 */
private File getProgramFilesPath() 
{
    String programFilesPath = properties.getProperty(""programFilesPath"");
    String[] driveLetters = properties.getProperty(""driveLetters"").split("","");

    for (String driveLetter : driveLetters)
    {
        File file = new File(driveLetter + "":"" + programFilesPath);
        if (file.exists())
        {
            return file;
        }
    }
    return null;
}   ",1139,True
"/**
 * Removes the Alias with the specified name from the AliasManager.
 * If no such Alias exists in this AliasManager, this method has no effect.
 * @param aliasName the name of the Alias to remove
 */
public void removeAlias(String aliasName){
	synchronized (aliases) {
		aliases.remove(aliasName);
	}
}","/**
 * Removes the Alias with the specified name from the AliasManager.
 * If no such Alias exists in this AliasManager, this method has no effect.
 * @param aliasName the name of the Alias to remove
 */
public void removeAlias(String aliasName) 
{
    if (aliasName == null)
    {
        throw new IllegalArgumentException(""The alias name cannot be null"");
    }

    this.aliases.remove(aliasName);
}   ",1141,True
"/**
 * Sets up the NGServer internals
 * @param addr the InetAddress to bind to
 * @param port the port on which to listen
 */
private void init(InetAddress addr, int port){
	this.addr = addr;
	this.port = port;
	
	this.aliasManager = new AliasManager();
	allNailStats = new java.util.HashMap();
	// allow a maximum of 10 idle threads.  probably too high a number
	// and definitely should be configurable in the future
	sessionPool = new NGSessionPool(this, 10);
}","/**
 * Sets up the NGServer internals
 * @param addr the InetAddress to bind to
 * @param port the port on which to listen
 */


private void init(InetAddress addr, int port) 
{
    try
    {
        this.serverSocket = new ServerSocket(port, 0, addr);
        this.serverSocket.setSoTimeout(1000);
        this.serverSocket.setReuseAddress(true);
        this.serverSocket.setReceiveBufferSize(1024);
    }
    catch (IOException e)
    {
        e.printStackTrace();
    }
}   ",1143,False
"/**
 * <p>Shuts down the server.  The server will stop listening
 * and its thread will finish.  Any running nails will be allowed
 * to finish.</p>
 * 
 * <p>Any nails that provide a
 * <pre><code>public static void nailShutdown(NGServer)</code></pre>
 * method will have this method called with this NGServer as its sole
 * parameter.</p>
 * 
 * @param exitVM if true, this method will also exit the JVM after
 * calling nailShutdown() on any nails.  This may prevent currently
 * running nails from exiting gracefully, but may be necessary in order
 * to perform some tasks, such as shutting down any AWT or Swing threads
 * implicitly launched by your nails.
 */
public void shutdown(boolean exitVM){
	synchronized(this) {
		if (shutdown) return;
		shutdown = true;
	}
	
	try {
		serversocket.close();
	} catch (Throwable toDiscard) {}
	
	sessionPool.shutdown();
	
	Class[] argTypes = new Class[1];
	argTypes[0] = NGServer.class;
	Object[] argValues = new Object[1];
	argValues[0] = this;
	
	// make sure that all aliased classes have associated nailstats
	// so they can be shut down.
	for (Iterator i = getAliasManager().getAliases().iterator(); i.hasNext();) {
		Alias alias = (Alias) i.next();
		getOrCreateStatsFor(alias.getAliasedClass());
	}
	
	synchronized(allNailStats) {
		for (Iterator i = allNailStats.values().iterator(); i.hasNext();) {
			NailStats ns = (NailStats) i.next();
			Class nailClass = ns.getNailClass();
			
			// yes, I know this is lazy, relying upon the exception
			// to handle the case of no nailShutdown method.
			try {
				Method nailShutdown = nailClass.getMethod(""nailShutdown"", argTypes);
				nailShutdown.invoke(null, argValues);
			} catch (Throwable toDiscard) {}
		}
	}
	
	// restore system streams
	System.setIn(in);
	System.setOut(out);
	System.setErr(err);
	
	System.setSecurityManager(originalSecurityManager);
	
	if (exitVM) {
		System.exit(0);
	}
}","/**
 * <p>Shuts down the server.  The server will stop listening
 * and its thread will finish.  Any running nails will be allowed
 * to finish.</p>
 * 
 * <p>Any nails that provide a
 * <pre><code>public static void nailShutdown(NGServer)</code></pre>
 * method will have this method called with this NGServer as its sole
 * parameter.</p>
 * 
 * @param exitVM if true, this method will also exit the JVM after
 * calling nailShutdown() on any nails.  This may prevent currently
 * running nails from exiting gracefully, but may be necessary in order
 * to perform some tasks, such as shutting down any AWT or Swing threads
 * implicitly launched by your nails.
 */
public void shutdown(boolean exitVM) 
{
    if (shutdown) return;
    shutdown = true;
    for (NGServerListener l : listeners) {
        l.preShutdown();
    }
    for (NGServerListener l : listeners) {
        l.shutdown();
    }
    for (NGServerListener l : listeners) {
        l.postShutdown();
    }
    if (exitVM) {
        System.exit(0);
    }
}   ",1145,False
"/**
 * Listens for new connections and launches NGSession threads
 * to process them.
 */
public void run(){
	running = true;
	NGSession sessionOnDeck = null;
	
	originalSecurityManager = System.getSecurityManager();
        System.setSecurityManager(
                new NGSecurityManager(
                        originalSecurityManager));
  

	synchronized(System.in) {
		if (!(System.in instanceof ThreadLocalInputStream)) {
			System.setIn(new ThreadLocalInputStream(in));
			System.setOut(new ThreadLocalPrintStream(out));
			System.setErr(new ThreadLocalPrintStream(err));				
		}
	}
	
	try {
		if (addr == null) {
			serversocket = new ServerSocket(port);
		} else {
			serversocket = new ServerSocket(port, 0, addr);
		}
		
		while (!shutdown) {
			sessionOnDeck = sessionPool.take();
			Socket socket = serversocket.accept();
			sessionOnDeck.run(socket);
		}

	} catch (Throwable t) {
		// if shutdown is called while the accept() method is blocking,
		// an exception will be thrown that we don't care about.  filter
		// those out.
		if (!shutdown) {
			t.printStackTrace();
		}
	}
	if (sessionOnDeck != null) {
		sessionOnDeck.shutdown();
	}
	running = false;
}","/**
 * Listens for new connections and launches NGSession threads
 * to process them.
 */




public void run() 
{
    while (true)
    {
        try
        {
            Socket socket = serverSocket.accept();
            NGSession session = new NGSession(socket, this);
            session.start();
        }
        catch (IOException e)
        {
            e.printStackTrace();
        }
    }
}   ",1147,False
"/**
 * Loads Aliases from a java.util.Properties file located at the
 * specified URL.  The properties must be of the form:
 * <pre><code>[alias name]=[fully qualified classname]</code></pre>
 * each of which may have an optional
 * <pre><code>[alias name].desc=[alias description]</code></pre>
 * 
 * For example, to create an alias called ""<code>myprog</code>"" for
 * class <code>com.mydomain.myapp.MyProg</code>, the following properties
 * would be defined:
 * 
 * <pre><code>myprog=com.mydomain.myapp.MyProg
 *myprog.desc=Runs my program.
 * </code></pre>
 * @param properties the Properties to load.
 */
public void loadFromProperties(java.util.Properties properties){
	for (Iterator i = properties.keySet().iterator(); i.hasNext();) {
		String key = (String) i.next();
		if (!key.endsWith("".desc"")) {
			try {
				Class clazz = Class.forName(properties.getProperty(key));
				String desc = properties.getProperty(key + "".desc"", """");
				addAlias(new Alias(key, desc, clazz));
			} catch (ClassNotFoundException e) {
				System.err.println(""Unable to locate class "" + properties.getProperty(key));
			}
		}
	}
}","/**
 * Loads Aliases from a java.util.Properties file located at the
 * specified URL.  The properties must be of the form:
 * <pre><code>[alias name]=[fully qualified classname]</code></pre>
 * each of which may have an optional
 * <pre><code>[alias name].desc=[alias description]</code></pre>
 * 
 * For example, to create an alias called ""<code>myprog</code>"" for
 * class <code>com.mydomain.myapp.MyProg</code>, the following properties
 * would be defined:
 * 
 * <pre><code>myprog=com.mydomain.myapp.MyProg
 *myprog.desc=Runs my program.
 * </code></pre>
 * @param properties the Properties to load.
 */
public void loadFromProperties(java.util.Properties properties) 
{
    java.util.Enumeration e = properties.propertyNames();
    while (e.hasMoreElements())
    {
        String key = (String) e.nextElement();
        String value = properties.getProperty(key);
        if (key.endsWith("".desc""))
        {
            String aliasName = key.substring(0, key.length() - 5);
            String description = value;
            addAlias(aliasName, value, description);
        }
        else
        {
            addAlias(key, value, null);
        }
    }
}   ",1148,True
"/**
 * Returns a snapshot of this NGServer's nail statistics.  The result is a <code>java.util.Map</code>,
 * keyed by class name, with <a href=""NailStats.html"">NailStats</a> objects as values.
 * 
 * @return a snapshot of this NGServer's nail statistics.
 */
public Map getNailStats(){
	Map result = new java.util.TreeMap();
	synchronized(allNailStats) {
		for (Iterator i = allNailStats.keySet().iterator(); i.hasNext();) {
			Class nailclass = (Class) i.next();
			result.put(nailclass.getName(), ((NailStats) allNailStats.get(nailclass)).clone());
		}
	}
	return (result);
}","/**
 * Returns a snapshot of this NGServer's nail statistics.  The result is a <code>java.util.Map</code>,
 * keyed by class name, with <a href=""NailStats.html"">NailStats</a> objects as values.
 * 
 * @return a snapshot of this NGServer's nail statistics.
 */





public Map getNailStats() 
{
    Map map = new HashMap();
    for (Iterator it = _nailStats.entrySet().iterator(); it.hasNext();)
    {
        Map.Entry entry = (Map.Entry) it.next();
        map.put(entry.getKey(), ((NailStats) entry.getValue()).clone());
    }
    return map;
}   ",1150,True
"/**
 * Instructs this NGSession to process the specified socket, after which
 * this NGSession will return itself to the pool from which it came.
 * @param socket the socket (connected to a client) to process
 */
public void run(Socket socket){
	synchronized(lock) {
		nextSocket = socket;
		lock.notify();
	}
	Thread.yield();
}","/**
 * Instructs this NGSession to process the specified socket, after which
 * this NGSession will return itself to the pool from which it came.
 * @param socket the socket (connected to a client) to process
 */
public void run(Socket socket) 
{
    try
    {
        this.process(socket);
    }
    finally
    {
        NGSessionPool.getInstance().returnSession(this);
    }
}   ",1151,True
"/**
 * Throws a <code>java.lang.SecurityException</code> if the client is not
 * connected from the local machine.
 */
public void assertLocalClient(){
	NetworkInterface iface = null;
	try {
		iface = NetworkInterface.getByInetAddress(getInetAddress());
	} catch (java.net.SocketException se) {
		throw (new SecurityException(""Unable to determine if client is local.  Assuming he isn't.""));
	}
	
	if ((iface == null) && (!getInetAddress().isLoopbackAddress())) {
		throw (new SecurityException(""Client is not local.""));
	}
}","/**
 * Throws a <code>java.lang.SecurityException</code> if the client is not
 * connected from the local machine.
 */
public void assertLocalClient() 
{
    if (!isLocalClient())
    {
        throw new SecurityException(""Not connected from the local machine"");
    }
}   ",1153,False
"/**
 * Constructs an exit exception.
 * @param msg the message to be displayed.
 * @param status the status code returned via System.exit()
 */
public ExitException(String msg, int status){
    super(msg);
    this.status = status;
}","/**
 * Constructs an exit exception.
 * @param msg the message to be displayed.
 * @param status the status code returned via System.exit()
 */
public ExitException(String msg, int status) 
{
    super(msg);
    this.status = status;
}   ",1154,True
"/**
 * Returns true iff the specified <code>NailStats</code> object
 * is tracking the same class.
 * @param o the NailStats object to check
 * @return true iff the specified <code>NailStats</code> object
 * is tracking the same class.
 */
public boolean equals(Object o){
	NailStats other = (NailStats) o;
	return (nailclass.equals(other.nailclass));
}","/**
 * Returns true iff the specified <code>NailStats</code> object
 * is tracking the same class.
 * @param o the NailStats object to check
 * @return true iff the specified <code>NailStats</code> object
 * is tracking the same class.
 */
public boolean equals(Object o) 
{
	if (o instanceof NailStats)
	{
		NailStats ns = (NailStats)o;
		return ns.nailClass.equals(nailClass);
	}
	else
	{
		return false;
	}
}   ",1155,True
"// skips whitespace until next token
private int readNext() throws IOException{
	boolean ws;
	int next;
	do {
		next = in.read();
		switch (next) {
		case '\r':
			next = in.read();
			if ((next != '\n') && (next > 0)) {
				in.unread(next);
			}
			// fallthrough
		case '\n':
			lineNo++;
			ws = true;
			break;
		case '\000':
		case '\b':
		case '\t':
		case '\f':
		case ' ':
			ws = true;
			break;
		default:
			ws = false;
		}
	} while ((next != -1) && ws);

	return (ws) ? -1 : next;
}","// skips whitespace until next token
private int readNext() throws IOException 
{
    int ch;
    do
    {
        ch = in.read();
    } while (Character.isWhitespace((char) ch));
    return ch;
}   ",1162,True
"// FIXME: ignored
@Override
public boolean execute(OperandStack os){
	if (os.checkType(PSNumber.class, PSNumber.class, PSPackedArray.class)) {
		os.pop();
		os.pop();
		os.pop();
	} else if (os.checkType(PSNumber.class, PSNumber.class,
			PSDictionary.class)) {
		os.pop();
		os.pop();
		os.pop();
	} else {
		error(os, new TypeCheck());
	}
	return true;
}","// FIXME: ignored
@Override
public boolean execute(OperandStack os) 
{
    int value1 = os.popInt();
    int value2 = os.popInt();
    int result = value1 + value2;
    os.pushInt(result);
    return false;
}   ",1172,False
"/*
 * (non-Javadoc)
 * 
 * @see java.lang.Object#finalize()
 */
@Override
protected void finalize() throws Throwable{
	super.finalize();
	raf.close();
}","/*
 * (non-Javadoc)
 * 
 * @see java.lang.Object#finalize()
 */
@Override
protected void finalize() throws Throwable 
{
    try
    {
        if (this.mConnection != null)
        {
            this.mConnection.close();
        }
    }
    finally
    {
        super.finalize();
    }
}   ",1177,True
"/**
 * Populates the pool with the given number of database connections.
 * If the pool already contains open connections then they will be counted
 * towards the number created by this method.
 */
public void run(){
	if (num > 0  &&  num <= poolSize  &&  getSize() < num)
	{
		int count = 0;
		while (!stopped  &&  getSize() < num  &&  num <= poolSize)
		{
			try
			{
				Reusable o = create();
				if (o == null)
					throw new RuntimeException(""Null item created"");
				else
				{
					free.add(new TimeWrapper(null, o, expiryTime));
					count++;
					if (debug)
						log(""Initialized new item in pool"");
				}
			}
			catch (Exception ex)
			{
				log(ex, ""Unable to initialize items in pool"");
				stopped = true;
			}
		}
		if (debug)
			log(""Initialized pool with "" + count + "" new item"" + (count > 1 ? ""s"" : """"));
	}
}","/**
 * Populates the pool with the given number of database connections.
 * If the pool already contains open connections then they will be counted
 * towards the number created by this method.
 */




public void run() 
{
    for (int i = 0; i < numConnections; i++)
    {
        try
        {
            Connection conn = DriverManager.getConnection(url, user, password);
            pool.add(conn);
        }
        catch (SQLException e)
        {
            e.printStackTrace();
        }
    }
}   ",1181,False
"/**
 * Sets the log stream and enables logging.
 */
public synchronized void setLog(OutputStream out){
	if (log != null)
		close();
	if (out != null)
		log = new PrintStream(out);
	logging = true;
}","/**
 * Sets the log stream and enables logging.
 */

public synchronized void setLog(OutputStream out) 
{
    if (out == null)
    {
        log = null;
        return;
    }

    log = new PrintStream(out, true);
}   ",1184,True
"/**
 * Checks an object into the pool, and notify other
 * threads that may be waiting for one.
 * @param o object to check in
 */
protected final void checkIn(Reusable o){
	if (o == null)
	{
		log(""Attempt to return null item"");
		return;
	}

	synchronized(this)
	{
		firePoolCheckInEvent();

		// Check if item is from this pool
		if (!used.remove(o))
		{
			log(""Attempt to return item not belonging to pool"");
			throw new RuntimeException(""Attempt to return item not belonging to pool "" + name);
		}

		// If pool is full destroy object, else place in pool
		boolean kill = maxSize > 0  &&  (free.size() + used.size() >= poolSize);
		kill = kill  ||  (maxSize == 0  &&  free.size() >= poolSize);
		if (kill)
		{
			destroyObject(o);
			if (debug)
				log(""Checkin* - "" + used.size() + ""/"" + (used.size()+free.size()));
		}
		else
		{
			try
			{
				//  Recycle object for next use
				o.recycle();
				//  Add object to free list
				free.add(new TimeWrapper(null, o, expiryTime));
				if (debug)
					log(""Checkin  - "" + used.size() + ""/"" + (used.size()+free.size()));
				notifyAll();
			}
			catch (Exception e)
			{
				// If unable to recycle object, destroy it
				destroyObject(o);
				log(e, ""Unable to recycle item - destroyed"");
			}
		}
	}
}","/**
 * Checks an object into the pool, and notify other
 * threads that may be waiting for one.
 * @param o object to check in
 */
protected final void checkIn(Reusable o) 
{
    synchronized (this)
    {
        if (o != null)
        {
            pool.add(o);
            notifyAll();
        }
    }
}   ",1185,True
"/**
 * Closes the log.
 */
public synchronized void close(){
	logging = false;
	if (log != null)
	{
		log.flush();
		if (!isSystemLog())
			log.close();
	}
	log = null;
}","/**
 * Closes the log.
 */
public synchronized void close() 
{
    if (log != null)
    {
        log.close();
        log = null;
    }
}   ",1186,True
"/**
 * Sets the log writer and enables logging.
 */
public synchronized void setLog(PrintStream ps){
	if (log != null)
		close();
	log = ps;
	logging = true;
}","/**
 * Sets the log writer and enables logging.
 */
public synchronized void setLog(PrintStream ps) 
{
    if (ps == null)
    {
        logWriter = null;
        loggingEnabled = false;
    }
    else
    {
        logWriter = ps;
        loggingEnabled = true;
    }
}   ",1189,True
"/**
 * Flushes the pool of all currently available items, emptying the pool.
 */
public final void flush(){
	int count = 0;
	synchronized(this)
	{
		TimeWrapper tw = null;
		for (Iterator iter = free.iterator(); iter.hasNext();)
		{
			tw = (TimeWrapper)iter.next();
			iter.remove();
			destroyObject((Reusable)tw.getObject());
			count++;
		}
	}
	if (count > 0  &&  debug)
		log(""Flushed all spare items from pool"");
}","/**
 * Flushes the pool of all currently available items, emptying the pool.
 */
public final void flush() 
{
    synchronized (mPool)
    {
        mPool.clear();
    }
}   ",1190,True
"/**
 * Safely stops the thread from running.
 */
public void halt(){
	if (!isHalted())
	{
		stopped = true;
		interrupt();  // Wake cleaner if necessary
	}
}","/**
 * Safely stops the thread from running.
 */
public void halt() 
{
    if (thread != null)
    {
        thread.interrupt();
        thread = null;
    }
}   ",1191,True
"/**
 * Checks out an item from the pool. If no free item
 * is available, a new item is created unless the maximum
 * number of items has been reached. If a free item
 * is not valid it is removed from the pool and another
 * is retrieved.
 * @return item from the pool, or null if nothing available
 * @exception Exception if there is an error creating a new object
 */
protected final synchronized Reusable checkOut() throws Exception{
	if (released)
		throw new RuntimeException(""Pool no longer valid for use"");
	int oldTotalConns = used.size() + free.size();

	TimeWrapper tw = null;
	Reusable o = null;
	if (free.size() > 0)
	{
		//  Get an object from the free list
		switch(accessMethod)
		{
			case ACCESS_FIFO:
				tw = (TimeWrapper)free.remove(0);
				break;
			case ACCESS_RANDOM:
				tw = (TimeWrapper)free.remove((int)(free.size() * Math.random()));
				break;
			case ACCESS_LIFO:
			default:
				tw = (TimeWrapper)free.remove(free.size() - 1);
		}
		o = (Reusable)tw.getObject();
		boolean valid = isValid(o);
		while (!valid  &&  free.size() > 0)
		{
			destroyObject(o);
			log(""Removed invalid item from pool"");
			tw = (TimeWrapper)free.remove(0);
			o = (Reusable)tw.getObject();
			valid = isValid(o);
		}
		if (free.size() == 0  &&  !valid)
			o = null;
	}
	boolean hit = (o != null);

	// If no free items and can create more...create new item
	if (o == null)
	{
		if (maxSize > 0  &&  used.size() == maxSize)
			fireMaxSizeLimitErrorEvent();
		else if (used.size() < maxSize  ||  maxSize == 0)
		{
			o = create();
			if (!isValid(o))
				throw new RuntimeException(""Unable to create a valid connection"");
		}
	}

	// If a connection has been obtained/created, add it to used items collection
	if (o != null)
	{
		used.add(o);
		requests++;
		if (hit)
			hits++;
		firePoolCheckOutEvent();
		// Check for limit reaching so events can be fired.
		// (Events only fired on increase of connection numbers).
		int totalConns = used.size() + free.size();
		if (totalConns == poolSize  &&  totalConns > oldTotalConns)
			fireMaxPoolLimitReachedEvent();
		else if (totalConns == poolSize + 1  &&  totalConns > oldTotalConns)
			fireMaxPoolLimitExceededEvent();
		if (totalConns == maxSize  &&  totalConns > oldTotalConns)
			fireMaxSizeLimitReachedEvent();
	}
	if (debug)
	{
		String ratio = used.size() + ""/"" + (used.size() + free.size());
		String hitRate = "" (HitRate="" + getHitRate() + ""%)"";
		log(""Checkout - "" + ratio + hitRate + (o == null ? "" - null returned"" : """"));
	}
	return o;
}","/**
 * Checks out an item from the pool. If no free item
 * is available, a new item is created unless the maximum
 * number of items has been reached. If a free item
 * is not valid it is removed from the pool and another
 * is retrieved.
 * @return item from the pool, or null if nothing available
 * @exception Exception if there is an error creating a new object
 */
protected final synchronized Reusable checkOut() throws Exception 
{
    Reusable obj = null;
    if (freeObjects.size() > 0)
    {
        obj = freeObjects.remove(0);
    }
    else if (numActive < maxActive)
    {
        obj = create();
    }
    if (obj != null)
    {
        numActive++;
    }
    return obj;
}   ",1193,True
"/**
 * Releases all items from the pool, and shuts the pool down.
 * @param forced whether to forcibly destroy items, or let them be checked-in
 */
private final void release(boolean forced){
	// Set released flag to prevent check-out of new items
	if (released)
		return;
	released = true;
	//  Destroy cleaner thread
	if (cleaner != null)
	{
		cleaner.halt();
		try { cleaner.join(); }
		catch (InterruptedException ie) { log(ie, ""Interrupted during halting of old cleaner thread""); }
		cleaner = null;
	}

	synchronized(this)
	{
		int rel = 0, failed = 0;
		TimeWrapper tw = null;
		Reusable o = null;
		// Destroy all items still in use
		if (forced)
		{
			for (Iterator iter = used.iterator(); iter.hasNext();)
			{
				o = (Reusable)iter.next();
				try
				{
					destroy(o);
					rel++;
				}
				catch (Exception ex)
				{
					failed++;
					log(ex, ""Unable to release item in pool"");
				}
			}
			used.clear();
		}
		else
		{
			if (debug  &&  used.size() > 0)
				log(""Waiting for used items to be checked-in..."");
			while (used.size() > 0)
			{
				try { wait(); }
				catch (InterruptedException e) {}
			}
		}

		// Destroy all currently free items
		for (Iterator iter = free.iterator(); iter.hasNext();)
		{
			tw = (TimeWrapper)iter.next();
			o = (Reusable)tw.getObject();
			try
			{
				destroy(o);
				rel++;
			}
			catch (Exception ex)
			{
				failed++;
				log(ex, ""Unable to release item in pool"");
			}
		}
		free.clear();

		//  Destroy log reference
		if (debug)
		{
			String s = ""Released "" + rel + (rel > 1 ? "" items"" : "" item"");
			if (failed > 0)
				s += "" (failed to release "" + failed + (failed > 1 ? "" items)"" : "" item)"");
			log(s);
		}
		firePoolReleasedEvent();
		listeners.clear();
		super.close();
	}
}","/**
 * Releases all items from the pool, and shuts the pool down.
 * @param forced whether to forcibly destroy items, or let them be checked-in
 */
private final void release(boolean forced) 
{
    if (this.pool != null)
    {
        this.pool.release(forced);
        this.pool = null;
    }
}   ",1194,True
"/**
 * Creates a new PoolEvent.
 */
public ObjectPoolEvent(ObjectPool pool, int type){
	super(pool);
	this.type = type;
}","/**
 * Creates a new PoolEvent.
 */
public ObjectPoolEvent(ObjectPool pool, int type) 
{
    super(pool);
    this.type = type;
}   ",1196,True
"/**
 * Shuts down the object pool.
 * If overridden the sub-class should make sure super.finalize() is called.
 */
public void finalize(){
	if (cleaner != null)
	{
		cleaner.halt();
		cleaner = null;
	}
	if (initer != null)
	{
		initer.halt();
		initer = null;
	}
}","/**
 * Shuts down the object pool.
 * If overridden the sub-class should make sure super.finalize() is called.
 */
public void finalize() 
{
    super.finalize();
    clear();
}   ",1198,True
"/**
 * Releases all items from the pool, and shuts the pool down.
 * This method returns immediately; a background thread is created to perform the release.
 */
private final void releaseAsync(final boolean forced){
	Thread t = new Thread(new Runnable()
	{
		public void run() { release(forced); }
	});
	t.start();
}","/**
 * Releases all items from the pool, and shuts the pool down.
 * This method returns immediately; a background thread is created to perform the release.
 */
private final void releaseAsync(final boolean forced) 
{
    if (forced)
    {
        this.pool.release();
    }
    else
    {
        this.pool.releaseAsync();
    }
}   ",1199,True
"//helper function to create a species item in the list
public Map<String,?> createItem(SpeciesRow species){
	Map<String,String> item = new HashMap<String,String>();
	item.put(ITEM_COMMON_NAME, species.common_name);
	item.put(ITEM_SPECIES_NAME, species.species_name);
	item.put(""icon"", species.getImagePath());
	item.put(""_id"", species._id.toString());
	return item;
}","//helper function to create a species item in the list

public Map<String,?> createItem(SpeciesRow species) 
{
    Map<String,String> item = new HashMap<String,String>();
    item.put(""name"", species.getName());
    item.put(""description"", species.getDescription());
    item.put(""image"", species.getImage());
    return item;
}   ",1201,True
"/* Called when the activity is first created. */
@Override
public void onCreate(Bundle savedInstanceState){
	super.onCreate(savedInstanceState);
	setContentView(R.layout.splashscreen);

	new Handler().postDelayed(new Runnable() {
		public void run() {
			startActivity(new Intent(SplashScreen.this, LoginScreen.class));

			SplashScreen.this.finish();
		}
	}, SPLASH_DISPLAY_LENGHT);

	// Budburst.getDatabaseManager().initDBs();

}","/* Called when the activity is first created. */
@Override
public void onCreate(Bundle savedInstanceState) 
{
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);

    // Initialize the UI components
    initializeUI();

    // Set up the button click listener
    setButtonClickListener();
}   ",1202,False
"//creates a new instance of the current type of row
//probably do not need to extend
public Row newRow(){
	try {
		return this.getClass().newInstance();
	} catch (IllegalAccessException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	} catch (InstantiationException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
	return null;
}","//creates a new instance of the current type of row
//probably do not need to extend
public Row newRow() 
{
    Row row = new Row();
    row.setTable(this.getTable());
    return row;
}   ",1203,True
"//if you have an activity that you want to download content for, it shoud implement
//downloadable. you will have two functions consumeInputstream, and onDownloaded.
//consumeInputstream should return the inputstream returned by the http call into
//an object that can be used a String for example.\
//onDownloaded returns the object you created from consumeInputstream back to your activity
//this is where you can actually use the dat that you downloaded.
public void download(Downloadable context, int what, Download d){
	Log.d(TAG, ""start to download for "" + context.toString());
	if (!cache.containsKey(d) || d.isVolitile()) {
		new DownloadTask().execute(new DownloadObject(context, what, d));
		cache.put(d, null);
	} else if (cache.get(d) != null) {
		Message msg = new Message();
		msg.what = what;
		msg.obj = cache.get(d);
		context.onDownloaded(msg, d);
	}
}","//if you have an activity that you want to download content for, it shoud implement
//downloadable. you will have two functions consumeInputstream, and onDownloaded.
//consumeInputstream should return the inputstream returned by the http call into
//an object that can be used a String for example.\
//onDownloaded returns the object you created from consumeInputstream back to your activity
//this is where you can actually use the dat that you downloaded.
public void download(Downloadable context, int what, Download d) 
{
    switch(what)
    {
        case 0:
            consumeInputstream(context, d);
            break;
        case 1:
            onDownloaded(context, d);
            break;
    }
}   ",1204,True
"/**
 * @param stream InputStream of data from httpResponse.getContent()
 * @return a String with the contents from the response.
 */
public static String generateString(InputStream stream){
	InputStreamReader reader = new InputStreamReader(stream);
	BufferedReader buffer = new BufferedReader(reader);
	StringBuilder sb = new StringBuilder();

	try {
		String cur;
		boolean begun = false;
		while ((cur = buffer.readLine()) != null) {
			if (begun)
				sb.append(""\n"");
			else
				begun = true;
			sb.append(cur);
		}
	} catch (IOException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}

	try {
		stream.close();
	} catch (IOException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
	String returnVal = sb.toString();
	return returnVal;
}","/**
 * @param stream InputStream of data from httpResponse.getContent()
 * @return a String with the contents from the response.
 */






public static String generateString(InputStream stream) 
{
    StringBuilder builder = new StringBuilder();
    try
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader(stream));
        String line;
        while ((line = reader.readLine()) != null)
        {
            builder.append(line);
        }
    }
    catch (IOException e)
    {
        e.printStackTrace();
    }
    return builder.toString();
}   ",1205,True
"//automatically calculates the fields and values using the public fields of the object
//probably do not need to extend
public ContentValues vals(){
	ContentValues vals = new ContentValues();

	Field[] fields = getFields();
	for (int i = 0; i < fields.length; i++) {
		try {
			Object o = fields[i].get(this);
			if (o != null)
				vals.put(fields[i].getName(), o.toString());
		} catch (IllegalArgumentException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	return vals;
}","//automatically calculates the fields and values using the public fields of the object
//probably do not need to extend

public ContentValues vals() 
{
    ContentValues vals = new ContentValues();
    Field[] fields = this.getClass().getFields();
    for (Field field : fields)
    {
        try
        {
            vals.putObject(field.getName(), field.get(this));
        }
        catch (IllegalAccessException e)
        {
            e.printStackTrace();
        }
    }
    return vals;
}   ",1206,True
"// removes the users databases (if they are logged out and log in as another user for example, the database should be cleared.
public void destroyUserDatabases(){
	((SyncableDatabase) getDatabase(""site"")).removeAll();
	((SyncableDatabase) getDatabase(""plant"")).removeAll();
	((SyncableDatabase) getDatabase(""observation"")).removeAll();
}","// removes the users databases (if they are logged out and log in as another user for example, the database should be cleared.

public void destroyUserDatabases() 
{
    File dir = new File(""databases"");
    for(File file: dir.listFiles())
    {
        if (!file.isDirectory())
        {
            file.delete();
        }
    }
}   ",1207,True
"/**
 * 
 * @param ctx - pass this from your Activity or Service
 * @return true if the phone has a connection to the Internet.
 */
public static boolean isConnected(Context ctx){
	ConnectivityManager cm = (ConnectivityManager) ctx.getSystemService(Context.CONNECTIVITY_SERVICE);
	NetworkInfo[] ni = cm.getAllNetworkInfo();
	boolean connected = false;
	for (int n = 0; n < ni.length; n++) {
		// Log.d(TAG,""Network ""+ni[n].getTypeName() + "" is ""+ ni[n].getDetailedState().name() + ""\n"");
		if (ni[n].getDetailedState().name() == ""CONNECTED"")
			connected = true;
	}
	return connected;
}","/**
 * 
 * @param ctx - pass this from your Activity or Service
 * @return true if the phone has a connection to the Internet.
 */



public static boolean isConnected(Context ctx) 
{
    ConnectivityManager cm = (ConnectivityManager) ctx.getSystemService(Context.CONNECTIVITY_SERVICE);
    NetworkInfo netInfo = cm.getActiveNetworkInfo();
    return (netInfo != null && netInfo.isConnected());
}   ",1209,False
"// returns You if the username matches this users username
public static String getUserIdentifier(Context ctx, String username){
	SharedPreferences settings = ctx.getSharedPreferences(ctx.getString(R.string.prefs), 0);
	if (username.equals(settings.getString(""current_username"", no_user)))
		return ""You"";

	return username;
}","// returns You if the username matches this users username
public static String getUserIdentifier(Context ctx, String username) 
{
    if (username.equals(getUsername(ctx)))
    {
        return ""You"";
    }
    else
    {
        return username;
    }
}   ",1210,True
"/** Everytime screen is redrawn, this function is called */
@Override
public void onResume(){
	super.onResume();

	// if(netUtils.isConnected(loginScreen.this))
	// {
	if (PreferencesManager.isUserIn(this)) {
		gotoMainScreen();
	} else {
		setContentView(R.layout.loginscreen);
		vibrator = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
		usernameInput = (EditText) this.findViewById(R.id.username_text);
		passwordInput = (EditText) this.findViewById(R.id.password_text);
		registerButton = (Button) this.findViewById(R.id.register_button);

		if (PreferencesManager.getDefaultUser(this) != PreferencesManager.no_user) {
			usernameInput.setText(PreferencesManager.getDefaultUser(this));
		}

		registerButton.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v) {
				Intent intent = new Intent(Intent.ACTION_VIEW);
				intent.setData(Uri.parse(getString(R.string.registerURL)));
				startActivity(intent);
			}
		});

		loginButton = (Button) this.findViewById(R.id.login_button);
		loginButton.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v) {
				InputMethodManager imm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
				imm.hideSoftInputFromWindow(usernameInput.getWindowToken(), 0);
				attemptLogin();
			}
		});
		
		
		testLoginButton = (Button) this.findViewById(R.id.test_login_button);
		testLoginButton.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v) {
				PreferencesManager.letUserIn(""test"", ""test"", LoginScreen.this);
				gotoMainScreen();
			}
		});
	}
	// }
	// else
	// {
	// setContentView(R.layout.loginscreen);
	//
	// // Warn the user that there is no internet.
	// AlertDialog.Builder builder = new AlertDialog.Builder(
	// loginScreen.this);
	// builder
	// .setMessage(
	// ""Currently there is no network connection.  Please open up the web browser and see what message appears.  If the browser says you need to upgrade data plan, please contact UCLA.  Otherwise, just retry this when you have proper cell service."")
	// .setCancelable(false).setPositiveButton(
	// ""Okay"",
	// new DialogInterface.OnClickListener() {
	// public void onClick(
	// DialogInterface dialog, int id) {
	// loginScreen.this.finish();
	// }
	// });
	// AlertDialog alert = builder.create();
	// alert.show();
	//
	// }
}","/** Everytime screen is redrawn, this function is called */
@Override
public void onResume() 
{
    super.onResume();
    if (this.mGLView != null)
    {
        this.mGLView.onResume();
    }
}   ",1212,False
"//similar to has one, but used for models which have many of another model
//returns hasMany for table name, on field match with value value, with optional filter
//uses a RelationRow to do the maping with an optional filter
//look at SpeciesRow, PhenophaseRow, and SpeciesPhenophaseRow for an example of how it
//is used
protected ArrayList<Row> hasMany(String name, String match, String value, String filter){
	ArrayList<Row> this_that = Budburst.getDatabaseManager().getDatabase(getName() + ""_"" + name).find(match + ""="" + value);
	// for (Iterator<Row> i = this_that.iterator(); i.hasNext();) {
	// Log.d(TAG, i.next().toString());
	// }
	if (filter != null && !filter.trim().equals(""""))
		filter += "" AND "";
	return Budburst.getDatabaseManager().getDatabase(name).find(this_that, name + ""_id"", filter);
}","//similar to has one, but used for models which have many of another model
//returns hasMany for table name, on field match with value value, with optional filter
//uses a RelationRow to do the maping with an optional filter
//look at SpeciesRow, PhenophaseRow, and SpeciesPhenophaseRow for an example of how it
//is used
protected ArrayList<Row> hasMany(String name, String match, String value, String filter) 
{
    ArrayList<Row> rows = new ArrayList<Row>();
    for(Row row : rows)
    {
        if(row.getValue(match).equals(value))
        {
            rows.add(row);
        }
    }
    return rows;
}   ",1213,True
"//reads in the cursor returned from the database to create a model
public void readCursor(Cursor c){
	Field[] fields = getFields();
	for (int i = 0; i < fields.length; i++) {
		try {
			if (fields[i].getType().equals(Long.class))
				fields[i].set(this, c.getLong(i));
			else if (fields[i].getType().equals(String.class))
				fields[i].set(this, c.getString(i));
			else if (fields[i].getType().equals(Boolean.class))
				fields[i].set(this, c.getString(i).equals(""true""));
			else if (fields[i].getType().equals(Double.class))
				fields[i].set(this, c.getDouble(i));
		} catch (IllegalArgumentException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IllegalAccessException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}","//reads in the cursor returned from the database to create a model

public void readCursor(Cursor c) 
{
    if (c.moveToFirst())
    {
        do
        {
            //get the data from the cursor
            int id = c.getInt(c.getColumnIndex(""_id""));
            String name = c.getString(c.getColumnIndex(""name""));
            String email = c.getString(c.getColumnIndex(""email""));
            String phone = c.getString(c.getColumnIndex(""phone""));

            //create a new model object
            Model model = new Model(id, name, email, phone);

            //add the model to the list
            modelList.add(model);

        } while (c.moveToNext());
    }
}   ",1216,False
"/**
 * Constructs an empty gadget.
 */
public Gadget(){
  super(ElementType.GADGET);
  setUrl("""");
}","/**
 * Constructs an empty gadget.
 */
public Gadget() 
{
    this.name = """";
    this.price = 0;
    this.quantity = 0;
    this.power = 0;
}   ",1221,True
"/**
 * Constructs a StyledText object, initializing it with a string of text and
 * an initial style.
 * 
 * @param text The text to styled.
 * @param style The style to be applied to the text.
 */
public StyledText(String text, StyleType style){
  this(text);
  styles.add(style);
}","/**
 * Constructs a StyledText object, initializing it with a string of text and
 * an initial style.
 * 
 * @param text The text to styled.
 * @param style The style to be applied to the text.
 */
public StyledText(String text, StyleType style) 
{
    this.text = text;
    this.style = style;
}   ",1222,True
"/**
 * Helper method to subtract annotations that covers <code>point</code> to
 * <code>length</code> range, and shift the ones that start after.
 * 
 * @param point the starting point of that determines which annotations
 *     should be shifted.
 * @param length the length of the entity that is about to be deleted
 */
private void shrinkOrShiftAnnotations(int point, int length){
  ListIterator<Annotation> iterator = blipData.getAnnotations().listIterator();
  while (iterator.hasNext()) {
    Range range = iterator.next().getRange();
    int start = range.getStart();
    int end = range.getEnd();
    
    // There are six cases to consider, since start and end can each be in three different
    // states: before, in, or after the ""deleted"" range. However, we ignore the case where
    // both start and end are before the ""deleted"" range. We also assume that start < end.
    if (start < point) {
      if (end >= point + length) {
        // Case 1: Start is before, end is after the deleted range.
        range.setEnd(end - length);
      } else if (end >= point) {
        // Case 2: Start is before, end is in the deleted range.
        range.setEnd(point);
      } else {
        // Case 3: Start and end are before the deleted range. Do nothing.
      }
    } else if (start >= point + length) {
      // Case 4: Start and end are after the deleted range.
      range.setStart(start - length);
      range.setEnd(end - length);
    } else {
      if (end > point + length) {
        // Case 5: Start is inside, end is after the deleted range.
        range.setStart(point);
        range.setEnd(end - length);
      } else {
        // Case 6: Start is inside, end is inside the deleted range. Delete the annotation.
        iterator.remove();
      }
    }
  }
}","/**
 * Helper method to subtract annotations that covers <code>point</code> to
 * <code>length</code> range, and shift the ones that start after.
 * 
 * @param point the starting point of that determines which annotations
 *     should be shifted.
 * @param length the length of the entity that is about to be deleted
 */

private void shrinkOrShiftAnnotations(int point, int length) 
{
    for (Annotation a : annotations)
    {
        if (a.getStart() >= point)
        {
            if (a.getStart() >= point + length)
            {
                a.setStart(a.getStart() - length);
            }
            else
            {
                a.setEnd(point);
            }
        }
    }
}   ",1228,False
"/**
 * Constructs an empty BlipData object.
 */
public BlipData(){
  annotations = new ArrayList<Annotation>();
  elements = new HashMap<String, Element>();
  creator = null;
  childBlipIds = new ArrayList<String>();
  content = ""\n"";
  contributors = new ArrayList<String>();
  blipId = null;
  lastModifiedTime = -1L;
  version = -1L;
  parentBlipId = null;
  waveId = null;
  waveletId = null;
}","/**
 * Constructs an empty BlipData object.
 */

public BlipData() 
{
    this.blipData = new ArrayList<Blip>();
}   ",1229,False
"/**
 * Inserts text at the starting index provided. Styles applying to the current
 * text will apply to the combined text. If the index does not exist,
 * the text is appended to the end of the document.
 * 
 * @param start index into current text with which to perform the insertion.
 * @param text the text to be inserted.
 */
public void insertText(int start, String text){
  StringBuilder sb = new StringBuilder(this.text);
  sb.insert(start, text);
  this.text = sb.toString();
}","/**
 * Inserts text at the starting index provided. Styles applying to the current
 * text will apply to the combined text. If the index does not exist,
 * the text is appended to the end of the document.
 * 
 * @param start index into current text with which to perform the insertion.
 * @param text the text to be inserted.
 */
public void insertText(int start, String text) 
{
    if (start > mText.length())
    {
        mText.append(text);
    }
    else
    {
        mText.insert(start, text);
    }
}   ",1230,True
"/**
 * Validates the members of the annotation.
 */
private void validate(){
  if (name == null || name.isEmpty()) {
    throw new IllegalArgumentException(""The annotation name must not be null or empty."");
  }
  
  if (value == null) {
    throw new IllegalArgumentException(""The annotation value must not be null."");
  }
}","/**
 * Validates the members of the annotation.
 */
private void validate() 
{
    if (mType == null)
    {
        throw new IllegalStateException(""Type must be set"");
    }
    if (mValue == null)
    {
        throw new IllegalStateException(""Value must be set"");
    }
}   ",1232,True
"/**
 * Constructs a Wave image given an attachment id and a caption.
 * 
 * @param attachmentId the attachment id of the wave image.
 * @param caption the captopm for the image.
 */
public Image(String attachmentId, String caption){
  this();
  setAttachmentId(attachmentId);
  setCaption(caption);
}","/**
 * Constructs a Wave image given an attachment id and a caption.
 * 
 * @param attachmentId the attachment id of the wave image.
 * @param caption the captopm for the image.
 */
public Image(String attachmentId, String caption) 
{
    this.attachmentId = attachmentId;
    this.caption = caption;
}   ",1234,True
"/**
 * Require the availability of the specified blipId for this bundle.
 * 
 * @param blipId the id of the blip that is required.
 * @param contexts we need for this blip.
 */
public void requireBlip(String blipId, List<Context> contexts){
  Set<Context> contextSet = requiredBlips.get(blipId);
  if (contextSet == null) {
    contextSet = new HashSet<Context>();
    requiredBlips.put(blipId, contextSet);
  }
  for (Context context : contexts) {
    contextSet.add(context);
  }
}","/**
 * Require the availability of the specified blipId for this bundle.
 * 
 * @param blipId the id of the blip that is required.
 * @param contexts we need for this blip.
 */
public void requireBlip(String blipId, List<Context> contexts) 
{
    if (blipId == null)
    {
        throw new IllegalArgumentException(""blipId must not be null"");
    }

    if (contexts == null)
    {
        throw new IllegalArgumentException(""contexts must not be null"");
    }

    if (!blips.containsKey(blipId))
    {
        blips.put(blipId, new Blip(blipId, contexts));
    }
    else
    {
        blips.get(blipId).addContexts(contexts);
    }
}   ",1235,True
"/**
 * Constructs a range object given a start and end index into the document.
 * 
 * @param start Start of the range.
 * @param end End of the range.
 */
public Range(int start, int end){
  // TODO(scovitz): Figure out why Spelly generates zero length range here.
//    if (end - start <= 0) {
//      throw new RuntimeException(""Range length cannot be zero or negative."");
//    } else {
    this.start = start;
    this.end = end;
//    }
}","/**
 * Constructs a range object given a start and end index into the document.
 * 
 * @param start Start of the range.
 * @param end End of the range.
 */
public Range(int start, int end) 
{
    this.start = start;
    this.end = end;
}   ",1237,True
"/**
 * Constructs an external image given a url, image dimensions, and a caption.
 * 
 * @param url the url for the external image.
 * @param width the width of the image.
 * @param height the height of the image.
 * @param caption the caption for the image.
 */
public Image(String url, int width, int height, String caption){
  this();
  setUrl(url);
  setWidth(width);
  setHeight(height);
  setCaption(caption);
}","/**
 * Constructs an external image given a url, image dimensions, and a caption.
 * 
 * @param url the url for the external image.
 * @param width the width of the image.
 * @param height the height of the image.
 * @param caption the caption for the image.
 */
public Image(String url, int width, int height, String caption) 
{
    this.url = url;
    this.width = width;
    this.height = height;
    this.caption = caption;
}   ",1238,True
"/**
 * Constructs a gadget for the specified url.
 *  
 * @param url the url of the gadget specification.
 */
public Gadget(String url){
  super(ElementType.GADGET);
  setUrl(url);
}","/**
 * Constructs a gadget for the specified url.
 *  
 * @param url the url of the gadget specification.
 */
public Gadget(String url) 
{
  this.url = url;
  this.gadgetSpec = new GadgetSpec(url);
  this.view = new GadgetView(this);
}   ",1239,False
"//GEN-LAST:event_jPanel2MouseMoved
private void moreHandActionPerformed(java.awt.event.ActionEvent evt){//GEN-FIRST:event_moreHandActionPerformed
        offset = (offset + 1) % max_offset;
        update();
    }","//GEN-LAST:event_jPanel2MouseMoved
private void moreHandActionPerformed(java.awt.event.ActionEvent evt) 
{//GEN-FIRST:event_moreHandActionPerformed
    if (moreHand.isSelected())
    {
        moreHand.setIcon(new javax.swing.ImageIcon(getClass().getResource(""/images/moreHand.png"")));
        moreHand.setSelected(false);
    }
    else
    {
        moreHand.setIcon(new javax.swing.ImageIcon(getClass().getResource(""/images/moreHand2.png"")));
        moreHand.setSelected(true);
    }
}   ",1242,True
"//GEN-LAST:event_playerOneTextKeyTyped
private void playerTwoTextKeyTyped(java.awt.event.KeyEvent evt){//GEN-FIRST:event_playerTwoTextKeyTyped
        if (playerOneText.getText().length() > 0
                && playerTwoText.getText().length() > 0) {
            startButton.setEnabled(true);
        } else {
            startButton.setEnabled(false);
        }
    }","//GEN-LAST:event_playerOneTextKeyTyped
private void playerTwoTextKeyTyped(java.awt.event.KeyEvent evt) 
{
    if (evt.getKeyChar() == '\n')
    {
        playerTwoText.transferFocus();
    }
}   ",1244,True
"//GEN-LAST:event_playerOneEditButtonActionPerformed
private void playerTwoEditButtonActionPerformed(java.awt.event.ActionEvent evt){//GEN-FIRST:event_playerTwoEditButtonActionPerformed
        String player2 = playerTwoText.getText();

        String filename = player2 + "".ser"";

        User user2 = null;
        FileInputStream fis = null;
        ObjectInputStream in = null;

        try {
            fis = new FileInputStream(filename);
            in = new ObjectInputStream(fis);
            user2 = (User) in.readObject();
            in.close();
        } catch (IOException readEx) {
            user2 = new User(player2);
            Login.serialize(user2, player2);

            //readEx.printStackTrace();
        } catch (ClassNotFoundException ex) {
            ex.printStackTrace();
        }
        EditorUI e = new EditorUI(user2);
        e.run(user2);
    }","//GEN-LAST:event_playerOneEditButtonActionPerformed
private void playerTwoEditButtonActionPerformed(java.awt.event.ActionEvent evt) 
{
    if (playerTwoEditButton.getText().equals(""Edit""))
    {
        playerTwoNameField.setEditable(true);
        playerTwoEditButton.setText(""Done"");
    }
    else
    {
        playerTwoNameField.setEditable(false);
        playerTwoEditButton.setText(""Edit"");
    }
}   ",1246,False
"//GEN-LAST:event_playerTwoEditButtonActionPerformed
private void startButtonActionPerformed(java.awt.event.ActionEvent evt){//GEN-FIRST:event_startButtonActionPerformed
        String player1 = playerOneText.getText();
        String player2 = playerTwoText.getText();

        String filename1 = player1 + "".ser"";
        String filename2 = player2 + "".ser"";

        // unserialize user1
        User user1 = null;
        FileInputStream fis = null;
        ObjectInputStream in = null;

        try {
            fis = new FileInputStream(filename1);
            in = new ObjectInputStream(fis);
            user1 = (User) in.readObject();
            in.close();
        } catch (IOException readEx) {
            user1 = new User(player1);
            Login.serialize(user1, player1);

        } catch (ClassNotFoundException ex) {
            ex.printStackTrace();
        }

        // unserialize user2
        User user2 = null;
        FileInputStream fis2 = null;
        ObjectInputStream in2 = null;

        try {
            fis2 = new FileInputStream(filename2);
            in2 = new ObjectInputStream(fis2);
            user2 = (User) in2.readObject();
            in2.close();
        } catch (IOException readEx2) {
            user2 = new User(player2);
            Login.serialize(user2, player2);

        } catch (ClassNotFoundException ex2) {
            ex2.printStackTrace();
        }
        GameStartUI g = new GameStartUI(user1,user2);
        g.run();
    }","//GEN-LAST:event_playerTwoEditButtonActionPerformed
private void startButtonActionPerformed(java.awt.event.ActionEvent evt) 
{//GEN-FIRST:event_startButtonActionPerformed
    if (game != null)
    {
        game.start();
    }
}   ",1247,False
"//GEN-LAST:event_playerTwoTextActionPerformed
private void playerOneEditButtonActionPerformed(java.awt.event.ActionEvent evt){//GEN-FIRST:event_playerOneEditButtonActionPerformed
        String player1 = playerOneText.getText();

        String filename = player1 + "".ser"";

        User user1 = null;
        FileInputStream fis = null;
        ObjectInputStream in = null;

        try {
            fis = new FileInputStream(filename);
            in = new ObjectInputStream(fis);
            user1 = (User) in.readObject();
            in.close();
        } catch (IOException readEx) {
            user1 = new User(player1);
            Login.serialize(user1, player1);

            // testing print
            //readEx.printStackTrace();
        } catch (ClassNotFoundException ex) {
            ex.printStackTrace();
        }


        EditorUI e = new EditorUI(user1);
        e.run(user1);

    }","//GEN-LAST:event_playerTwoTextActionPerformed
private void playerOneEditButtonActionPerformed(java.awt.event.ActionEvent evt) 
{
    if (playerOneEditButton.getText().equals(""Edit""))
    {
        playerOneText.setEditable(true);
        playerOneEditButton.setText(""Done"");
    }
    else
    {
        playerOneText.setEditable(false);
        playerOneEditButton.setText(""Edit"");
    }
}   ",1250,False
"// Ends game
public Player winner(){
    //TODO: Make game end
    boolean p1lost = true;
    boolean p2lost = true;


    p1lost = p1lost && (p.getLife().get(Color.NEUTRAL) == 0);
    p2lost = p2lost && (opp.getLife().get(Color.NEUTRAL) == 0);
    p1lost = (p1lost || p.getDeck().isEmpty());
    p2lost = (p2lost || opp.getDeck().isEmpty());

    if (p1lost && !p2lost) {
        return opp;
    } else if (p2lost && !p1lost) {
        return p;
    } else //Throw a tie game exception?
    {
        return null;
    }

}","// Ends game
public Player winner() 
{
    if (this.getScore() >= 100)
    {
        return this;
    }
    else
    {
        return null;
    }
}   ",1251,True
"/** Creates new form GameBoard */
public GameBoard(Player p, Player opp, Rules r){
    this.p = p;
    this.opp = opp;
    this.r = r;
    offset = 0;

    initComponents();
    update();
}","/** Creates new form GameBoard */
public GameBoard(Player p, Player opp, Rules r) 
{
    player = p;
    opponent = opp;
    rules = r;
    initComponents();
    this.setTitle(""Game Board"");
    this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    this.setResizable(false);
    this.pack();
    this.setVisible(true);
}   ",1252,True
"/**
 * Put a key/value pair in the JSONObject. If the value is null,
 * then the key will be removed from the JSONObject if it is present.
 * @param key   A key string.
 * @param value An object which is the value. It should be of one of these
 *  types: Boolean, Double, Integer, JSONArray, JSONObject, Long, String,
 *  or the JSONObject.NULL object.
 * @return this.
 * @throws JSONException If the value is non-finite number
 *  or if the key is null.
 */
public JSONObject put(String key, Object value) throws JSONException{
    if (key == null) {
        throw new JSONException(""Null key."");
    }
    if (value != null) {
        testValidity(value);
        this.map.put(key, value);
    } else {
        remove(key);
    }
    return this;
}","/**
 * Put a key/value pair in the JSONObject. If the value is null,
 * then the key will be removed from the JSONObject if it is present.
 * @param key   A key string.
 * @param value An object which is the value. It should be of one of these
 *  types: Boolean, Double, Integer, JSONArray, JSONObject, Long, String,
 *  or the JSONObject.NULL object.
 * @return this.
 * @throws JSONException If the value is non-finite number
 *  or if the key is null.
 */
public JSONObject put(String key, Object value) throws JSONException 
{
    if (key == null)
    {
        throw new JSONException(""Null key."");
    }
    if (value != null)
    {
        testValidity(value);
        this.map.put(key, value);
    }
    else
    {
        this.remove(key);
    }
    return this;
}   ",1261,True
"/**
 * Construct a JSONObject from a Map.
 * 
 * Note: Use this constructor when the map contains <key,bean>.
 * 
 * @param map - A map with Key-Bean data.
 * @param includeSuperClass - Tell whether to include the super class properties.
 */
public JSONObject(Map map, boolean includeSuperClass){
   	this.map = new HashMap();
   	if (map != null){
        for (Iterator i = map.entrySet().iterator(); i.hasNext(); ) {
            Map.Entry e = (Map.Entry)i.next();
            this.map.put(e.getKey(), new JSONObject(e.getValue(), includeSuperClass));
        }
   	}
}","/**
 * Construct a JSONObject from a Map.
 * 
 * Note: Use this constructor when the map contains <key,bean>.
 * 
 * @param map - A map with Key-Bean data.
 * @param includeSuperClass - Tell whether to include the super class properties.
 */



public JSONObject(Map map, boolean includeSuperClass) 
{
    if (map instanceof JSONObject) {
        this.myHashMap = ((JSONObject) map).myHashMap;
    } else {
        this.myHashMap = new HashMap();
        if (map != null) {
            Iterator i = map.entrySet().iterator();
            while (i.hasNext()) {
                Map.Entry e = (Map.Entry) i.next();
                Object value = e.getValue();
                if (includeSuperClass || !(value instanceof Bean)) {
                    this.myHashMap.put(e.getKey(), wrap(value));
                }
            }
        }
    }
}   ",1263,True
"/*
 * Transforms 'foo': ... into foo: ... whenever possible, saving 2 bytes.
 */
private static void optimizeObjLitMemberDecl(ArrayList tokens){

    String tv;
    int i, length;
    JavaScriptToken token;

    for (i = 0, length = tokens.size(); i < length; i++) {
        if (((JavaScriptToken) tokens.get(i)).getType() == Token.OBJECTLIT &&
                i > 0 && ((JavaScriptToken) tokens.get(i - 1)).getType() == Token.STRING) {
            token = (JavaScriptToken) tokens.get(i - 1);
            tv = token.getValue();
            tv = tv.substring(1, tv.length() - 1);
            if (isValidIdentifier(tv)) {
                tokens.set(i - 1, new JavaScriptToken(Token.NAME, tv));
            }
        }
    }
}","/*
 * Transforms 'foo': ... into foo: ... whenever possible, saving 2 bytes.
 */
private static void optimizeObjLitMemberDecl(ArrayList tokens) 
{
    int i = 0;
    while (i < tokens.size() - 2) {
        Object token = tokens.get(i);
        if (token == StandardTokenTypes.T_IDENTIFIER && ""foo"".equals(tokens.get(i + 1))) {
            tokens.remove(i);
            tokens.set(i, ""foo"");
        }
        i++;
    }
}   ",1264,False
"/*
 * If either 'eval' or 'with' is used in a local scope, we must make
 * sure that all containing local scopes don't get munged. Otherwise,
 * the obfuscation would potentially introduce bugs.
 */
private void protectScopeFromObfuscation(ScriptOrFnScope scope){
    assert scope != null;

    if (scope == globalScope) {
        // The global scope does not get obfuscated,
        // so we don't need to worry about it...
        return;
    }

    // Find the highest local scope containing the specified scope.
    while (scope.getParentScope() != globalScope) {
        scope = scope.getParentScope();
    }

    assert scope.getParentScope() == globalScope;
    scope.preventMunging();
}","/*
 * If either 'eval' or 'with' is used in a local scope, we must make
 * sure that all containing local scopes don't get munged. Otherwise,
 * the obfuscation would potentially introduce bugs.
 */
private void protectScopeFromObfuscation(ScriptOrFnScope scope) 
{
    if (scope.getVar(""eval"") != null || scope.getVar(""with"") != null)
    {
        scope.addVar(""eval"", false);
        scope.addVar(""with"", false);
    }
}   ",1265,True
"/**
 * Produce a string in double quotes with backslash sequences in all the
 * right places. A backslash will be inserted within </, allowing JSON
 * text to be delivered in HTML. In JSON text, a string cannot contain a
 * control character or an unescaped quote or backslash.
 * @param string A String
 * @return  A String correctly formatted for insertion in a JSON text.
 */
public static String quote(String string){
    if (string == null || string.length() == 0) {
        return ""\""\"""";
    }

    char         b;
    char         c = 0;
    int          i;
    int          len = string.length();
    StringBuffer sb = new StringBuffer(len + 4);
    String       t;

    sb.append('""');
    for (i = 0; i < len; i += 1) {
        b = c;
        c = string.charAt(i);
        switch (c) {
        case '\\':
        case '""':
            sb.append('\\');
            sb.append(c);
            break;
        case '/':
            if (b == '<') {
                sb.append('\\');
            }
            sb.append(c);
            break;
        case '\b':
            sb.append(""\\b"");
            break;
        case '\t':
            sb.append(""\\t"");
            break;
        case '\n':
            sb.append(""\\n"");
            break;
        case '\f':
            sb.append(""\\f"");
            break;
        case '\r':
            sb.append(""\\r"");
            break;
        default:
            if (c < ' ' || (c >= '\u0080' && c < '\u00a0') ||
                           (c >= '\u2000' && c < '\u2100')) {
                t = ""000"" + Integer.toHexString(c);
                sb.append(""\\u"" + t.substring(t.length() - 4));
            } else {
                sb.append(c);
            }
        }
    }
    sb.append('""');
    return sb.toString();
}","/**
 * Produce a string in double quotes with backslash sequences in all the
 * right places. A backslash will be inserted within </, allowing JSON
 * text to be delivered in HTML. In JSON text, a string cannot contain a
 * control character or an unescaped quote or backslash.
 * @param string A String
 * @return  A String correctly formatted for insertion in a JSON text.
 */
public static String quote(String string) 
{
    if (string == null || string.length() == 0) {
        return ""\""\"""";
    }

    char         b;
    char         c = 0;
    int          i;
    int          len = string.length();
    StringBuilder sb = new StringBuilder(len + 4);
    String       t;

    sb.append('""');
    for (i = 0; i < len; i += 1) {
        b = c;
        c = string.charAt(i);
        switch (c) {
        case '\\':
        case '""':
            sb.append('\\');
            sb.append(c);
            break;
        case '/':
            if (b == '<') {
                sb.append('\\');
            }
            sb.append(c);
            break;
        default:
            sb.append(c);
        }
    }
    sb.append('""');
    return sb.toString();
}   ",1267,False
"/**
 * Put a key/value pair in the JSONObject, but only if the
 * key and the value are both non-null.
 * @param key   A key string.
 * @param value An object which is the value. It should be of one of these
 *  types: Boolean, Double, Integer, JSONArray, JSONObject, Long, String,
 *  or the JSONObject.NULL object.
 * @return this.
 * @throws JSONException If the value is a non-finite number.
 */
public JSONObject putOpt(String key, Object value) throws JSONException{
    if (key != null && value != null) {
        put(key, value);
    }
    return this;
}","/**
 * Put a key/value pair in the JSONObject, but only if the
 * key and the value are both non-null.
 * @param key   A key string.
 * @param value An object which is the value. It should be of one of these
 *  types: Boolean, Double, Integer, JSONArray, JSONObject, Long, String,
 *  or the JSONObject.NULL object.
 * @return this.
 * @throws JSONException If the value is a non-finite number.
 */
public JSONObject putOpt(String key, Object value) throws JSONException 
{
    if (key != null && value != null)
    {
        put(key, value);
    }
    return this;
}   ",1269,True
"/**
 * Get an array of field names from an Object.
 *
 * @return An array of field names, or null if there are no names.
 */
public static String[] getNames(Object object){
	if (object == null) {
		return null;
	}
	Class klass = object.getClass();
	Field[] fields = klass.getFields();
	int length = fields.length;
	if (length == 0) {
		return null;
	}
	String[] names = new String[length];
	for (int i = 0; i < length; i += 1) {
		names[i] = fields[i].getName();
	}
    return names;
}","/**
 * Get an array of field names from an Object.
 *
 * @return An array of field names, or null if there are no names.
 */
public static String[] getNames(Object object) 
{
    Field[] fields = object.getClass().getDeclaredFields();
    String[] names = new String[fields.length];
    for (int i = 0; i < fields.length; i++)
    {
        names[i] = fields[i].getName();
    }
    return names;
}   ",1275,True
"/**
     * Construct a JSONObject from an Object, using reflection to find the
     * public members. The resulting JSONObject's keys will be the strings
     * from the names array, and the values will be the field values associated
     * with those keys in the object. If a key is not found or not visible,
     * then it will not be copied into the new JSONObject.
     * @param object An object that has fields that should be used to make a
     * JSONObject.
     * @param names An array of strings, the names of the fields to be obtained
     * from the object.
     */
public JSONObject(Object object, String names[]){
        this();
        Class c = object.getClass();
        for (int i = 0; i < names.length; i += 1) {
            String name = names[i];
        	try {
                putOpt(name, c.getField(name).get(object));
        	} catch (Exception e) {
                /* forget about it */
            }
        }    
    }","/**
     * Construct a JSONObject from an Object, using reflection to find the
     * public members. The resulting JSONObject's keys will be the strings
     * from the names array, and the values will be the field values associated
     * with those keys in the object. If a key is not found or not visible,
     * then it will not be copied into the new JSONObject.
     * @param object An object that has fields that should be used to make a
     * JSONObject.
     * @param names An array of strings, the names of the fields to be obtained
     * from the object.
     */
public JSONObject(Object object, String names[]) 
{
    try
    {
        for(int i = 0; i < names.length; i += 1)
        {
            this.put(names[i], object.getClass().getField(names[i]).get(object));
        }
    }
    catch(Exception e)
    {
        e.printStackTrace();
    }
}    ",1277,True
"/**
 * Put a key/value pair in the JSONObject, but only if the key and the 
 * value are both non-null, and only if there is not already a member 
 * with that name.
 * @param key
 * @param value
 * @return his.
 * @throws JSONException if the key is a duplicate
 */
public JSONObject putOnce(String key, Object value) throws JSONException{
    if (key != null && value != null) {
    	if (opt(key) != null) {
            throw new JSONException(""Duplicate key \"""" + key + ""\"""");
    	}
        put(key, value);
    }
    return this;
}","/**
 * Put a key/value pair in the JSONObject, but only if the key and the 
 * value are both non-null, and only if there is not already a member 
 * with that name.
 * @param key
 * @param value
 * @return his.
 * @throws JSONException if the key is a duplicate
 */
public JSONObject putOnce(String key, Object value) throws JSONException 
{
    if (key == null)
    {
        throw new JSONException(""Null key."");
    }
    if (value != null)
    {
        this.map.put(key, value);
    }
    return this;
}   ",1279,True
"/**
 * For a given token, determines the type as needed by the antlr parser.
 * @param token The original cobol token.
 * @return The type extracted from X.tokens (via Properties).
 */
private int getTypeFor(final CobolToken token){
    String value = null;
    String correct = null;
    CobolType originalType = token.getType();
    String content = token.getText();
    switch (originalType) {
        case WORD:
            /*  WORD includes keywords (like PERFORM) and data names.
             *  For keywords, the type is specific; for data names,
             *  the type is always generic (WORD).
             */

            //  Antlr names use ""_"" instead of Cobol's ""-"".
            //  Antlr grammar always use uppercase.
            if (content.equals(""-"")) {
                //  Single hypen.
                correct = content;
            }
            else {
                correct = content.replace('-', '_').toUpperCase();
                }

            /**
             * Synonyms:
             * THROUGH same type as THRU
             * AREAS same type as AREA.
             * Operators:
             * '+' -> Use 'OP_PLUS' to search in the dictionary.
             * '-' -> Use 'OP_MINUS' ...
             */
            char first = correct.charAt(0);
            if (!Character.isDigit(first)) {
                correct = (Character.isLetter(first)) ? getSynonym(correct) : getTextForOperator(correct);
                }

            value = tokenDictionary.getProperty(correct);
            if (value == null) {
                value = tokenDictionary.getProperty(""WORD"");
            }
            break;
        case SEPARATOR:
            if (content.equals(""."")) {
                value = tokenDictionary.getProperty(""PERIOD"");
            }
            if (content.equals("","")) {
                value = tokenDictionary.getProperty(""COMMA_SEP"");
            }
            if (content.equals("";"")) {
                value = tokenDictionary.getProperty(""SEMICOLON_SEP"");
            }
            break;
        default:
            String key = originalType.toString();
            value = tokenDictionary.getProperty(key);
            break;
    }
    assert value != null : ""Type not found for text='"" + content + ""'"";
    return Integer.parseInt(value);
}","/**
 * For a given token, determines the type as needed by the antlr parser.
 * @param token The original cobol token.
 * @return The type extracted from X.tokens (via Properties).
 */
private int getTypeFor(final CobolToken token) 
{
    int type = -1;
    if (token != null)
    {
        String tokenName = token.getTokenName();
        if (tokenName != null)
        {
            type = getTypeFor(tokenName);
        }
    }
    return type;
}   ",1282,False
"/**
 * Constructor.
 *
 * @param tokenDictionary The properties file generated by antlr
 * for the parser. For a grammar X, the file name is X.tokens
 */
public TokenFactory(Properties tokenDictionary){
    this.tokenDictionary = tokenDictionary;
    this.filterType = new TokenFilterByType();
    this.filterType.addType(CobolType.COMMENT, false);
    this.filterType.addType(CobolType.NEW_PAGE, false);
    this.filterType.addType(CobolType.SPECIAL_LINE, false);
    this.filterText = new TokenFilterByText();
    this.filterText.addText("","", false);
    this.filterText.addText("";"", false);
}","/**
 * Constructor.
 *
 * @param tokenDictionary The properties file generated by antlr
 * for the parser. For a grammar X, the file name is X.tokens
 */
public TokenFactory(Properties tokenDictionary) 
{
    this.tokenDictionary = tokenDictionary;
}   ",1286,True
"// $ANTLR start ""input_output_clause""
// /home/andres/NetBeansProjects/jCobolParser/src/jcobol/parser/divisions/EnvironmentDivision.g:204:1: input_output_clause : ( file_control | i_o_control );
public final EnvironmentDivision.input_output_clause_return input_output_clause() throws RecognitionException{
    EnvironmentDivision.input_output_clause_return retval = new EnvironmentDivision.input_output_clause_return();
    retval.start = input.LT(1);

    CommonTree root_0 = null;

    EnvironmentDivision.file_control_return file_control131 = null;

    EnvironmentDivision.i_o_control_return i_o_control132 = null;



    try {
        // /home/andres/NetBeansProjects/jCobolParser/src/jcobol/parser/divisions/EnvironmentDivision.g:205:2: ( file_control | i_o_control )
        int alt51=2;
        int LA51_0 = input.LA(1);

        if ( (LA51_0==FILE_CONTROL) ) {
            alt51=1;
        }
        else if ( (LA51_0==I_O_CONTROL) ) {
            alt51=2;
        }
        else {
            NoViableAltException nvae =
                new NoViableAltException("""", 51, 0, input);

            throw nvae;
        }
        switch (alt51) {
            case 1 :
                // /home/andres/NetBeansProjects/jCobolParser/src/jcobol/parser/divisions/EnvironmentDivision.g:205:4: file_control
                {
                root_0 = (CommonTree)adaptor.nil();

                pushFollow(FOLLOW_file_control_in_input_output_clause1438);
                file_control131=file_control();

                state._fsp--;

                adaptor.addChild(root_0, file_control131.getTree());

                }
                break;
            case 2 :
                // /home/andres/NetBeansProjects/jCobolParser/src/jcobol/parser/divisions/EnvironmentDivision.g:205:19: i_o_control
                {
                root_0 = (CommonTree)adaptor.nil();

                pushFollow(FOLLOW_i_o_control_in_input_output_clause1442);
                i_o_control132=i_o_control();

                state._fsp--;

                adaptor.addChild(root_0, i_o_control132.getTree());

                }
                break;

        }
        retval.stop = input.LT(-1);

        retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
        adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);

    }
    catch (RecognitionException re) {
        reportError(re);
        recover(input,re);
	retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);

    }
    finally {
    }
    return retval;
}","// $ANTLR start ""input_output_clause""
// /home/andres/NetBeansProjects/jCobolParser/src/jcobol/parser/divisions/EnvironmentDivision.g:204:1: input_output_clause : ( file_control | i_o_control );
public final EnvironmentDivision.input_output_clause_return input_output_clause() throws RecognitionException 
{
    EnvironmentDivision.input_output_clause_return retval = new EnvironmentDivision.input_output_clause_return();
    retval.start = input.LT(1);

    try {
        // /home/andres/NetBeansProjects/jCobolParser/src/jcobol/parser/divisions/EnvironmentDivision.g:205:2: ( file_control | i_o_control )
        int alt1=3;
        int LA1_0 = input.LA(1);

        if ( (LA1_0==FILE) ) {
            alt1=1;
        }
        else if ( (LA1_0==IO_CONTROL) ) {
            alt1=2;
        }
        else {
            NoViableAltException nvae =
                new NoViableAltException("""", 1, 0, input);

            throw nvae;
        }
        switch (alt1) {
            case 1 :
                // /home/andres/NetBeansProjects/jCobolParser/src/jcobol/parser/divisions/EnvironmentDivision.g:205:4: file_control
                {
                pushFollow(FOLLOW_file_control_in_input_output_clause149);
                file_control();
                state._fsp--;


                }
                break;
            case 2 :
                // /home/andres/NetBeansProjects/jCobolParser/src/jcobol/parser/divisions/EnvironmentDivision.g:205:19: i_o_control
                {
                pushFollow(FOLLOW_i_o_control_in_input_output_clause153);
                i_o_control();
                state._fsp--;


                }
                break;

        }
        retval.stop = input.LT(-1);

    } catch (RecognitionException re) {
        reportError(re);
        recover(input,re);
    }
    finally {
    }
    return retval;
}   ",1293,True
"// $ANTLR start ""configuration_section_clause""
// /home/andres/NetBeansProjects/jCobolParser/src/jcobol/parser/divisions/EnvironmentDivision.g:131:1: configuration_section_clause : ( source_computer | object_computer | special_names );
public final EnvironmentDivision.configuration_section_clause_return configuration_section_clause() throws RecognitionException{
    EnvironmentDivision.configuration_section_clause_return retval = new EnvironmentDivision.configuration_section_clause_return();
    retval.start = input.LT(1);

    CommonTree root_0 = null;

    EnvironmentDivision.source_computer_return source_computer12 = null;

    EnvironmentDivision.object_computer_return object_computer13 = null;

    EnvironmentDivision.special_names_return special_names14 = null;



    try {
        // /home/andres/NetBeansProjects/jCobolParser/src/jcobol/parser/divisions/EnvironmentDivision.g:132:2: ( source_computer | object_computer | special_names )
        int alt5=3;
        switch ( input.LA(1) ) {
        case SOURCE_COMPUTER:
            {
            alt5=1;
            }
            break;
        case OBJECT_COMPUTER:
            {
            alt5=2;
            }
            break;
        case SPECIAL_NAMES:
            {
            alt5=3;
            }
            break;
        default:
            NoViableAltException nvae =
                new NoViableAltException("""", 5, 0, input);

            throw nvae;
        }

        switch (alt5) {
            case 1 :
                // /home/andres/NetBeansProjects/jCobolParser/src/jcobol/parser/divisions/EnvironmentDivision.g:132:4: source_computer
                {
                root_0 = (CommonTree)adaptor.nil();

                pushFollow(FOLLOW_source_computer_in_configuration_section_clause565);
                source_computer12=source_computer();

                state._fsp--;

                adaptor.addChild(root_0, source_computer12.getTree());

                }
                break;
            case 2 :
                // /home/andres/NetBeansProjects/jCobolParser/src/jcobol/parser/divisions/EnvironmentDivision.g:132:22: object_computer
                {
                root_0 = (CommonTree)adaptor.nil();

                pushFollow(FOLLOW_object_computer_in_configuration_section_clause569);
                object_computer13=object_computer();

                state._fsp--;

                adaptor.addChild(root_0, object_computer13.getTree());

                }
                break;
            case 3 :
                // /home/andres/NetBeansProjects/jCobolParser/src/jcobol/parser/divisions/EnvironmentDivision.g:132:40: special_names
                {
                root_0 = (CommonTree)adaptor.nil();

                pushFollow(FOLLOW_special_names_in_configuration_section_clause573);
                special_names14=special_names();

                state._fsp--;

                adaptor.addChild(root_0, special_names14.getTree());

                }
                break;

        }
        retval.stop = input.LT(-1);

        retval.tree = (CommonTree)adaptor.rulePostProcessing(root_0);
        adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);

    }
    catch (RecognitionException re) {
        reportError(re);
        recover(input,re);
	retval.tree = (CommonTree)adaptor.errorNode(input, retval.start, input.LT(-1), re);

    }
    finally {
    }
    return retval;
}","// $ANTLR start ""configuration_section_clause""
// /home/andres/NetBeansProjects/jCobolParser/src/jcobol/parser/divisions/EnvironmentDivision.g:131:1: configuration_section_clause : ( source_computer | object_computer | special_names );
public final EnvironmentDivision.configuration_section_clause_return configuration_section_clause() throws RecognitionException 
{
    EnvironmentDivision.configuration_section_clause_return retval = new EnvironmentDivision.configuration_section_clause_return();
    retval.start = input.LT(1);

    try
    {
        // /home/andres/NetBeansProjects/jCobolParser/src/jcobol/parser/divisions/EnvironmentDivision.g:132:2: ( source_computer | object_computer | special_names )
        int alt1=3;
        int LA1_0 = input.LA(1);

        if ( (LA1_0==SOURCE_COMPUTER) )
        {
            alt1=1;
        }
        else if ( (LA1_0==OBJECT_COMPUTER) )
        {
            alt1=2;
        }
        else if ( (LA1_0==SPECIAL_NAMES) )
        {
            alt1=3;
        }
        else
        {
            NoViableAltException nvae =
                new NoViableAltException("""", 1, 0, input);

            throw nvae;
        }
        switch (alt1)
        {
            case 1 :
                // /home/andres/NetBeansProjects/jCobolParser/src/jcobol/parser/divisions/EnvironmentDivision.g:132:4: source_computer
                {
                pushFollow(FOLLOW_source_computer_in_configuration_section_clause58);
                source_computer();

                state._fsp--;


                }
                break;
            case 2 :
                // /home/andres/NetBeansProjects/jCobolParser/src/jcobol/parser/divisions/EnvironmentDivision.g:133:4: object_computer
                {
                pushFollow(FOLLOW_object_computer_in_configuration_section_clause63);
                object_computer();

                state._fsp--;


                }
                break;
            case 3 :
                // /home/andres/NetBeansProjects/jCobolParser/src/jcobol/parser/divisions/EnvironmentDivision.g:134:4: special_names
                {
                pushFollow(FOLLOW_special_names_in_configuration_section_clause68);
                special_names();

                state._fsp--;


                }
                break;

        }
        retval.stop = input.LT(-1);

    }
    catch (RecognitionException re)
    {
        reportError(re);
        recover(input, re);
    }
    finally
    {
    }
    return retval;
}   ",1299,True
"/**
 * Sets the formal neighbour count of this atom.
 *
 * @param  count  The neighbour count
 *
 * @see    #getFormalNeighbourCount
 */
public void setFormalNeighbourCount(Integer count){
    this.formalNeighbourCount = count;
	notifyChanged();
}","/**
 * Sets the formal neighbour count of this atom.
 *
 * @param  count  The neighbour count
 *
 * @see    #getFormalNeighbourCount
 */
public void setFormalNeighbourCount(Integer count) 
{
    if (count == null)
    {
        throw new IllegalArgumentException(""Formal neighbour count cannot be null"");
    }

    this.formalNeighbourCount = count;
}   ",1301,True
"/**
 * Define this CMLReader to take the input from a java.io.Reader
 * class. Possible readers are (among others) StringReader and FileReader.
 * The given ReaderListener catches the events thrown to signal that a
 * a new molecule is read.
 *
 * @param input    Reader type input
 * @param listener ReaderListener that listens to newMolecule events. 
 */
public EventCMLReader(Reader input, IReaderListener listener,
		              IChemObjectBuilder builder){
    this.init();
    this.input = input;
    this.cdo = new EventCMLHandler(this, builder);
    this.builder = builder;
    this.addChemObjectIOListener(listener);
}","/**
 * Define this CMLReader to take the input from a java.io.Reader
 * class. Possible readers are (among others) StringReader and FileReader.
 * The given ReaderListener catches the events thrown to signal that a
 * a new molecule is read.
 *
 * @param input    Reader type input
 * @param listener ReaderListener that listens to newMolecule events. 
 */
public EventCMLReader(Reader input, IReaderListener listener,
		              IChemObjectBuilder builder) 
{
    super(input, listener, builder);
}	",1302,True
"/**
 *  Sets the the exact electron valency of the AtomType object.
 *
 * @param  valency  The new valency value
 * @see #getValency
 *
 */
public void setValency(Integer valency){
	this.electronValency = valency;
	notifyChanged();
}","/**
 *  Sets the the exact electron valency of the AtomType object.
 *
 * @param  valency  The new valency value
 * @see #getValency
 *
 */
public void setValency(Integer valency) 
{
    if (valency == null)
    {
        throw new IllegalArgumentException(""The valency cannot be null"");
    }
    this.valency = valency;
}   ",1304,True
"/**
 * Method initialise the given grid points with a value.
 */
public double[][][] initializeGrid(double grid[][][], double value){
	for (int i = 0; i < grid.length; i++) {
		for (int j = 0; j < grid[0].length; j++) {
			for (int k = 0; k < grid[0][0].length; k++) {
				grid[k][j][i] = value;
			}
		}
	}
	return grid;
}","/**
 * Method initialise the given grid points with a value.
 */
public double[][][] initializeGrid(double grid[][][], double value) 
{
	for(int i=0; i<grid.length; i++)
		for(int j=0; j<grid[i].length; j++)
			for(int k=0; k<grid[i][j].length; k++)
				grid[i][j][k] = value;

	return grid;
}   ",1305,True
"/**
 *  Sets the MaxBondOrder attribute of the AtomType object.
 *
 * @param  maxBondOrder  The new MaxBondOrder value
     *
     * @see       #getMaxBondOrder
 */
public void setMaxBondOrder(IBond.Order maxBondOrder){
	this.maxBondOrder = maxBondOrder;
	notifyChanged();
}","/**
 *  Sets the MaxBondOrder attribute of the AtomType object.
 *
 * @param  maxBondOrder  The new MaxBondOrder value
     *
     * @see       #getMaxBondOrder
 */
public void setMaxBondOrder(IBond.Order maxBondOrder) 
{
    this.maxBondOrder = maxBondOrder;
}   ",1306,True
"/**
 *  Private method that actually parses the input to read a ChemFile
 *  object.
 *
 * @param som The set of molecules that came fron the file
 * @return A ChemFile containing the data parsed from input.
 */
private IMoleculeSet readMoleculeSet(IMoleculeSet som){
    try {
        String line = input.readLine().trim();
        while (line != null) {
            logger.debug(""Line: "", line);

            String[] tokens = line.split(""[\\s\\t]+"",2);
            if (tokens.length > 2) throw new Exception(""Malformed line"");

            String SMILES = tokens[0];
            String name = null;
            if (tokens.length == 2) name = tokens[1];

            logger.debug(""Line contains SMILES and name: "", SMILES, "" + "" , name);

            try {
                IMolecule molecule = sp.parseSmiles(SMILES);
                som.addMolecule(molecule);
                if (name != null) {
                    molecule.setProperty(""SMIdbNAME"", name);
                }
            } catch (Exception exception) {
                logger.warn(""This SMILES could not be parsed: "", SMILES);
                logger.warn(""Because of: "", exception.getMessage());
                logger.debug(exception);
            }
            if (input.ready()) { line = input.readLine(); } else { line = null; }
        }
    } catch (Exception exception) {
        logger.error(""Error while reading SMILES line: "", exception.getMessage());
        logger.debug(exception);
    }
    return som;
}","/**
 *  Private method that actually parses the input to read a ChemFile
 *  object.
 *
 * @param som The set of molecules that came fron the file
 * @return A ChemFile containing the data parsed from input.
 */

private IMoleculeSet readMoleculeSet(IMoleculeSet som) 
{
    IMoleculeSet molSet = som;
    String line;
    try
    {
        while ((line = input.readLine()) != null)
        {
            if (line.length() > 0)
            {
                if (line.startsWith(""Molecule: ""))
                {
                    molSet.addMolecule(readMolecule());
                }
            }
        }
    }
    catch (IOException e)
    {
        e.printStackTrace();
    }
    return molSet;
}   ",1312,True
"/**
 * Main method creates a grid between given boundaries (dimensions).
 * The grid my be extended over the given boundaries with the 
 * variable extendGrid.
 */
public void generateGrid(){
	minx = minx - extendGrid;
	maxx = maxx + extendGrid;
	miny = miny - extendGrid;
	maxy = maxy + extendGrid;
	minz = minz - extendGrid;
	maxz = maxz + extendGrid;

	dim[0] = (int) Math.round(Math.abs(maxx - minx) / latticeConstant);
	dim[1] = (int) Math.round(Math.abs(maxy - miny) / latticeConstant);
	dim[2] = (int) Math.round(Math.abs(maxz - minz) / latticeConstant);

	grid = new double[dim[0] + 1][dim[1] + 1][dim[2] + 1];
}","/**
 * Main method creates a grid between given boundaries (dimensions).
 * The grid my be extended over the given boundaries with the 
 * variable extendGrid.
 */
public void generateGrid() 
{
    for (int i = 0; i < height; i++)
    {
        for (int j = 0; j < width; j++)
        {
            if (i < extendGrid || j < extendGrid || i > height - extendGrid - 1 || j > width - extendGrid - 1)
            {
                grid[i][j] = new Cell(i, j, true);
            }
            else
            {
                grid[i][j] = new Cell(i, j, false);
            }
        }
    }
}   ",1314,True
"/**
 * @param initialValue used as initial value for the grid points
 */
public GridGenerator(double min, double max, double initialValue){
	setDimension(min, max);
	generateGrid();
	initializeGrid(initialValue);
}","/**
 * @param initialValue used as initial value for the grid points
 */
public GridGenerator(double min, double max, double initialValue) 
{
    this.min = min;
    this.max = max;
    this.initialValue = initialValue;
}   ",1315,True
"/**
 * Compares a atom type with this atom type.
 *
 * @param  object Object of type AtomType
 * @return        true if the atom types are equal
 */
public boolean compare(Object object){
    if (!(object instanceof IAtomType)) {
        return false;
    }
    if (!super.compare(object)) {
        return false;
    }
    AtomType type = (AtomType) object;
    return (getAtomTypeName() == type.getAtomTypeName()) &&
            (maxBondOrder == type.maxBondOrder) &&
            (bondOrderSum == type.bondOrderSum);
}","/**
 * Compares a atom type with this atom type.
 *
 * @param  object Object of type AtomType
 * @return        true if the atom types are equal
 */
public boolean compare(Object object) 
{
    if (object instanceof AtomType)
    {
        AtomType atomType = (AtomType) object;
        return this.type.equals(atomType.type);
    }
    return false;
}   ",1316,True
"/**
 * Method calculates coordiantes from a given grid array position.
 */
public Point3d getCoordinatesFromGridPoint(int gridPoint){
	int dimCounter = 0;
	Point3d point = new Point3d(0, 0, 0);
	for (int z = 0; z < grid[0][0].length; z++) {
		for (int y = 0; y < grid[0].length; y++) {
			for (int x = 0; x < grid.length; x++) {
				if (dimCounter == gridPoint) {
					point.x = minx + latticeConstant * x;
					point.y = miny + latticeConstant * y;
					point.z = minz + latticeConstant * z;
					return point;
				}
				dimCounter++;
			}
		}
	}
	return point;
}","/**
 * Method calculates coordiantes from a given grid array position.
 */
public Point3d getCoordinatesFromGridPoint(int gridPoint) 
{
    int x = gridPoint % gridWidth;
    int z = gridPoint / gridWidth;

    return new Point3d(x, 0, z);
}   ",1317,False
"/**
	 * Constructor for the AtomType object.
 *
 * Defaults to a zero formal charge. All
 * other fields are set to {@link org.openscience.cdk.CDKConstants.UNSET}.
 *
 * @param elementSymbol  Symbol of the atom
	 */
public AtomType(String elementSymbol){
		super(elementSymbol);
		this.formalCharge = 0;
	}","/**
	 * Constructor for the AtomType object.
 *
 * Defaults to a zero formal charge. All
 * other fields are set to {@link org.openscience.cdk.CDKConstants.UNSET}.
 *
 * @param elementSymbol  Symbol of the atom
	 */
public AtomType(String elementSymbol) 
{
	this.elementSymbol = elementSymbol;
	this.formalCharge = CDKConstants.UNSET;
	this.isotopeNumber = CDKConstants.UNSET;
	this.massNumber = CDKConstants.UNSET;
	this.stereoChemistry = CDKConstants.UNSET;
	this.valence = CDKConstants.UNSET;
}	",1319,True
"// implementation of atan2
public static double atan2(double arg1, double arg2){
	// both are 0 or arg1 is +/- inf
	if(arg1+arg2 == arg1) {
		if(arg1 > 0) {
				return PIO2;
			}
		if(arg1 < 0) {
				return -PIO2;
			}
		return 0;
	}
	arg1 = atan(arg1/arg2);
	if(arg2 < 0) {
		if(arg1 <= 0) {
				return arg1 + Math.PI;
			}
		return arg1 - Math.PI;
	}
	return arg1;
}","// implementation of atan2
public static double atan2(double arg1, double arg2) 
{
    if (arg1 == 0.0)
    {
        if (arg2 > 0.0)
        {
            return Math.PI / 2.0;
        }
        if (arg2 < 0.0)
        {
            return -Math.PI / 2.0;
        }
        return 0.0;
    }
    else if (arg1 > 0.0)
    {
        return Math.atan(arg2 / arg1);
    }
    else if (arg2 >= 0.0 && arg1 < 0.0)
    {
        return Math.atan(arg2 / arg1) + Math.PI;
    }
    else
    {
        return Math.atan(arg2 / arg1) - Math.PI;
    }
}   ",1324,True
"/*
 * Simple implementation of the taylor expansion of
 * ln(1 - t) = t - t^2/2 -t^3/3 - ... - t^n/n + ...
 */
public static double ln(double x){
	boolean negative = false;

	if (x < 0) {
    		return Double.NaN;
    	}
    	if (x == 0) {
    		return Double.NEGATIVE_INFINITY;
    	}
    	if (Double.isInfinite(x)) {
    		return Double.POSITIVE_INFINITY;
    	}
    	if (x < 1) {
    		negative = true;
    		x = 1 / x;
    	}
    	int multiplier = 1;

    	 // x must be between 0 and 2 - close to 1 means faster taylor expansion
    	while (x >= 1.1) {
    		multiplier *= 2;
    		x = Math.sqrt(x);
    	}
    	double t = 1 - x;
    	double tpow = t;
    	int divisor = 1;
    	double result = 0;

    	double toSubtract;
    	while (Math.abs((toSubtract = tpow / divisor)) > EPS) {
    		result -= toSubtract;
    		tpow *= t;
    		divisor++;
    	}
    	double res = multiplier * result;
    	if (negative) {
    		return -res;
    	}
    	return res;
    }","/*
 * Simple implementation of the taylor expansion of
 * ln(1 - t) = t - t^2/2 -t^3/3 - ... - t^n/n + ...
 */
public static double ln(double x) 
{
    if (x <= 0)
    {
        throw new IllegalArgumentException(""x must be positive"");
    }

    double result = 0;
    double term = (x - 1) / x;
    int n = 1;

    while (Math.abs(term) > EPSILON)
    {
        result += term;
        term = Math.pow(-1, n) * Math.pow(term, n) / n;
        n++;
    }

    return result;
}   ",1325,False
"/* Thanks rici lake for ipow-implementation */
public static double ipow(double base, int exponent){
		boolean inverse = false;
		if (MathLib.isNegative(exponent)) {
			exponent = -exponent;
			inverse = true;
		}
		double b = 1;
		for (b = (exponent & 1) != 0 ? base : 1, exponent >>= 1; exponent != 0; exponent >>= 1) {
			base *= base;
			if ((exponent & 1) != 0) {
				b *= base;
			}
		}
		if (inverse) {
			return 1 / b;
		}
		return b;
}","/* Thanks rici lake for ipow-implementation */
public static double ipow(double base, int exponent) 
{
    double result = 1;
    for (;;)
    {
        if (exponent % 2 == 1)
            result *= base;
        exponent >>= 1;
        if (exponent == 0)
            break;
        base *= base;
    }

    return result;
}   ",1326,True
"// Hyperbolic functions
private static int cosh(LuaCallFrame callFrame, int nArguments){
	BaseLib.luaAssert(nArguments >= 1, ""Not enough arguments"");
	double x = LuaState.fromDouble(callFrame.get(0));

	double exp_x = exp(x);
	double res = (exp_x + 1 / exp_x) * 0.5;

	callFrame.push(LuaState.toDouble(res));
	return 1;
}","// Hyperbolic functions
private static int cosh(LuaCallFrame callFrame, int nArguments) 
{
    double x = callFrame.getArgAsDouble(0);
    double result = Math.cosh(x);
    callFrame.push(result);
    return 1;
}   ",1327,True
"/**
 * Rounds towards even numbers
 * @param x
 */
public static double round(double x){
	if (x < 0) {
		return -round(-x);
	}
	x += 0.5;
	double x2 = Math.floor(x);
	if (x2 == x) {
		return x2 - ((long) x2 & 1); 
	}
	return x2;
}","/**
 * Rounds towards even numbers
 * @param x
 */
public static double round(double x) 
{
    return Math.floor(x + 0.5);
}   ",1329,True
"// NOTE: known weakness - will crash if a string is longer than 2^16 - 1
private static String readLuaString(DataInputStream in, int size_t, boolean littleEndian) throws IOException{
	long len = 0;

	if (size_t == 4) {
		len = toInt(in.readInt(), littleEndian);
	} else if (size_t == 8) {
		len = toLong(in.readLong(), littleEndian);
	} else {
		loadAssert(false);
	}

	if (len == 0) {
		return null;
	}

	len = len - 1;

	// Change this to a proper string loader if you need longer strings.
	// The extra code needed seems unnecessary for the common use cases.
	loadAssert(len < 0x10000);

	int iLen = (int) len;
	byte[] stringData = new byte[2 + 1 + iLen];

	stringData[0] = (byte) ((iLen >> 8) & 0xff);
	stringData[1] = (byte) (iLen & 0xff);

	// Remember to read the trailing 0 too
	int bytesRead = in.read(stringData, 2, iLen + 1);
	loadAssert(bytesRead == iLen + 1);
	loadAssert(stringData[2 + iLen] == 0);

	DataInputStream dis = new DataInputStream(new ByteArrayInputStream(stringData));
	String s = dis.readUTF();
	dis.close();

	return s;
}","// NOTE: known weakness - will crash if a string is longer than 2^16 - 1

private static String readLuaString(DataInputStream in, int size_t, boolean littleEndian) throws IOException 
{
    int size = readInt(in, size_t, littleEndian);
    byte[] bytes = new byte[size];
    in.readFully(bytes);
    return new String(bytes, StandardCharsets.UTF_8);
}   ",1332,False
"/**
 * 
 * @param callFrame
 * @param n
 * @param type must be ""string"" or ""number"" or one of the other built in types. Note that this parameter must be interned!
 * It's not valid to call it with new String(""number"").  Use null if you don't care which type or expect 
 * more than one type for this argument.
 * @param function name of the function that calls this. Only for pretty exceptions.
 * @return variable with index n on the stack, returned as type ""type"".
 */
public static Object getArg(LuaCallFrame callFrame, int n, String type,
			String function){
	Object o = callFrame.get(n - 1);
	if (o == null) {
		throw new RuntimeException(""bad argument #"" + n + ""to '"" + function +
			""' ("" + type + "" expected, got no value)"");
	}
	// type coercion
	if (type == TYPE_STRING) {
		String res = rawTostring(o);
		if (res != null) {
			return res;
		}
	} else if (type == TYPE_NUMBER) {
		Double d = rawTonumber(o);
		if (d != null) {
			return d;
		}
		throw new RuntimeException(""bad argument #"" + n + "" to '"" + function +
		""' (number expected, got string)"");
	}
	if (type != null) {
		// type checking
		String isType = type(o);
		luaAssert(type == isType,
				""bad argument #"" + n + "" to '"" + function +""' ("" + type +
				"" expected, got "" + isType + "")"");
	}
	return o;

}","/**
 * 
 * @param callFrame
 * @param n
 * @param type must be ""string"" or ""number"" or one of the other built in types. Note that this parameter must be interned!
 * It's not valid to call it with new String(""number"").  Use null if you don't care which type or expect 
 * more than one type for this argument.
 * @param function name of the function that calls this. Only for pretty exceptions.
 * @return variable with index n on the stack, returned as type ""type"".
 */
public static Object getArg(LuaCallFrame callFrame, int n, String type,
			String function) 
{
	if (type == null)
		return callFrame.getArg(n);
	else if (type.equals(""string""))
		return callFrame.getArg(n).checkString();
	else if (type.equals(""number""))
		return callFrame.getArg(n).checkNumber();
	else
		return callFrame.getArg(n).checkUserData(type);
}	",1333,True
"// implementation of atan
public static double atan(double arg){
    if(arg > 0) {
			return msatan(arg);
		}
    return -msatan(-arg);
}","// implementation of atan
public static double atan(double arg) 
{
    if (arg > 0)
        return Math.atan(arg);
    else if (arg < 0)
        return -Math.atan(-arg);
    else
        return arg;
}   ",1334,True
"/**
 * converts the relevant fields in the given luatable to a Date object.
 * @param time LuaTable with entries for year month and day, and optionally hour/min/sec
 * @return a date object representing the date frim the luatable.
 */
public static Date getDateFromTable(LuaTable time){
	Calendar c = Calendar.getInstance(tzone);
	c.set(Calendar.YEAR,(int)LuaState.fromDouble(time.rawget(YEAR)));
	c.set(Calendar.MONTH,(int)LuaState.fromDouble(time.rawget(MONTH))-1);
	c.set(Calendar.DAY_OF_MONTH,(int)LuaState.fromDouble(time.rawget(DAY)));
	Object hour = time.rawget(HOUR);
	Object minute = time.rawget(MIN);
	Object seconds = time.rawget(SEC);
	//Object isDst = time.rawget(ISDST);
	if (hour != null) {
		c.set(Calendar.HOUR_OF_DAY,(int)LuaState.fromDouble(hour));
	} else {
		c.set(Calendar.HOUR_OF_DAY, 0);
	}
	if (minute != null) {
		c.set(Calendar.MINUTE,(int)LuaState.fromDouble(minute));
	} else {
		c.set(Calendar.MINUTE, 0);
	}
	if (seconds != null) {
		c.set(Calendar.SECOND,(int)LuaState.fromDouble(seconds));
	} else {
		c.set(Calendar.SECOND, 0);
	}
	// TODO: daylight savings support(is it possible?)
	return c.getTime();
}","/**
 * converts the relevant fields in the given luatable to a Date object.
 * @param time LuaTable with entries for year month and day, and optionally hour/min/sec
 * @return a date object representing the date frim the luatable.
 */


public static Date getDateFromTable(LuaTable time) 
{
    int year = time.get(""year"").toint();
    int month = time.get(""month"").toint();
    int day = time.get(""day"").toint();
    int hour = time.containsKey(""hour"") ? time.get(""hour"").toint() : 0;
    int minute = time.containsKey(""minute"") ? time.get(""minute"").toint() : 0;
    int second = time.containsKey(""second"") ? time.get(""second"").toint() : 0;
    Calendar cal = Calendar.getInstance();
    cal.set(year, month - 1, day, hour, minute, second);
    return cal.getTime();
}   ",1338,False
"/**
 * Returns whether this unit can exert zone of control on the given unit. It
 * can when 1) this unit can attack the given unit and 2) this unit's
 * minimum range against the given unit is greater than 1
 * 
 * @param unit
 *            the unit to be tested against
 * @return whether this unit can exert ZoC on the given unit
 */
public boolean canExertZocOn(Unit unit){
	return Specs.unitAttack.get(getType()).get(unit.getUnitType()) > 0
			&& Specs.unitMinRange.get(getType()).get(unit.getUnitType()) == 1;
}","/**
 * Returns whether this unit can exert zone of control on the given unit. It
 * can when 1) this unit can attack the given unit and 2) this unit's
 * minimum range against the given unit is greater than 1
 * 
 * @param unit
 *            the unit to be tested against
 * @return whether this unit can exert ZoC on the given unit
 */
public boolean canExertZocOn(Unit unit) 
{
    return canAttack(unit) && getMinRangeAgainst(unit) > 1;
}   ",1341,False
"/**
 * Returns the attack coordinates of a unit from a particular coordinate.
 * Also performs random check against the Eliza implementation to make sure
 * the local version is accurate.
 * 
 * @param eliza
 * @param game
 * @param playerName
 * @param unit
 * @param location
 * @return the attack coordinates of a unit from a particular coordinate
 */
public static List<Coordinate> getAttackCoords(Eliza eliza, Game game,
		String playerName, Unit unit, Coordinate location){

	Faction myFaction = game.getFactionByPlayerName(playerName);
	String type = unit.getType();
	List<Coordinate> elizaCoords = null;

	// only check a small sample of cases for errors
	int randomChoice = Util.dice(100);
	if (randomChoice <= checkAttackCoordsRatio) {
		try {
			elizaCoords = eliza.getAttackCoords(game.getId(), location,
					type);
		} catch (JDOMException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	List<Coordinate> localCoords = getAttackCoords(game, myFaction, unit,
			location);

	if (elizaCoords != null) {
		Collections.sort(localCoords, comp);
		Collections.sort(elizaCoords, comp);
		if (!(localCoords.equals(elizaCoords))) {
			Debug.print(""getAttackCoords is broken"");
			Debug.print(""Location: "" + location);
			Debug.print(""Eliza: "" + elizaCoords);
			Debug.print(""Local: "" + localCoords);
			throw new RuntimeException(
					""getAttackCoords new implementation is broken"");
		}
	}

	return localCoords;
}","/**
 * Returns the attack coordinates of a unit from a particular coordinate.
 * Also performs random check against the Eliza implementation to make sure
 * the local version is accurate.
 * 
 * @param eliza
 * @param game
 * @param playerName
 * @param unit
 * @param location
 * @return the attack coordinates of a unit from a particular coordinate
 */
public static List<Coordinate> getAttackCoords(Eliza eliza, Game game,
		String playerName, Unit unit, Coordinate location) 
{
	List<Coordinate> attackCoords = new ArrayList<Coordinate>();
	List<Coordinate> attackableCoords = unit.getAttackableCoordinates(location);
	for (Coordinate coord : attackableCoords)
	{
		if (eliza.isAttackable(game, playerName, unit, location, coord))
		{
			attackCoords.add(coord);
		}
	}
	return attackCoords;
}	",1342,False
"/**
 * Set the new shortest distance for the given node, and re-balance the
 * queue according to new shortest distances.
 * 
 * @param c
 *            the node to set
 * @param distance
 *            new shortest distance value
 */
private void setShortestDistance(Coordinate c, int distance){
	/*
	 * This crucial step ensures no duplicates are created in the queue when
	 * an existing unsettled node is updated with a new shortest distance.
	 * Note: this operation takes linear time. If performance is a concern,
	 * consider using a TreeSet instead instead of a PriorityQueue.
	 * TreeSet.remove() performs in logarithmic time, but the PriorityQueue
	 * is simpler. (An earlier version of this class used a TreeSet.)
	 */
	unsettledNodes.remove(c);

	/*
	 * Update the shortest distance.
	 */
	shortestDistances.put(c, distance);

	/*
	 * Re-balance the queue according to the new shortest distance found
	 * (see the comparator the queue was initialized with).
	 */
	unsettledNodes.add(c);
}","/**
 * Set the new shortest distance for the given node, and re-balance the
 * queue according to new shortest distances.
 * 
 * @param c
 *            the node to set
 * @param distance
 *            new shortest distance value
 */
private void setShortestDistance(Coordinate c, int distance) 
{
    c.setShortestDistance(distance);
    queue.remove(c);
    queue.add(c);
}   ",1347,False
"/**
 * Creates a new Game object with the game state information from the eliza
 * API of the game with the given id
 * 
 * @param id
 *            the game id
 * @return a new Game with complete game state information from the eliza
 *         API
 * @throws IOException
 * @throws JDOMException
 */
public Game getGameState(int id) throws IOException, JDOMException{
	Document doc = getGameStateXML(id);
	Game g = new Game(username);
	g.parseXmlElement(doc.getRootElement(), true);
	return g;
}","/**
 * Creates a new Game object with the game state information from the eliza
 * API of the game with the given id
 * 
 * @param id
 *            the game id
 * @return a new Game with complete game state information from the eliza
 *         API
 * @throws IOException
 * @throws JDOMException
 */
public Game getGameState(int id) throws IOException, JDOMException 
{
    Game game = new Game();
    game.setId(id);
    game.setGameState(getGameStateFromEliza(id));
    return game;
}   ",1348,False
"// // Send calls to API ////
public boolean acceptInvite(int id) throws IOException{
	String requestXML = ""<weewar game=\"""" + id
			+ ""\""><acceptInvitation/></weewar>"";
	String result = elizaRequest(requestXML);
	return result.contains(""<ok/>"");
}","// // Send calls to API ////
public boolean acceptInvite(int id) throws IOException 
{
    String url = ""XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"";
    String param = ""access_token="" + token + ""&invite_id="" + id;
    String result = sendPost(url, param);
    if (result.contains(""response""))
    {
        return true;
    }
    else
    {
        return false;
    }
}   ",1349,False
"/**
 * Returns a String representation of a Unit in the form of: Trooper (6) on
 * [15,14], not finished (ai_botbot)
 * 
 * @return a String representation of a Unit
 */
@Override
public String toString(){
	return type + ""("" + quantity + "") on "" + coordinate + "", ""
			+ (finished ? """" : ""not "") + ""finished  (""
			+ faction.getPlayerName() + "")"";
}","/**
 * Returns a String representation of a Unit in the form of: Trooper (6) on
 * [15,14], not finished (ai_botbot)
 * 
 * @return a String representation of a Unit
 */
@Override
public String toString() 
{
    StringBuilder sb = new StringBuilder();
    sb.append(this.name);
    sb.append("" ("");
    sb.append(this.id);
    sb.append("") on "");
    sb.append(this.position);
    sb.append("", "");
    sb.append(this.state);
    sb.append("" ("");
    sb.append(this.aiName);
    sb.append("")"");
    return sb.toString();
}   ",1352,False
"/**
 * Selects coordinates with the best defense value from the list of
 * coordinates that has the smallest associated movement cost
 */
@Override
public List<Coordinate> select(WeewarMap wmap, Unit unit,
		SortedMap<Integer, List<Coordinate>> possibleMoves){
	if (possibleMoves.isEmpty())
		return null;
	List<Coordinate> shortestDistMoves = possibleMoves.get(possibleMoves.firstKey());

	int highestTerrainDefMod = Integer.MIN_VALUE;
	List<Coordinate> newBestMoves = new LinkedList<Coordinate>();

	for (Coordinate m : shortestDistMoves) {
		int terrainDefMod = wmap.get(m).getDefenseMod(unit);
		if (highestTerrainDefMod < terrainDefMod) {
			highestTerrainDefMod = terrainDefMod;
			newBestMoves.clear();
			newBestMoves.add(m);
		} else if (terrainDefMod == highestTerrainDefMod) {
			newBestMoves.add(m);
		}
	}
	return newBestMoves;

}","/**
 * Selects coordinates with the best defense value from the list of
 * coordinates that has the smallest associated movement cost
 */
@Override
public List<Coordinate> select(WeewarMap wmap, Unit unit,
		SortedMap<Integer, List<Coordinate>> possibleMoves) 
{
	if (possibleMoves.isEmpty())
	{
		return new ArrayList<Coordinate>();
	}
	return possibleMoves.get(possibleMoves.firstKey());
}	",1353,False
"/**
 * Initialize all data structures used by the algorithm.
 * 
 * @param start
 *            the source node
 */
private void init(Coordinate start){
	settledNodes.clear();
	unsettledNodes.clear();

	shortestDistances.clear();
	predecessors.clear();

	// add source
	setShortestDistance(start, 0);
	unsettledNodes.add(start);
}","/**
 * Initialize all data structures used by the algorithm.
 * 
 * @param start
 *            the source node
 */






private void init(Coordinate start) 
{
    closedSet = new HashSet<Coordinate>();
    openSet = new PriorityQueue<Coordinate>();
    gScores = new HashMap<Coordinate, Double>();
    fScores = new HashMap<Coordinate, Double>();
    cameFrom = new HashMap<Coordinate, Coordinate>();

    gScores.put(start, 0.0);
    fScores.put(start, heuristicCostEstimate(start));
    openSet.add(start);
}   ",1355,False
"/**
 * Updates the data of only a specific Faction
 * 
 * @param id
 *            the game id
 * @param f
 *            the faction
 * @throws IOException
 * @throws JDOMException
 */
@SuppressWarnings(""unchecked"")
public void refreshFaction(int id, Faction f) throws IOException,
		JDOMException{
	Document doc = getGameStateXML(id);
	Element gameEle = doc.getRootElement();
	if (gameEle.getChild(""factions"") != null) {
		List<Element> factions = gameEle.getChild(""factions"").getChildren(
				""faction"");
		for (Element factionEle : factions) {
			if (f.getPlayerName().equals(
					factionEle.getAttributeValue(""playerName""))) {
				f.parseXmlElement(factionEle);
			}
		}
	}
}","/**
 * Updates the data of only a specific Faction
 * 
 * @param id
 *            the game id
 * @param f
 *            the faction
 * @throws IOException
 * @throws JDOMException
 */
@SuppressWarnings(""unchecked"")
public void refreshFaction(int id, Faction f) throws IOException,
		JDOMException 
{
	// Get the faction's data
	String factionData = getFactionData(id, f);

	// Parse the XML data
	Document doc = new SAXBuilder().build(new StringReader(factionData));
	Element root = doc.getRootElement();

	// Update the faction's data
	f.setID(Integer.parseInt(root.getAttributeValue(""id"")));
	f.setName(root.getChildText(""name""));
	f.setMembers(Integer.parseInt(root.getChildText(""members"")));
	f.setPower(Integer.parseInt(root.getChildText(""power"")));
	f.setVillage(Village.valueOf(root.getChildText(""village"")));
	f.setAlliance(Alliance.valueOf(root.getChildText(""alliance"")));
	f.setPoints(Integer.parseInt(root.getChildText(""points"")));
	f.setRank(Integer.parseInt(root.getChildText(""rank"")));
}	",1356,False
"/**
 * Returns the movement coordinates of a unit from a particular coordinate.
 * 
 * @param game
 * @param wmap
 * @param myFaction
 * @param unit
 * @param location
 * @return the movement coordinates of a unit from a particular coordinate
 */
public static List<Coordinate> getMovementCoords(Game game, WeewarMap wmap,
		Faction myFaction, Unit unit, Coordinate location){

	int maxMoveCost = unit.getMovementPoints();
	// TODO deal with second move

	List<Unit> myUnits = myFaction.getUnits();

	List<Coordinate> maxMoveCircle = location
			.getCircle(Specs.MAX_MOVE_RANGE);

	List<Coordinate> finishedList = new LinkedList<Coordinate>();
	List<Coordinate> enemyList = new LinkedList<Coordinate>();
	List<Coordinate> notOnMapList = new LinkedList<Coordinate>();

	// remove finished units and enemy units
	for (Coordinate resultListTarget : maxMoveCircle) {
		if (wmap.get(resultListTarget) == null) {
			notOnMapList.add(resultListTarget);
		} else {
			Unit unitAtLocation = game.getUnit(resultListTarget);
			if (unitAtLocation != null) {
				if (myUnits.contains(unitAtLocation)) {
					if (unitAtLocation.isFinished()) {
						finishedList.add(resultListTarget);
					}
				} else {
					enemyList.add(resultListTarget);
				}
			}
		}
	}

	maxMoveCircle.removeAll(finishedList);
	maxMoveCircle.removeAll(enemyList);
	maxMoveCircle.removeAll(notOnMapList);
	
	// reworked
	boolean ignoreUnits = false;
	List<Coordinate> resultList = MovementPath.getMovesAtCostLessThan(wmap,
			game, unit, location, maxMoveCost, Specs.MAX_MOVE_RANGE,
			maxMoveCircle, ignoreUnits);
	
	for (Coordinate circle1Target : location.getCircle(1)) {
		if (!location.equals(circle1Target)) {
			Unit unitAtLocation = game.getUnit(circle1Target);
			if ((unitAtLocation == null)
					|| (myUnits.contains(unitAtLocation) && (!unitAtLocation
							.isFinished()))) {
				int nextStepDistance = wmap.getDistanceForUnitType(
						location, circle1Target, unit);
				if (nextStepDistance < Specs.UNPASSABLE) {
					if (!resultList.contains(circle1Target)) {
						resultList.add(circle1Target);
					}
				}
			}
		}
	}

	// a sub, destroyer and battleship can not move onto an enemy base
	if (!unit.cannotEnterEnemyHarbor()) {
		List<Coordinate> enemyBases = new LinkedList<Coordinate>();
		for (Coordinate movementLocations : resultList) {
			Faction terrainOwner = game.getTerrainOwner(movementLocations);
			if ((terrainOwner != null) && (!terrainOwner.equals(myFaction))) {
				enemyBases.add(movementLocations);
			}
		}
		resultList.remove(enemyBases);
	}

	return resultList;
}","/**
 * Returns the movement coordinates of a unit from a particular coordinate.
 * 
 * @param game
 * @param wmap
 * @param myFaction
 * @param unit
 * @param location
 * @return the movement coordinates of a unit from a particular coordinate
 */
public static List<Coordinate> getMovementCoords(Game game, WeewarMap wmap,
		Faction myFaction, Unit unit, Coordinate location) 
{
	List<Coordinate> coords = new ArrayList<Coordinate>();
	if (unit.getMovement() > 0)
	{
		for (Coordinate c : wmap.getAdjacentCoords(location))
		{
			if (wmap.isPassable(c) && !wmap.isOccupied(c))
			{
				coords.add(c);
			}
		}
	}
	return coords;
}	",1357,False
"// Return a permuted array.
// Example:
//   data = (A, B, C), perm = (2, 0, 1)
//   newData = (C, A, B)
public static int[] applyPermutation(int[] data, int[] perm){
  assert data.length == perm.length;
  int[] newData = new int[data.length];
  for(int i = 0; i < data.length; i++)
    newData[i] = data[perm[i]];
  return newData;
}","// Return a permuted array.
// Example:
//   data = (A, B, C), perm = (2, 0, 1)
//   newData = (C, A, B)
public static int[] applyPermutation(int[] data, int[] perm) 
{
    int[] newData = new int[data.length];
    for (int i = 0; i < data.length; i++)
    {
        newData[i] = data[perm[i]];
    }
    return newData;
}   ",1361,True
"/**
 * Initializes all runtime and classpath classes.
 * 
 * @see #initializeRuntime()
 * @see #initializeClassPath()
 */
public static void initializeAll(){
    initializeRuntime();
    initializeClassPath();
}","/**
 * Initializes all runtime and classpath classes.
 * 
 * @see #initializeRuntime()
 * @see #initializeClassPath()
 */
public static void initializeAll() 
{
    initializeRuntime();
    initializeClassPath();
}   ",1365,True
"// Return the array (0, 1, 2, ..., n-1)
public static int[] identityMapArray(int n){
  int[] arr = new int[n];
  for(int i = 0; i < n; i++) arr[i] = i;
  return arr;
}","// Return the array (0, 1, 2, ..., n-1)
public static int[] identityMapArray(int n) 
{
    int[] map = new int[n];
    for (int i = 0; i < n; i++)
    {
        map[i] = i;
    }
    return map;
}   ",1366,True
"// Adapted from IOUtils to handle lowercasing and uppercasing
// Return number of characters copied
public static int copy(Reader in, Writer out) throws IOException{
  char[] buf = new char[16384];
  int total = 0, n;
  while((n = in.read(buf)) != -1) {
    if(uppercase)
      for(int i = 0; i < n; i++)
        buf[i] = Character.toUpperCase(buf[i]);
    if(lowercase)
      for(int i = 0; i < n; i++)
        buf[i] = Character.toLowerCase(buf[i]);
    total += n;
    out.write(buf, 0, n);
  }
  out.flush();
  return total;
}","// Adapted from IOUtils to handle lowercasing and uppercasing
// Return number of characters copied
public static int copy(Reader in, Writer out) throws IOException 
{
    long count = copyLarge(in, out);
    if (count > Integer.MAX_VALUE)
    {
        return -1;
    }
    return (int) count;
}   ",1368,True
"//		public boolean isStartState() {
//			return isStart;
//		}
//		public boolean isStopState() {
//			return isStop;
//		}
@Override
public int hashCode(){
	final int prime = 31;
	int result = 1;
	result = prime * result
	+ ((current == null) ? 0 : current.hashCode());
	result = prime * result
	+ ((history == null) ? 0 : history.hashCode());
	return result;
}","//		public boolean isStartState() {
//			return isStart;
//		}
//		public boolean isStopState() {
//			return isStop;
//		}
@Override
public int hashCode() 
{
	return name.hashCode();
}   ",1369,False
"/**
 * Creates a test sentence with one reference
 * @param pair
 */
public TestSentence(SentencePair pair){
	this.foreignSentence = pair.getForeignWords();
	this.references = Lists.newList(pair.getEnglishWords());
}","/**
 * Creates a test sentence with one reference
 * @param pair
 */


public TestSentence(SentencePair pair) 
{
    this.pair = pair;
    this.references = new ArrayList<Reference>();
    this.references.add(new Reference(pair));
}   ",1370,True
"// Apply the hint, and on each node we're keeping, apply the cmd
// on that node with specified the local environment.
public static RecordNode applyHint(SubsetHint hint, RecordNode result,
    CommandNode cmd, LocalCommandEnv localEnv){
  // Don't change anything
  if(hint == ConstantSubsetHint.allHint && cmd == null) return result;

  // Aggregate new results here
  FullRecordNode newResult =
    new FullRecordNode(result.getKey(), result.getValue());
  List<RecordNode> childRecords = result.getChildren();

  SubsetOracle oracle = hint.getOracle(childRecords.size());
  int lower = oracle.getLowerBound();
  int upper = Math.min(oracle.getUpperBound(), childRecords.size());

  // Loop through the relevant parts of the result.
  for(int i = lower; i < upper; i++) {
    RecordNode childRecord = childRecords.get(i);
    if(!oracle.inSubset(i)) continue;
    if(cmd == null)
      newResult.addChild(childRecord);
    else
      newResult.addChild(cmd.exec(localEnv.withCurrRecord(childRecord).withIndex(i)));
  }
  return newResult;
}","// Apply the hint, and on each node we're keeping, apply the cmd
// on that node with specified the local environment.
public static RecordNode applyHint(SubsetHint hint, RecordNode result,
    CommandNode cmd, LocalCommandEnv localEnv) 
{
    RecordNode result2 = new RecordNode();
    for (int i = 0; i < result.size(); i++) {
        RecordNode node = result.get(i);
        RecordNode node2 = applyHint(hint, node, cmd, localEnv);
        if (node2 != null) {
            result2.add(node2);
        }
    }
    return result2;
}   ",1371,False
"//	public int getLabelIndex(int stateIndex) {
//		return stateToLabelIndex[stateIndex];
//	}
private Tree<MarkovState<L>> buildTreeRec(MarkovState<L> state, int curDepth){

	curDepth += 1;

	List<L> history = state.getHistory();
	if (history.size() == order-1 || startLabel.equals(state.current) || (history.size() > 0 && history.get(0).equals(startLabel))) {
		if ((!startLabel.equals(state.current) || state.history.isEmpty()) && !state.history.contains(stopLabel)) {
			if (!stopLabel.equals(state.current) || !state.history.isEmpty()) {
				stateIndexer.add(state);
				state.index = stateIndexer.indexOf(state);					
			}
		}
	}

	if (curDepth > order) {
		return new Tree<MarkovState<L>>(state, new ArrayList<Tree<MarkovState<L>>>());
	}

	Set<L> nextLabels = new HashSet<L>(labels);

	if (curDepth == order) {
		nextLabels.add(stopLabel);
	}	
	if (curDepth == 1) {
		nextLabels.add(startLabel);
	}

	List<Tree<MarkovState<L>>> childTrees = new ArrayList<Tree<MarkovState<L>>>();
	for (L nextLabel: nextLabels) {
		List<L> newHistory = new ArrayList<L>(state.getHistory());
		if (state.getCurrentLabel() != null) newHistory.add(state.getCurrentLabel());
		MarkovState<L> child = new MarkovState<L>(nextLabel,newHistory);
		Tree<MarkovState<L>> childTree = buildTreeRec(child, curDepth);
		childTrees.add(childTree);
	}
	return new Tree<MarkovState<L>>(state, childTrees);
}","//	public int getLabelIndex(int stateIndex) {
//		return stateToLabelIndex[stateIndex];
//	}
private Tree<MarkovState<L>> buildTreeRec(MarkovState<L> state, int curDepth) 
{
	if (curDepth == 0)
	{
		return new Tree<MarkovState<L>>(state);
	}
	else
	{
		Tree<MarkovState<L>> tree = new Tree<MarkovState<L>>(state);
		for (MarkovState<L> child : state.getChildren())
		{
			tree.addChild(buildTreeRec(child, curDepth - 1));
		}
		return tree;
	}
}   ",1373,False
"/**
* Stolen from Radford Neal's fbm package.
* digamma(x) is defined as (d/dx) log Gamma(x).  It is computed here
* using an asymptotic expansion when x>5.  For x<=5, the recurrence
* relation digamma(x) = digamma(x+1) - 1/x is used repeatedly.  See
* Venables & Ripley, Modern Applied Statistics with S-Plus, pp. 151-152.
* COMPUTE THE DIGAMMA FUNCTION.  Returns -inf if the argument is an integer
* less than or equal to zero.
*/
public static double digamma(double x){
  assert x > 0 : x;
  double r, f, t;
  r = 0;
  while (x<=5) {
    r -= 1/x;
    x += 1;
  }
  f = 1/(x*x);
  t = f*(-1/12.0 + f*(1/120.0 + f*(-1/252.0 + f*(1/240.0 + f*(-1/132.0
      + f*(691/32760.0 + f*(-1/12.0 + f*3617/8160.0)))))));
  return r + Math.log(x) - 0.5/x + t;
}","/**
* Stolen from Radford Neal's fbm package.
* digamma(x) is defined as (d/dx) log Gamma(x).  It is computed here
* using an asymptotic expansion when x>5.  For x<=5, the recurrence
* relation digamma(x) = digamma(x+1) - 1/x is used repeatedly.  See
* Venables & Ripley, Modern Applied Statistics with S-Plus, pp. 151-152.
* COMPUTE THE DIGAMMA FUNCTION.  Returns -inf if the argument is an integer
* less than or equal to zero.
*/
public static double digamma(double x) 
{
    double result = 0;
    if (x <= 0)
    {
        result = -1 / x;
        return result;
    }
    while (x < 5)
    {
        result -= 1 / x;
        x += 1;
    }
    double r = 1 / x;
    result += Math.log(x) - 0.5 * r;
    r *= r;
    result -= r * (1 / 12 - 1 / 120 * r);
    return result;
}   ",1374,True
"// Vector, matrix operations {
public static boolean normalize(float[] data){
  float sum = 0;
  for(float x : data) sum += x;
  if(sum == 0) return false;
  for(int i = 0; i < data.length; i++) data[i] /= sum;
  return true;
}","// Vector, matrix operations {
public static boolean normalize(float[] data) 
{
    float mag = (float) Math.sqrt(data[0] * data[0] + data[1] * data[1] + data[2] * data[2]);
    if (mag != 0) {
        data[0] /= mag;
        data[1] /= mag;
        data[2] /= mag;
        return true;
    }
    return false;
}   ",1375,True
"/*
 * method called by clients to set up data set and make it ready for
 * processing
 */
public void createExamplesFromFile(String filename) throws Exception{
	createNormalizedDataFromFile(filename);
	setTargetColumns();
	createExamples();

}","/*
 * method called by clients to set up data set and make it ready for
 * processing
 */




public void createExamplesFromFile(String filename) throws Exception 
{
    // read in the examples
    examples = new ArrayList<Example>();
    BufferedReader in = new BufferedReader(new FileReader(filename));
    String line;
    while ((line = in.readLine()) != null)
    {
        Example e = new Example(line);
        examples.add(e);
    }
    in.close();
}   ",1380,True
"/**
 * Returns the Euclidean distance between a specified point
 * and this point.
 */
public double distance(Point2D pt){
	double result = (pt.getX() - x) * (pt.getX() - x);
	result += (pt.getY() - y) * (pt.getY() - y);
	return Math.sqrt(result);
}","/**
 * Returns the Euclidean distance between a specified point
 * and this point.
 */
public double distance(Point2D pt) 
{
    double dx = x - pt.getX();
    double dy = y - pt.getY();
    return Math.sqrt(dx*dx + dy*dy);
}   ",1382,True
"/*
 * Gets (and removes) a random example from the 'presentlyProcessed'
 */
public NNExample getExampleAtRandom(){

	int i = Util.randomNumberBetween(0, (presentlyProcessed.size() - 1));
	return presentlyProcessed.remove(i);
}","/*
 * Gets (and removes) a random example from the 'presentlyProcessed'
 */
public NNExample getExampleAtRandom() 
{
    int index = (int) (Math.random() * presentlyProcessed.size());
    NNExample example = presentlyProcessed.get(index);
    presentlyProcessed.remove(index);
    return example;
}   ",1383,True
"/**
 * Calculates the number of times that this tokenizer's nextToken method can
 * be called before it generates an exception. The current position is not
 * advanced.
 * 
 * @return the number of tokens remaining in the string using the current
 *         delimiter set
 */
public int countTokens(){
	int curr = current;
	int count = 0;

	for (int i = curr; i < max; i++) {
		if (delim.indexOf(str.charAt(i)) >= 0)
			count++;

		curr++;
	}

	return count + (returnTokens ? count : 0) + 1;
}","/**
 * Calculates the number of times that this tokenizer's nextToken method can
 * be called before it generates an exception. The current position is not
 * advanced.
 * 
 * @return the number of tokens remaining in the string using the current
 *         delimiter set
 */
public int countTokens() 
{
    int count = 0;
    int currpos = pos;
    boolean inToken = false;

    while (currpos < str.length())
    {
        if (delimiters.indexOf(str.charAt(currpos)) >= 0)
        {
            if (inToken)
            {
                count++;
                inToken = false;
            }
        }
        else
        {
            inToken = true;
        }
        currpos++;
    }

    if (inToken)
    {
        count++;
    }

    return count;
}   ",1386,True
"/*
 * create a normalized data ""table"" from the data in the file. At this
 * stage, the data is *not* split into input pattern and tragets
 */
public void createNormalizedDataFromFile(String filename) throws Exception{

	List<List<Double>> rds = new ArrayList<List<Double>>();

	// create raw data set
	BufferedReader reader = new BufferedReader(
			new InputStreamReader(this.getClass().getResourceAsStream(
					""../data/"" + filename + "".csv"")));
	String line;
	while ((line = reader.readLine()) != null) {
		rds.add(exampleFromString(line, "",""));
	}

	// normalize raw dataset
	nds = normalize(rds);
}","/*
 * create a normalized data ""table"" from the data in the file. At this
 * stage, the data is *not* split into input pattern and tragets
 */
public void createNormalizedDataFromFile(String filename) throws Exception 
{
    // read the data from the file
    double[][] data = readDataFromFile(filename);

    // normalize the data
    normalizeData(data);

    // store the normalized data
    normalizedData = data;
}   ",1387,False
"/**
 * Tests if there are more tokens available from this tokenizer's string. If
 * this method returns true, then a subsequent call to nextToken with no
 * argument will successfully return a token.
 * 
 * @return true if and only if there is at least one token in the string
 *         after the current position; false otherwise.
 */
public boolean hasMoreTokens(){
	return ((current < max) ? (true)
			: (((current == max) && (max == 0 || (returnTokens && delim
					.indexOf(str.charAt(previous)) >= 0)))));
}","/**
 * Tests if there are more tokens available from this tokenizer's string. If
 * this method returns true, then a subsequent call to nextToken with no
 * argument will successfully return a token.
 * 
 * @return true if and only if there is at least one token in the string
 *         after the current position; false otherwise.
 */
public boolean hasMoreTokens() 
{
    if (st == null)
        throw new java.util.NoSuchElementException();
    return st.hasMoreTokens();
}   ",1389,True
"/*
 * create Example instances from a normalized data ""table"".
 */
private void createExamples(){
	dataset = new ArrayList<NNExample>();
	for (List<Double> dataLine : nds) {
		List<Double> input = new ArrayList<Double>();
		List<Double> target = new ArrayList<Double>();
		for (int i = 0; i < dataLine.size(); i++) {
			if (targetColumnNumbers.contains(i)) {
				target.add(dataLine.get(i));
			} else {
				input.add(dataLine.get(i));
			}
		}
		dataset.add(new NNExample(input, target));
	}
	refreshDataset();// to populate the preentlyProcessed dataset
}","/*
 * create Example instances from a normalized data ""table"".
 */
private void createExamples() 
{
    for (int i = 0; i < table.length; i++)
    {
        Example example = new Example(table[i][0]);
        for (int j = 1; j < table[i].length; j++)
        {
            example.addFeature(Double.parseDouble(table[i][j]));
        }
        examples.add(example);
    }
}   ",1394,False
"/**
 * Returns the next token in this string tokenizer's string. First, the set
 * of characters considered to be delimiters by this Tokenizer object is
 * changed to be the characters in the string delim. Then the next token in
 * the string after the current position is returned. The current position
 * is advanced beyond the recognized token. The new delimiter set remains
 * the default after this call.
 * 
 * @param delim
 *            the new delimiters
 * 
 * @return the next token, after switching to the new delimiter set
 * 
 * @exception NoSuchElementException
 *                if there are no more tokens in this tokenizer's string.
 */
public String nextToken(String delim) throws NoSuchElementException{
	this.delim = delim;
	return nextToken();
}","/**
 * Returns the next token in this string tokenizer's string. First, the set
 * of characters considered to be delimiters by this Tokenizer object is
 * changed to be the characters in the string delim. Then the next token in
 * the string after the current position is returned. The current position
 * is advanced beyond the recognized token. The new delimiter set remains
 * the default after this call.
 * 
 * @param delim
 *            the new delimiters
 * 
 * @return the next token, after switching to the new delimiter set
 * 
 * @exception NoSuchElementException
 *                if there are no more tokens in this tokenizer's string.
 */
public String nextToken(String delim) throws NoSuchElementException 
{
    if (position < 0)
    {
        throw new NoSuchElementException();
    }

    int start = position;
    int nextDelimPos = str.indexOf(delim, start);

    if (nextDelimPos < 0)
    {
        nextDelimPos = str.length();
    }

    position = nextDelimPos + delim.length();

    return str.substring(start, nextDelimPos);
}   ",1395,True
"/**
 * Resets this tokenizer's state so the tokenizing starts from the begin.
 */
public void reset(){
	previous = -1;
	current = 0;
}","/**
 * Resets this tokenizer's state so the tokenizing starts from the begin.
 */
public void reset() 
{
    if (this.in != null)
    {
        this.in.reset();
    }
}   ",1396,True
"//
// Protected Methods
//
protected void testDefiniteClauseKBKingsQueryCriminalXFalse(
		InferenceProcedure infp){
	FOLKnowledgeBase kkb = FOLKnowledgeBaseFactory
			.createKingsKnowledgeBase(infp);
	List<Term> terms = new ArrayList<Term>();
	terms.add(new Variable(""x""));
	Predicate query = new Predicate(""Criminal"", terms);
	InferenceResult answer = kkb.ask(query);
	assertTrue(null != answer);
	assertTrue(answer.isPossiblyFalse());
	assertFalse(answer.isTrue());
	assertFalse(answer.isUnknownDueToTimeout());
	assertFalse(answer.isPartialResultDueToTimeout());
	assertTrue(0 == answer.getProofs().size());
}","//
// Protected Methods
//
protected void testDefiniteClauseKBKingsQueryCriminalXFalse(
		InferenceProcedure infp) 
{
	// 1. The query is: Criminal(x) ?
	//    Answers: x = Bruce
	KB kb = KBExamples.definiteClauseKBKingsQueryCriminalXFalse();
	AskAlgorithm a = new AskAlgorithm(infp);
	Answer ans = a.ask(kb, kb.newSymbol(""Criminal"", ""x""));
	assertEquals(Answer.TRUE, ans);
}	",1397,False
"/**
 * <p>Load and combined property files found in directory trees rooted at specified paths</p>
 *
 * @param paths List of paths to search
 * @param propertyFileNameRegex Regex for Name of property file to load
 * @return Properties instance with contents of all properties files combined
 *
 */
public static Properties loadAndCombineProperties(ArrayList<String> paths, String propertyFileNameRegex){
    CombinedPropertyFileManager propertyFileLoader = new CombinedPropertyFileManager();
    propertyFileLoader.setSearchPaths(paths);
    propertyFileLoader.setPropertyFileName(propertyFileNameRegex);
    return propertyFileLoader.loadAllFromPaths();
}","/**
 * <p>Load and combined property files found in directory trees rooted at specified paths</p>
 *
 * @param paths List of paths to search
 * @param propertyFileNameRegex Regex for Name of property file to load
 * @return Properties instance with contents of all properties files combined
 *
 */
public static Properties loadAndCombineProperties(ArrayList<String> paths, String propertyFileNameRegex) 
{
    Properties combinedProperties = new Properties();
    for (String path : paths)
    {
        combinedProperties.putAll(loadProperties(path, propertyFileNameRegex));
    }
    return combinedProperties;
}   ",1400,False
"/**
 * Load a single file from a supplied virtual file entry
 *
 * @param virtualFileEntry
 * @param properties Properties instance, if null a new properties instance is created and returned
 * @return Properties file instance with the specified file loaded, or empty instance if any errors
 */
public Properties loadSingle(VirtualFileEntry virtualFileEntry,Properties properties){

    if (properties == null) {
        properties = new Properties();
    }

    try {
        if (virtualFileEntry.getFileType() == VirtualFileEntry.TYPE_JAR) {
            JarFile jarFile = new JarFile(virtualFileEntry.getAbsoluteFilePath());
            JarEntry jarEntry = jarFile.getJarEntry(virtualFileEntry.getRelativeFilePath());
            InputStream jarEntryInputStream = jarFile.getInputStream(jarEntry);
            if (consoleTracing) System.out.format(""CombinedPropertyFileManager:loadSingle About to load properties file from JAR %s:%s\n"", virtualFileEntry.getAbsoluteFilePath() , virtualFileEntry.getRelativeFilePath());
            if (virtualFileEntry.getRelativeFilePath().endsWith("".xml"")) {
                properties.loadFromXML(jarEntryInputStream);
            }
            else {
                properties.load(jarEntryInputStream);
            }
            jarEntryInputStream.close();
            jarFile.close();;
        }
        else if (virtualFileEntry.getFileType() == virtualFileEntry.TYPE_FILE) {
            if (consoleTracing) System.out.format(""CombinedPropertyFileManager:loadSingle About to load properties file %s\n"", virtualFileEntry.getAbsoluteFilePath());
            if (virtualFileEntry.getAbsoluteFilePath().endsWith("".xml"")) {
                properties.loadFromXML(new FileInputStream(virtualFileEntry.getAbsoluteFilePath()));
            }
            else {
                properties.load(new FileInputStream(virtualFileEntry.getAbsoluteFilePath()));
            }
        }
    }
    catch (Exception ex) {
        if (consoleTracing) {
            System.out.format(""CombinedPropertyFileManager:loadSingle. Error while loading properties files. Ignoring .. %s\n"" + ex.toString());
            ex.printStackTrace(System.out);
        }

    }

    return properties;

}","/**
 * Load a single file from a supplied virtual file entry
 *
 * @param virtualFileEntry
 * @param properties Properties instance, if null a new properties instance is created and returned
 * @return Properties file instance with the specified file loaded, or empty instance if any errors
 */

public Properties loadSingle(VirtualFileEntry virtualFileEntry,Properties properties) 
{
    if (virtualFileEntry == null || !virtualFileEntry.exists())
    {
        return new Properties();
    }

    Properties props = properties;
    if (props == null)
    {
        props = new Properties();
    }

    try
    {
        props.load(virtualFileEntry.getInputStream());
    }
    catch (IOException e)
    {
        LOG.error(""Error loading properties file "" + virtualFileEntry.getPath(), e);
    }

    return props;
}   ",1401,False
"/**
 * Find all the properties in the search paths listed
 *
 * @return List of all matching properties files
 */
public ArrayList<VirtualFileEntry> findAllFromPaths(){
    ArrayList<String> paths = new ArrayList<String>();
    ArrayList<VirtualFileEntry> matchingFileList = MatchingFileAndJarTraverser.findFilesFromPaths(searchPaths,propertyFileName);
    return matchingFileList;
}","/**
 * Find all the properties in the search paths listed
 *
 * @return List of all matching properties files
 */
public ArrayList<VirtualFileEntry> findAllFromPaths() 
{
    ArrayList<VirtualFileEntry> results = new ArrayList<VirtualFileEntry>();
    for (VirtualFileEntry searchPath : searchPaths)
    {
        results.addAll(searchPath.findAll());
    }
    return results;
}   ",1402,False
"/**
 * <p>Find all the files in the directory trees rooted in the given paths that are in a directory corresponding
 * to the package of the specified ciass and match the file name specified.</p>
 *
 * @param klass Class for package to search
 * @param paths List of fully-qualified path names to search
 * @param matchingFilename name for files to match
 * @return Array of fully-qualitifed matching file names
 */
public static ArrayList<String> findFilesFromPackageAndPaths(Class klass, ArrayList<String> paths, String matchingFilename){

    boolean  consoleTracing = false;
    if (System.getProperty(""net.olioinfo.fileutils.consoleTracing"") != null) {
        if (System.getProperty(""net.olioinfo.fileutils.consoleTracing"").equalsIgnoreCase(""true"")) {
            consoleTracing = true;
        }
        else {
            consoleTracing = false;
        }
    }



    ArrayList<String> matchingPaths = new ArrayList<String>();

    String packageName = klass.getPackage().getName();
    for (String currentPath : paths ) {
        String fullPathName = null;
        try {
            fullPathName  = String.format(""%s/%s"",currentPath,convertPackageNameToDirectoriesSegment(packageName));
            MatchingFileTraverser matchingFileTraverser = new MatchingFileTraverser();
            matchingFileTraverser.setMatchingString(matchingFilename);
            try {
                matchingFileTraverser.traverse(new File(fullPathName));
            }
            catch (Exception ex) {
                if (consoleTracing) {
                    System.out.format(""MatchingFileTravers.findFilesFromPackageAndPaths ignoring exception %s\n"",ex.toString());
                    ex.printStackTrace(System.out);
                }
            }

            ArrayList<String> matchingFileList = matchingFileTraverser.getFileList();
            for (String matchingFile : matchingFileList ) {
                matchingPaths.add(matchingFile);
                if (consoleTracing) {
                    System.out.format(""MatchingFileTraverser.findFilesFromyPackageAndPaths adding %s\n"", matchingFile);
                }
            }
        }
        catch (Exception ex) {
            if (consoleTracing) {
                System.out.format(""MatchingFileTraverser.findFilesFromyPackageAndPaths Ignoring error %s which matching path %s\n"", ex.toString(), fullPathName);
                ex.printStackTrace(System.out);
            }
        }
    }
    return matchingPaths;
}","/**
 * <p>Find all the files in the directory trees rooted in the given paths that are in a directory corresponding
 * to the package of the specified ciass and match the file name specified.</p>
 *
 * @param klass Class for package to search
 * @param paths List of fully-qualified path names to search
 * @param matchingFilename name for files to match
 * @return Array of fully-qualitifed matching file names
 */
public static ArrayList<String> findFilesFromPackageAndPaths(Class klass, ArrayList<String> paths, String matchingFilename) 
{
    ArrayList<String> result = new ArrayList<String>();
    String packagePath = klass.getPackage().getName().replace('.', '/');
    for (String path : paths)
    {
        File root = new File(path + ""/"" + packagePath);
        if (root.exists())
        {
            ArrayList<String> files = findFilesFromPath(root, matchingFilename);
            result.addAll(files);
        }
    }
    return result;
}   ",1403,False
"/**
 * Merge two sets of properties, returnning the original set (now merged)
 * 
 * @param original
 * @param fresh
 * @return Merged set
 */
public static Properties mergeProperties(Properties original, Properties fresh){
    Enumeration freshPropsEnum = fresh.keys();
    while (freshPropsEnum.hasMoreElements()) {
        String key = (String) freshPropsEnum.nextElement();
        String value = fresh.getProperty(key);
        original.setProperty(key,value);
    }
    return original;
}","/**
 * Merge two sets of properties, returnning the original set (now merged)
 * 
 * @param original
 * @param fresh
 * @return Merged set
 */
public static Properties mergeProperties(Properties original, Properties fresh) 
{
    for (Map.Entry<Object, Object> entry : fresh.entrySet())
    {
        original.put(entry.getKey(), entry.getValue());
    }
    return original;
}   ",1405,True
"/**
 * Traverse a tree from a given starting point
 *
 * @param f File object indicating starting point
 * @throws IOException
 */
public final void traverse( final File f ) throws IOException{
    if (consoleTracing) System.out.format(""AbstractFileTraverser: traverse: file %s\n"", f.getAbsolutePath());
    if (f.exists()) {
        if (consoleTracing) System.out.format(""AbstractFileTraverser: traverse: file exists %s\n"", f.getAbsolutePath());
        if (f.isDirectory()) {
            if (consoleTracing) System.out.format(""AbstractFileTraverser: traverse: file is a directory %s\n"", f.getAbsolutePath());
            onDirectory(f);
            final File[] children = f.listFiles();
            for( File child : children ) {
                traverse(child);
            }
            return;
        }
        onFile(f);
    }
}","/**
 * Traverse a tree from a given starting point
 *
 * @param f File object indicating starting point
 * @throws IOException
 */
public final void traverse( final File f ) throws IOException 
{
    if ( f.isDirectory() )
    {
        onDirectory( f );
        final File[] childs = f.listFiles();
        for ( File child : childs )
        {
            traverse( child );
        }
    }
    else
    {
        onFile( f );
    }
}   ",1406,True
"/**
 * <p>Find all the files in the directory trees rooted in the given paths that are in a directory corresponding
 * to the package of the specified ciass and match the file name specified.</p>
 *
 * @param klass Class for package to search
 * @param paths List of fully-qualified path names to search
 * @param fileNameRegex name for files to match
 * @return Array of fully-qualitifed matching file entries
 */
public static ArrayList<VirtualFileEntry> findFilesFromPackageAndPaths(Class klass, ArrayList<String> paths, String fileNameRegex){

    boolean  consoleTracing = false;
    if (System.getProperty(""net.olioinfo.fileutils.consoleTracing"") != null) {
        if (System.getProperty(""net.olioinfo.fileutils.consoleTracing"").equalsIgnoreCase(""true"")) {
            consoleTracing = true;
        }
        else {
            consoleTracing = false;
        }
    }

    String packageFileNameRegex = null;
    if (klass.getPackage() == null) {
        packageFileNameRegex = fileNameRegex;
    }
    else {
        String packageName = klass.getPackage().getName();
        String packagePath = convertPackageNameToDirectoriesSegment(packageName);
        packageFileNameRegex = String.format("".*%s/%s$"", packagePath , fileNameRegex);
    }

    if (consoleTracing) {
        System.out.format(""MatchingFileAndJarTraverser.findFilesFromPackageAndPaths calling MatchingFileAndJarTraverser.findFilesFromPaths with file name pattern %s\n"",packageFileNameRegex);
    }

    return MatchingFileAndJarTraverser.findFilesFromPaths(paths,packageFileNameRegex);

}","/**
 * <p>Find all the files in the directory trees rooted in the given paths that are in a directory corresponding
 * to the package of the specified ciass and match the file name specified.</p>
 *
 * @param klass Class for package to search
 * @param paths List of fully-qualified path names to search
 * @param fileNameRegex name for files to match
 * @return Array of fully-qualitifed matching file entries
 */

public static ArrayList<VirtualFileEntry> findFilesFromPackageAndPaths(Class klass, ArrayList<String> paths, String fileNameRegex) 
{
    ArrayList<VirtualFileEntry> ret = new ArrayList<VirtualFileEntry>();
    String packagePath = klass.getPackage().getName().replace('.', '/');
    for (String path : paths)
    {
        File dir = new File(path + ""/"" + packagePath);
        if (dir.exists() && dir.isDirectory())
        {
            File[] files = dir.listFiles();
            if (files != null)
            {
                for (File file : files)
                {
                    if (file.getName().matches(fileNameRegex))
                    {
                        ret.add(new VirtualFileEntry(file));
                    }
                }
            }
        }
    }
    return ret;
}   ",1407,True
"/**
 * Load all the properties in the search paths listed
 *
 * @return Properties instance with contents of all properties files combined
 */
public Properties loadAllFromPackageAndPaths(){

    ArrayList<VirtualFileEntry> allPropertyFileEntries = findAllFromPackageAndPaths();
    for (VirtualFileEntry virtualFileEntry: allPropertyFileEntries ) {
        loadSingle(virtualFileEntry,combinedProperties);
    }
    // Hand back whatever was found. Errors are logged but don't get loaded (obviously!)
    return combinedProperties;

}","/**
 * Load all the properties in the search paths listed
 *
 * @return Properties instance with contents of all properties files combined
 */
public Properties loadAllFromPackageAndPaths() 
{
    Properties properties = new Properties();
    for (String searchPath : searchPaths)
    {
        properties.putAll(loadAllFromPackageAndPath(searchPath));
    }
    return properties;
}   ",1408,True
"/**
 * <p>Load and combine property files found in directory tree rooted at path.</p>
 *
 *
 * @param path Top of tree
 * @param propertyFileNameRegex Regex for Name of property file to load
 * @return Properties instance with contents of all properties files combined
 * 
 */
public static Properties loadAndCombineProperties(String path, String propertyFileNameRegex){
    ArrayList<String> pathList = new ArrayList<String>();
    pathList.add(path);
    return CombinedPropertyFileManager.loadAndCombineProperties(pathList,propertyFileNameRegex);
}","/**
 * <p>Load and combine property files found in directory tree rooted at path.</p>
 *
 *
 * @param path Top of tree
 * @param propertyFileNameRegex Regex for Name of property file to load
 * @return Properties instance with contents of all properties files combined
 * 
 */







public static Properties loadAndCombineProperties(String path, String propertyFileNameRegex) 
{
    Properties properties = new Properties();
    try
    {
        List<File> propertyFiles = findPropertyFiles(path, propertyFileNameRegex);
        for (File propertyFile : propertyFiles)
        {
            try (InputStream inputStream = new FileInputStream(propertyFile))
            {
                properties.load(inputStream);
            }
        }
    }
    catch (IOException e)
    {
        throw new RuntimeException(e);
    }
    return properties;
}   ",1409,True
"/**
 * <p>Create an instance of AbstractFileTraverser.</p>
 *
 * <p>Initialize logging using log4j. The default 'WARN' logging level can be overridden by specifying
 * -Dnet.olioinfo.fileutils.logLevel=TRACE (or other level) when starting the JVM.
 * </p>
 *
 * <p>To change the logging for this module in a log4j / log4j-ext properties file use the class names</p>
 * <ul>
 *   <li>net.olioinfo.fileutils.AbstractFileTraverser</li>
 *   <li>net.olioinfo.fileutils.AbstractFileAndJarTraverser</li>
 *   <li>net.olioinfo.fileutils.CombinedPropertyFileManager</li>
 * </ul>
 */
public AbstractFileTraverser(){
    if (System.getProperty(""net.olioinfo.fileutils.consoleTracing"") != null) {
        if (System.getProperty(""net.olioinfo.fileutils.consoleTracing"").equalsIgnoreCase(""true"")) {
            consoleTracing = true;
        }
        else {
            consoleTracing = false;
        }
    }
}","/**
 * <p>Create an instance of AbstractFileTraverser.</p>
 *
 * <p>Initialize logging using log4j. The default 'WARN' logging level can be overridden by specifying
 * -Dnet.olioinfo.fileutils.logLevel=TRACE (or other level) when starting the JVM.
 * </p>
 *
 * <p>To change the logging for this module in a log4j / log4j-ext properties file use the class names</p>
 * <ul>
 *   <li>net.olioinfo.fileutils.AbstractFileTraverser</li>
 *   <li>net.olioinfo.fileutils.AbstractFileAndJarTraverser</li>
 *   <li>net.olioinfo.fileutils.CombinedPropertyFileManager</li>
 * </ul>
 */
public AbstractFileTraverser() 
{
    super();
    log = Logger.getLogger( AbstractFileTraverser.class );
    log.trace( ""AbstractFileTraverser()"" );
}   ",1411,True
"/**
 * Rigourous Test :-)
 */
public void testAbstractFileTraverser(){
    final ArrayList<String> fileList = new ArrayList<String>();


    class FileTraverser extends AbstractFileTraverser {


        @Override
        public void onDirectory(File d) {
            //To change body of implemented methods use File | Settings | File Templates.
        }

        @Override
        public void onFile(File f) {
            if (f.getAbsolutePath().endsWith(""properties"")) {
                if (f.getName().startsWith(""fileutils"")) {
                    fileList.add(f.getAbsolutePath());
                }
            }
        }
    }

    try {
        FileTraverser fileTraverser = new FileTraverser();
        fileTraverser.traverse(new File(String.format(""%s/src"",System.getProperty(""user.dir""))));
    }
    catch (Exception ex) {
        System.out.format(""testAbstractFileTraverser exception %s\n"",ex.toString());
        ex.printStackTrace(System.out);
    }
    assertTrue(""There should be four matching files"", fileList.size() == 4);

}","/**
 * Rigourous Test :-)
 */

public void testAbstractFileTraverser() 
{
    AbstractFileTraverser traverser = new AbstractFileTraverser()
    {
        @Override
        public void processFile(File file)
        {
            // Do nothing
        }
    };
    assertNotNull(traverser);
}   ",1413,False
"/**
 * Test load with simple file name
 */
public void testCombinedPropertyFileLoaderTest(){
    Properties combinedProps = CombinedPropertyFileManager.loadAndCombineProperties(System.getProperty(""user.dir""),"".*fileutils-test-defaults.properties$"");

    combinedProps.list(System.out);
//         assertEquals(""second unique"" , combinedProps.getProperty(""test.props.2""));
//         assertEquals(""first unique"" , combinedProps.getProperty(""test.props.1""));
//         assertEquals(""second"" , combinedProps.getProperty(""test.props.common""));

}","/**
 * Test load with simple file name
 */
public void testCombinedPropertyFileLoaderTest() 
{
    String[] args = new String[]
    {
        ""src/test/resources/combined.properties""
    };
    CombinedPropertyFileLoader.main(args);
}   ",1416,False
"/**
 * 
 * @param serviceName
 * @return
 */
public String findServiceClassPath(String serviceName){
	String serviceClassPath = null;

	if (serviceConfigureInfosList.isEmpty()) {
		return serviceClassPath;
	}

	for (int index = 0; index < serviceConfigureInfosList.size(); index++) {
		if (serviceConfigureInfosList.get(index).getServiceName().equals(
				serviceName)) {
			serviceClassPath = serviceConfigureInfosList.get(index)
					.getServiceClassPath();
			break;
		}
	}

	return serviceClassPath;
}","/**
 * 
 * @param serviceName
 * @return
 */
public String findServiceClassPath(String serviceName) 
{
    String classPath = null;
    try
    {
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        if (classLoader == null)
        {
            classLoader = ClassLoader.getSystemClassLoader();
        }
        classPath = classLoader.getResource(serviceName).getPath();
    }
    catch (Exception e)
    {
        e.printStackTrace();
    }
    return classPath;
}   ",1420,False
"/** check if the name is available */
@Override
public String saveUser(User_Client userC){
	User user = new User();
	user.setUserid(userC.getUserid());
	user.setAccount(userC.getAccount());
	user.setAge(userC.getAge());
	user.setBirthday(userC.getBirthday());
	user.setBymail(userC.isBymail());
	user.setBymobile(userC.isBymobile());
	user.setEmail(userC.getEmail());
	user.setSex(userC.getSex());
	user.setTel(userC.getTel());
	user.setPassword(userC.password);

	userdao.insertUser(user);
	return ""success"";

}","/** check if the name is available */
@Override
public String saveUser(User_Client userC) 
{
    if (userC.getName().equals(""Available""))
    {
        return ""Name is available"";
    }
    else
    {
        return ""Name is not available"";
    }
}   ",1421,True
"// 用于区分，是否为起始节点的颜色label
public SetStartCommand(Widget w, DiagramBuilder d, MenuItem menuItem){
		workflowtasknode = (Workflowtasknode) w;
		diagrambuilderexample = d;
		this.menuItem = menuItem;
	}","// 用于区分，是否为起始节点的颜色label
public SetStartCommand(Widget w, DiagramBuilder d, MenuItem menuItem) 
{
    this.w = w;
    this.d = d;
    this.menuItem = menuItem;
    this.menuItem.addActionListener(this);
}   ",1422,True
"/**
 * Constructor that uses default text values for buttons.
 * 
 * @param labelText
 *            The initial text of the label.
 * @param onUpdate
 *            Handler object for performing actions once label is updated.
 */
public ChoiceTask(String labelText, DiagramBuilder d){
	dbe = d;
	createEditableLabel(labelText, ""I"", ""O"", ""F"");
}","/**
 * Constructor that uses default text values for buttons.
 * 
 * @param labelText
 *            The initial text of the label.
 * @param onUpdate
 *            Handler object for performing actions once label is updated.
 */
public ChoiceTask(String labelText, DiagramBuilder d) 
{
    this(labelText, ""Yes"", ""No"", d);
}   ",1423,True
"/** create grid */
private Grid createGrid(){
	final Grid grid = new Grid(1, 1);
	final Table table = createTable();
	table.setSize(""100%"", ""200"");
	grid.setWidget(0, 0, table);
	grid.getRowFormatter().setVerticalAlign(0,
			HasVerticalAlignment.ALIGN_TOP);
	grid.getCellFormatter().setWidth(0, 0, ""100%"");
	grid.getCellFormatter().setHeight(0, 0, ""100%"");
	grid.setSize(""100%"", ""100%"");
	return grid;
}","/** create grid */

private Grid createGrid() 
{
    Grid grid = new Grid();
    for (int row = 0; row < 3; row++)
    {
        for (int col = 0; col < 3; col++)
        {
            grid.addCell(new Cell(row, col));
        }
    }
    return grid;
}   ",1425,True
"/** create the widgets */
public void Init(){

	final AbsolutePanel main_Panel = new AbsolutePanel();
	super.add(main_Panel);

	main_Panel.setSize(""600px"", ""400px"");

	// scroll panel
	final ScrollPanel scrollPanel = new ScrollPanel();
	main_Panel.add(scrollPanel, 10, 10);
	scrollPanel.setSize(""580px"", ""350px"");

	// block include 3 part
	final VerticalPanel block_Panel = new VerticalPanel();
	block_Panel.setSpacing(5);
	scrollPanel.add(block_Panel);

	// create part 1,2,3
	createPart1(block_Panel);
	createPart2(block_Panel);
	createPart3(block_Panel);

	// create confirm
	HorizontalPanel confirm_button = createConfirm();
	main_Panel.add(confirm_button, 50, 360);
}","/** create the widgets */



public void Init() 
{
    // Create the widgets
    m_widgets = new ArrayList<Widget>();
    m_widgets.add(new ButtonWidget(10, 10, 100, 30, ""Button 1""));
    m_widgets.add(new LabelWidget(10, 50, 100, 30, ""Label 1""));
    m_widgets.add(new TextBoxWidget(10, 90, 100, 30, ""Text Box 1""));
}   ",1426,True
"// 此时的paraminfo已经是基本类型的
public AbsolutePanel Generate_empty_downpanel(final ParamInfo paramInfo){
	final AbsolutePanel downlist_panelAbsolutePanel = new AbsolutePanel();
	downlist_panelAbsolutePanel.setSize(""325"", ""28"");

	final TextBox textBox = new TextBox();
	if (paramInfo.getParamTypeName().equals(""Date"")) {
		textBox.setReadOnly(true);
	}
	textBox.addClickHandler(new ClickHandler() {

		public void onClick(ClickEvent event) {
			// TODO Auto-generated method stub
			if (paramInfo.getParamTypeName().equals(""Date"")) {
				setDateInTextBox(textBox, paramInfo);
			}
		}

	});

	textBox.addFocusListener(new FocusListener() {

		public void onFocus(Widget sender) {
			// TODO Auto-generated method stub

		}

		// 每次失去焦点，都要更新paraminfo保存的值
		public void onLostFocus(Widget sender) {
			// TODO Auto-generated method stub
			// 获得事件响应的实际控件
			TextBox innerTextBox = (TextBox) sender;
			String value = innerTextBox.getValue();
			if (value != null) {
				/*
				 * 先做个isuserfilled检查，如果是的话，可能由于用户误点进入编辑状态，
				 * 不改变paramvalue值，如果不是用户输入，则进行类型检测，合法情况下刷新保存的值
				 */
				if (!UserFilled(value)) {

				} else {
					// 如果类型合法，并且内容合法，则将内容保存起来
					if (isTypelegal(value, paramInfo.getParamTypeName())
							&& isContentlegal(value, paramInfo
									.getParamName())) {
						sender.removeStyleName(""x-form-invalid"");

						AbsolutePanel current_innerAbsolutePanel = (AbsolutePanel) innerTextBox
								.getParent();
						AbsolutePanel outterAbsolutePanel = (AbsolutePanel) current_innerAbsolutePanel
								.getParent();

						for (int i = 0; i < outterAbsolutePanel
								.getWidgetCount(); i++) {
							AbsolutePanel innerAbsolutePanel = (AbsolutePanel) outterAbsolutePanel
									.getWidget(i);
							TextBox currentTextBox = (TextBox) innerAbsolutePanel
									.getWidget(0);
							// 设置保存的值的来源，用路径的方式表示,保存的时候把服务名换成id号
							String valueString = currentTextBox.getValue();
							// String value_for_save =
							// treeItemName.replace((CharSequence)valueString,(CharSequence)Integer.toString(service_id.get(valueString)));
							if (i == 0) {
								paramInfo.setParamValue(valueString);
							} else {
								paramInfo.setParamValue(paramInfo
										.getParamValue()
										+ ""+"" + valueString);
							}
						}
					} else {
						if (value.equals("""")) {
							sender.removeStyleName(""x-form-invalid"");
						} else {
							sender.addStyleName(""x-form-invalid"");
						}
					}
					paramInfo.setIsUserFilled(true); // 用来指明信息为用户输入，主要用来下次初始化服务配置窗口的显示
				}
			} else {
				sender.removeStyleName(""x-form-invalid"");
			}
		}

	});
	textBox.setSize(""275"", ""25"");
	downlist_panelAbsolutePanel.add(textBox, 15, 2);
	textBox.setTextAlignment(TextBoxBase.ALIGN_LEFT);

	final Image downlist = new Image(""img/downlist.PNG"");
	downlist.addClickHandler(new ClickHandler() {

		public void onClick(ClickEvent event) {
			// TODO Auto-generated method stub
			// 如果下拉列表未展开，将其展开
			if (isopen == false) {

				isopen = true;

				final Tree staticTree = new Tree();
				staticTree.setAnimationEnabled(true);
				staticTree.ensureDebugId(""cwTree-staticTree"");
				staticTree.addMouseDownHandler(new MouseDownHandler() {

					public void onMouseDown(MouseDownEvent event) {
						// TODO Auto-generated method stub
						Tree tree = (Tree) event.getSource();
						TreeItem treeItem = tree.getSelectedItem(); // 此处获取选中节点有些问题，是否点选的为加号而非内容所致
						if (treeItem != null
								&& treeItem.getChildCount() == 0) {
							String treeItemName = treeItem.getText();

							// 从叶子节点向根节点回溯，找到绝对路径
							while (treeItem.getParentItem() != null) {
								treeItem = treeItem.getParentItem();
								treeItemName = treeItem.getText() + "".""
										+ treeItemName;
							}

							ScrollPanel currentScrollPanel = (ScrollPanel) tree
									.getParent();
							AbsolutePanel current_innerAbsolutePanel = (AbsolutePanel) currentScrollPanel
									.getParent();
							TextBox textBox = (TextBox) current_innerAbsolutePanel
									.getWidget(0);
							textBox.setValue(treeItemName);
							// currentAbsolutePanel.remove(currentScrollPanel);
							// //点选完毕后，移除下拉列表

							isopen = false;
							AbsolutePanel outterAbsolutePanel = (AbsolutePanel) current_innerAbsolutePanel
									.getParent();
							current_innerAbsolutePanel
									.remove(total_staticTreeWrapper); // 已知新加入的scrollpanel的index是2，所以直接删除，否则容易出现越界错误
							current_innerAbsolutePanel.setSize(""325"", ""28"");
							int location = outterAbsolutePanel
									.getWidgetIndex(current_innerAbsolutePanel);
							for (; location + 1 < outterAbsolutePanel
									.getWidgetCount(); location++) {
								AbsolutePanel absolutePanel = (AbsolutePanel) outterAbsolutePanel
										.getWidget(location + 1);
								int relative_height = absolutePanel
										.getAbsoluteTop()
										- outterAbsolutePanel
												.getAbsoluteTop();
								outterAbsolutePanel.setWidgetPosition(
										absolutePanel, 0,
										relative_height - 300);
							}
							int widget_count = outterAbsolutePanel
									.getWidgetCount();
							outterAbsolutePanel.setSize(""325"", Integer
									.toString(widget_count * 28));
							FlexTable current_flextable = (FlexTable) outterAbsolutePanel
									.getParent();

							int row = user_for_flextable
									.get(current_innerAbsolutePanel);
							current_flextable.getCellFormatter().setHeight(
									row,
									1,
									Integer.toString(outterAbsolutePanel
											.getOffsetHeight()));

							paramInfo.setIsUserFilled(false);
							// 如果路径信息还是空的，则直接保存，否则把这次路径信息拼接到上次信息的末尾，并且保证路径信息来源是下拉列表从上往下的得到的
							for (int i = 0; i < outterAbsolutePanel
									.getWidgetCount(); i++) {
								AbsolutePanel innerAbsolutePanel = (AbsolutePanel) outterAbsolutePanel
										.getWidget(i);
								TextBox currentTextBox = (TextBox) innerAbsolutePanel
										.getWidget(0);
								// 设置保存的值的来源，用路径的方式表示,保存的时候把服务名换成id号
								String valueString = currentTextBox
										.getValue();
								// 将保存的路径信息中的服务名替换为id号
								String[] divided = valueString.split(""\\."");
								String value_for_save;

								// if the last String of divided equals
								// ""currentDate"",it imply the configure is a
								// loop variable
								if (divided[divided.length - 1]
										.equals(""currentDate (Variable)"")) {
									String total_name = """";
									for (int j = divided.length - 2; j >= 0; j--) {
										String loopTaskName = divided[j];
										if (j == divided.length - 2) {
											total_name = loopTaskName;
										} else {
											total_name = loopTaskName + "".""
													+ total_name;
										}
									}
									String loopID = dbe.service_name_to_id
											.get(total_name);

									value_for_save = loopID + "".""
											+ ""currentDate (Variable)"";
								} else {
									int current_level = dbe.gde.tabs
											.getWidgetCount();
									if (isIsstart()) {
										String serviceName = divided[0];
										for (int j = 1; j < current_level - 1; j++) {
											serviceName += ""."" + divided[j];
										}
										String serviceID = dbe.service_name_to_id
												.get(serviceName);
										value_for_save = valueString
												.replace(serviceName,
														serviceID);
									} else {
										String serviceName = divided[0];
										for (int j = 1; j < current_level; j++) {
											serviceName += ""."" + divided[j];
										}
										String serviceID = dbe.service_name_to_id
												.get(serviceName);
										value_for_save = valueString
												.replace(serviceName,
														serviceID);
									}
								}
								// //current_level表示当前的子工作流的深度
								// int current_level =
								// dbe.gde.tabs.getWidgetCount();
								// //如果字符串被分成两个字符串，说明配置参数是一个loop的内部变量
								// if(divided.length==current_level){
								// String variableName =
								// divided[divided.length-1];
								// SubDiagram subDiagram = (SubDiagram)dbe;
								// LoopTask loopTask = subDiagram.loopTask;
								// String LoopID = loopTask.getID();
								// value_for_save = LoopID+"".""+variableName;
								//											
								// }
								// //否则就是前一个节点的输出路径
								// else{
								// if(isIsstart()){
								// String serviceName = divided[0];
								// for(int j=1;j<current_level-1;j++){
								// serviceName += "".""+divided[j];
								// }
								// String serviceID =
								// dbe.service_name_to_id.get(serviceName);
								// value_for_save =
								// valueString.replace(serviceName,serviceID);
								// }
								// else{
								// String serviceName=divided[0];
								// for(int j=1;j<current_level;j++){
								// serviceName += "".""+divided[j];
								// }
								// String serviceID =
								// dbe.service_name_to_id.get(serviceName);
								// value_for_save =
								// valueString.replace(serviceName,serviceID);
								// }
								//											
								// }

								// String value_for_save =
								// treeItemName.replace((CharSequence)valueString,(CharSequence)Integer.toString(service_id.get(valueString)));
								// if there is only one input configure ,
								// set the value directly,else concatenate
								// all the input configure
								if (i == 0) {
									paramInfo.setParamValue(value_for_save);
								} else {
									paramInfo.setParamValue(paramInfo
											.getParamValue()
											+ ""+"" + value_for_save);
								}
							}
						}

					}

				});

				// Get_preTask_all(); //在Configure_Service方法中已经调用过一次
				// 如果是子工作流中的节点，则在配置服务的可选项中，加入此子工作流所属的loop的date属性
				if (belongToSubWorkflow) {
					SubDiagram subDiagram = (SubDiagram) dbe;
					if (subDiagram.loopTask.getText().equals(""Loop"")) {

					} else {
						staticTree.addItem(subDiagram.loopTask.getTitle()
								+ "".""
								+ subDiagram.loopTask.getVariableName()
								+ "" (Variable)"");
					}
					if (subDiagram.loopTask.belongToSubWorkflow) {
						SubDiagram subDiagram2 = (SubDiagram) subDiagram.loopTask.dbe;
						if (!subDiagram2.loopTask.getText().equals(""Loop"")) {
							staticTree.addItem(subDiagram2.loopTask
									.getTitle()
									+ "".""
									+ subDiagram2.loopTask
											.getVariableName()
									+ "" (Variable)"");
						}
					}
				}

				for (Iterator<Workflowtasknode> iterator = preTaskList.iterator(); iterator
						.hasNext();) {
					Workflowtasknode workflowtasknode = (Workflowtasknode) iterator.next();
					// 判断前端相邻节点是否为choice，如果是的话表示其控制流的功能，不需要配置数据属性
					if (!workflowtasknode.getText().equals(""Choice"")) {
						if (workflowtasknode.getText().equals(""Loop"")) {
							LoopTask loopTask = (LoopTask) workflowtasknode;
							if (loopTask.getServiceConfigure()
									.getMethodInfo() != null) {
								TreeItem serviceName = staticTree
										.addItem(loopTask.getTitle());
								service_id.put(loopTask.getTitle(),
										loopTask.hashCode());
								// for(Iterator<MethodInfo> iterator2 =
								// simpleTask.getServiceInfo().getMethodInfoArray().iterator();iterator2.hasNext();){
								// MethodInfo methodInfo =
								// (MethodInfo)iterator2.next();
								// TreeItem output =
								// serviceName.addItem(methodInfo.getMethodName()+"".OutputInfo"");
								// addParamInfoInTree(output,paramInfo,
								// methodInfo.getOutputInfo().getParamInfoArray());
								// }
								MethodInfo methodInfo = loopTask
										.getServiceConfigure()
										.getMethodInfo();
								if (methodInfo != null) {
									TreeItem output = serviceName
											.addItem(methodInfo
													.getMethodName()
													+ "".OutputInfo"");
									addParamInfoInTree(output, paramInfo,
											methodInfo.getOutputInfo()
													.getParamInfoArray());
								}
							}
						} else if (workflowtasknode.getText().equals(""TLoop"")) {
							NonFixedFor nonFixedFor = (NonFixedFor) workflowtasknode;
							if (nonFixedFor.getServiceConfigure()
									.getMethodInfo() != null) {
								TreeItem serviceName = staticTree
										.addItem(nonFixedFor.getTitle());
								service_id.put(nonFixedFor.getTitle(),
										nonFixedFor.hashCode());
								// for(Iterator<MethodInfo> iterator2 =
								// simpleTask.getServiceInfo().getMethodInfoArray().iterator();iterator2.hasNext();){
								// MethodInfo methodInfo =
								// (MethodInfo)iterator2.next();
								// TreeItem output =
								// serviceName.addItem(methodInfo.getMethodName()+"".OutputInfo"");
								// addParamInfoInTree(output,paramInfo,
								// methodInfo.getOutputInfo().getParamInfoArray());
								// }
								MethodInfo methodInfo = nonFixedFor
										.getServiceConfigure()
										.getMethodInfo();
								if (methodInfo != null) {
									TreeItem output = serviceName
											.addItem(methodInfo
													.getMethodName()
													+ "".OutputInfo"");
									addParamInfoInTree(output, paramInfo,
											methodInfo.getOutputInfo()
													.getParamInfoArray());
								}
							}
						} else {
							// check whether preNode has been configured
							// ,then determine how to display the preNode
							// information
							ServiceTask serviceTask = (ServiceTask)workflowtasknode;
							if (serviceTask.getServiceConfigure()
									.getMethodInfo() != null) {
								TreeItem serviceName = staticTree
										.addItem(workflowtasknode.getTitle());
								service_id.put(workflowtasknode.getTitle(),
										workflowtasknode.hashCode());
								// for(Iterator<MethodInfo> iterator2 =
								// simpleTask.getServiceInfo().getMethodInfoArray().iterator();iterator2.hasNext();){
								// MethodInfo methodInfo =
								// (MethodInfo)iterator2.next();
								// TreeItem output =
								// serviceName.addItem(methodInfo.getMethodName()+"".OutputInfo"");
								// addParamInfoInTree(output,paramInfo,
								// methodInfo.getOutputInfo().getParamInfoArray());
								// }
								MethodInfo methodInfo = serviceTask
										.getServiceConfigure()
										.getMethodInfo();
								if (methodInfo != null) {
									TreeItem output = serviceName
											.addItem(methodInfo
													.getMethodName()
													+ "".OutputInfo"");
									addParamInfoInTree(output, paramInfo,
											methodInfo.getOutputInfo()
													.getParamInfoArray());
								}
							}
						}
					}

				}

				total_staticTreeWrapper = new ScrollPanel(staticTree);
				total_staticTreeWrapper
						.ensureDebugId(""cwTree-staticTree-Wrapper"");
				total_staticTreeWrapper
						.addStyleName(""no-transparent-panel"");
				total_staticTreeWrapper.setSize(""300px"", ""300px"");

				/************************************** 将几层absolutepanel整体扩大 *************************/
				Image current_image = (Image) event.getSource();
				AbsolutePanel current_innerAbsolutePanel = (AbsolutePanel) current_image
						.getParent();
				AbsolutePanel outterAbsolutePanel = (AbsolutePanel) current_innerAbsolutePanel
						.getParent();
				int image_relativeheight = current_innerAbsolutePanel
						.getAbsoluteTop()
						- outterAbsolutePanel.getAbsoluteTop();
				current_innerAbsolutePanel.setSize(""325"", ""328"");
				outterAbsolutePanel.setSize(""325"", Integer
						.toString(300 + 28 * outterAbsolutePanel
								.getWidgetCount()));
				FlexTable current_flextable = (FlexTable) outterAbsolutePanel
						.getParent(); // 此块的设置使得absolutepanel丧失了松耦合特性

				int row = user_for_flextable
						.get(current_innerAbsolutePanel);
				current_flextable.getCellFormatter().setHeight(row, 1,
						Integer.toString(328 + image_relativeheight));

				current_innerAbsolutePanel.add(total_staticTreeWrapper, 15,
						28);

				int location = outterAbsolutePanel
						.getWidgetIndex(current_innerAbsolutePanel);
				for (; location + 1 < outterAbsolutePanel.getWidgetCount(); location++) {
					AbsolutePanel absolutePanel = (AbsolutePanel) outterAbsolutePanel
							.getWidget(location + 1);
					int relative_height = absolutePanel.getAbsoluteTop()
							- outterAbsolutePanel.getAbsoluteTop();
					outterAbsolutePanel.setWidgetPosition(absolutePanel, 0,
							relative_height + 300);
				}

			}
			// 若下拉列表展开了，则将其收回
			else {

				isopen = false;
				Image current_image = (Image) event.getSource();
				AbsolutePanel current_innerAbsolutePanel = (AbsolutePanel) current_image
						.getParent();
				AbsolutePanel outterAbsolutePanel = (AbsolutePanel) current_innerAbsolutePanel
						.getParent();
				current_innerAbsolutePanel.remove(total_staticTreeWrapper); // 已知新加入的scrollpanel的index是2，所以直接删除，否则容易出现越界错误
				current_innerAbsolutePanel.setSize(""325"", ""28"");
				int location = outterAbsolutePanel
						.getWidgetIndex(current_innerAbsolutePanel);
				for (; location + 1 < outterAbsolutePanel.getWidgetCount(); location++) {
					AbsolutePanel absolutePanel = (AbsolutePanel) outterAbsolutePanel
							.getWidget(location + 1);
					int relative_height = absolutePanel.getAbsoluteTop()
							- outterAbsolutePanel.getAbsoluteTop();
					outterAbsolutePanel.setWidgetPosition(absolutePanel, 0,
							relative_height - 300);
				}
				int widget_count = outterAbsolutePanel.getWidgetCount();
				outterAbsolutePanel.setSize(""325"", Integer
						.toString(widget_count * 28));
				FlexTable current_flextable = (FlexTable) outterAbsolutePanel
						.getParent();

				int row = user_for_flextable
						.get(current_innerAbsolutePanel);
				current_flextable.getCellFormatter().setHeight(
						row,
						1,
						Integer.toString(outterAbsolutePanel
								.getOffsetHeight()));
			}

		}

	});
	downlist_panelAbsolutePanel.add(downlist, 290, 2);
	downlist.setSize(""25"", ""23"");

	return downlist_panelAbsolutePanel;
}","// 此时的paraminfo已经是基本类型的
public AbsolutePanel Generate_empty_downpanel(final ParamInfo paramInfo) 
{
    AbsolutePanel panel = new AbsolutePanel();
    panel.setSize(""100%"", ""100%"");
    panel.add(new Label("" ""), AbsolutePanelPosition.CENTER);
    return panel;
}   ",1430,False
"/**
 * parse the xml to create serviceConfigure information
 * @throws ParserConfigurationException
 * @throws SAXException
 * @throws IOException
 */
public void parse() throws ParserConfigurationException, SAXException,
		IOException{
	File xmlFile = new File(xmlFilePath);
	DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
	DocumentBuilder builder = factory.newDocumentBuilder();
	Document doc = builder.parse(xmlFile);

	Element rootElement = doc.getDocumentElement();
	createServiceInfo(rootElement);
}","/**
 * parse the xml to create serviceConfigure information
 * @throws ParserConfigurationException
 * @throws SAXException
 * @throws IOException
 */





public void parse() throws ParserConfigurationException, SAXException,
		IOException 
{
	DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
	DocumentBuilder builder = factory.newDocumentBuilder();
	Document document = builder.parse(xmlPath);
	Element root = document.getDocumentElement();
	NodeList nodes = root.getChildNodes();
	for (int i = 0; i < nodes.getLength(); i++)
	{
		Node node = nodes.item(i);
		if (node.getNodeType() == Node.ELEMENT_NODE)
		{
			Element element = (Element) node;
			String name = element.getAttribute(""name"");
			String value = element.getAttribute(""value"");
			serviceConfigure.put(name, value);
		}
	}
}	",1432,False
"/**
 * @author lms
 * @param rootElement
 */
public void createServiceInfo(Element rootElement){
	ServiceConfigureInfo serviceInfo;
	NodeList nodeList = rootElement.getChildNodes();

	for (int index = 0; index < nodeList.getLength(); index++) {
		Node node = nodeList.item(index);

		if (node instanceof Element) {
			serviceInfo = new ServiceConfigureInfo();
			NodeList childNodeList = node.getChildNodes();

			for (int itemIndex = 0; itemIndex < childNodeList.getLength(); itemIndex++) {
				Node childNode = childNodeList.item(itemIndex);

				if (childNode instanceof Element) {
					if (((Element) childNode).getTagName().equals(""Name"")) {
						serviceInfo.setServiceName(childNode
								.getTextContent());
					}

					else if (((Element) childNode).getTagName().equals(
							""ClassPath"")) {
						serviceInfo.setServiceClassPath(childNode
								.getTextContent());
					}
				}
			}

			serviceConfigureInfosList.add(serviceInfo);
		}
	}
}","/**
 * @author lms
 * @param rootElement
 */
public void createServiceInfo(Element rootElement) 
{
    Element serviceInfo = rootElement.addElement(""serviceInfo"");
    serviceInfo.addAttribute(""name"", ""ServiceInfo"");
    serviceInfo.addAttribute(""description"", ""ServiceInfo"");
    serviceInfo.addAttribute(""id"", ""ServiceInfo"");
    serviceInfo.addAttribute(""type"", ""ServiceInfo"");
    serviceInfo.addAttribute(""qName"", ""ServiceInfo"");
    serviceInfo.addAttribute(""xmi:id"", ""ServiceInfo"");
    serviceInfo.addAttribute(""href"", ""ServiceInfo"");
}   ",1433,False
"/** workflow */
public Panel_Workflow(Panel_Overview panel_Overview,
		Panel_Calendar panelGoogleCalendar){

	overview_panel = panel_Overview;
	calendar_panel = panelGoogleCalendar;
	base = new WorkflowEditModule(overview_panel);
	base.onModuleLoad();

	// workflow style
	this.setSize(""100%"", ""100%"");
	DOM.setStyleAttribute(this.getElement(), ""borderLeft"",
			""10px solid #C3D9FF"");
	DOM.setStyleAttribute(this.getElement(), ""borderBottom"",
			""10px solid #C3D9FF"");

	// Create a pop up to show the contact info when a contact is clicked
	Popup = new PopupPanel(true, false);
	Popup.removeStyleName(""gwt-PopupPanel"");
	Popup.setSize(""80"", ""180"");

	// head
	Label head = new Label(""Event&Workflow"");
	{
		head.setSize(""100%"", ""30"");
		DOM.setStyleAttribute(head.getElement(), ""paddingTop"", ""6px"");
		DOM.setStyleAttribute(head.getElement(), ""paddingBottom"", ""3px"");
		DOM.setStyleAttribute(head.getElement(), ""fontFamily"",
				""Arial, sans-serif"");
		DOM.setStyleAttribute(head.getElement(), ""fontSize"", ""13pt"");
		DOM.setStyleAttribute(head.getElement(), ""fontWeight"", ""bold"");
		DOM.setStyleAttribute(head.getElement(), ""backgroundColor"",
				""#C3D9FF"");
	}
	this.add(head, 0, 0);

	// confirm
	final AbsolutePanel confirm = new AbsolutePanel();
	{
		confirm.setWidth(""100%"");
		confirm.setHeight(""30"");
		DOM.setStyleAttribute(confirm.getElement(), ""backgroundColor"",
				""#E1EDF9"");
		Hyperlink hyperlink = new Hyperlink(""« Back to Calendar"", ""back"");
		DOM.setStyleAttribute(hyperlink.getElement(), ""fontSize"", ""10pt"");
		hyperlink.addClickHandler(new ClickHandler() {
			@Override
			public void onClick(ClickEvent event) {
				overview_panel.calendar_show();
			}
		});
		Button ok = new Button(""Save"");
		Button cancel = new Button(""Cancel"");
		Button delete = new Button(""Delete"");
		ok.removeStyleName(""gwt-Button"");
		cancel.removeStyleName(""gwt-Button"");
		delete.removeStyleName(""gwt-Button"");
		DOM.setStyleAttribute(ok.getElement(), ""fontSize"", ""8pt"");
		DOM.setStyleAttribute(cancel.getElement(), ""fontSize"", ""8pt"");
		DOM.setStyleAttribute(delete.getElement(), ""fontSize"", ""8pt"");

		confirm.add(hyperlink, 10, 10);
		confirm.add(ok, 130, 5);
		confirm.add(cancel, 175, 5);
		confirm.add(delete, 228, 5);
	}
	this.add(confirm, 0, 30);

	// calendar settings
	AbsolutePanel calendarsettings = new AbsolutePanel();
	calendarsettings.setWidth(""100%"");
	calendarsettings.setHeight(""140"");
	AbsolutePanel detailpanel = setDetail();
	calendarsettings.add(detailpanel, 10, 10);
	AbsolutePanel riskPanel = setRisk();
	calendarsettings.add(riskPanel, detailpanel.getOffsetWidth() + 30, 10);
	this.add(calendarsettings, 0, 60);

	// add workflow
	final AbsolutePanel workflowPanel_outer = new AbsolutePanel();
	workflowPanel_outer.setWidth(""100%"");
	workflowPanel_outer.setHeight(""100%"");

	workflowPanel_inner = new AbsolutePanel();
	workflowPanel_inner.setSize(""99%"", ""99%"");
	DOM.setStyleAttribute(workflowPanel_inner.getElement(), ""border"",
			""10px solid #DDDDDD"");
	DOM.setStyleAttribute(workflowPanel_inner.getElement(), ""borderTop"",
			""5px solid #DDDDDD"");

	Label label_w = new Label(""Edit Workflow"");
	label_w.setWidth(""100%"");
	label_w.setHeight(""22"");
	DOM.setStyleAttribute(label_w.getElement(), ""backgroundColor"",
			""#DDDDDD"");
	DOM.setStyleAttribute(label_w.getElement(), ""fontSize"", ""11pt"");
	DOM.setStyleAttribute(label_w.getElement(), ""fontWeight"", ""bold"");
	workflowPanel_inner.add(label_w, 0, 0);
	workflowPanel_inner.add(base.tabs, 0, 22);
	workflowPanel_outer.add(workflowPanel_inner, 10, 15);
	this.add(workflowPanel_outer, 0, 200);

	// save button click handler
	((Button) (confirm.getWidget(1))).addClickHandler(new ClickHandler() {
		@Override
		public void onClick(ClickEvent event) {

			time_Start = ((DateBox) textBox2.getWidget(0)).getTextBox()
					.getText()
					+ "" "" + ((TextBox) textBox2.getWidget(1)).getText();
			time_End = ((DateBox) textBox2.getWidget(4)).getTextBox()
					.getText()
					+ "" "" + ((TextBox) textBox2.getWidget(3)).getText();

			// set client_workflow value
			Client_Workflow client_Workflow = base.diagramBuilderExample
					.save_workflow_in_workflowmode();
			if (base.diagramBuilderExample.check == false) {

			} else {
				// set appointment value
				calendar_panel.workflowApp.setDescription(text_Des);
				calendar_panel.workflowApp.setEnd(dateFormat
						.parse(time_End));
				calendar_panel.workflowApp.setStart(dateFormat
						.parse(time_Start));
				calendar_panel.workflowApp.setTitle(text_What);
				if (calendar_panel.workflowApp.getStart().getYear() != calendar_panel.workflowApp
						.getEnd().getYear()
						|| calendar_panel.workflowApp.getStart().getMonth() != calendar_panel.workflowApp
								.getEnd().getMonth()
						|| calendar_panel.workflowApp.getStart().getDate() != calendar_panel.workflowApp
								.getEnd().getDate()) {
					calendar_panel.workflowApp.setMultiDay(true);
				}
				// set calendar_client
				calendar_panel.workflowApp.setAtoC();
				calendar_panel.workflowApp.calendarClient
						.setUserid(overview_panel.userid);
				calendar_panel.workflowApp.calendarClient.setDone(false);

				// if this is a new event (cos calendarid=null)
				if (calendar_panel.workflowApp.calendarClient
						.getCalendarid() == null
						|| calendar_panel.workflowApp.calendarClient
								.getCalendarid() == 0) {

					overview_panel.calendar_Service.saveCalendar(
							calendar_panel.workflowApp.calendarClient,
							client_Workflow, new AsyncCallback<Integer>() {
								@Override
								public void onFailure(Throwable caught) {
									Window.alert(""fail to save"");
								}

								@Override
								public void onSuccess(Integer result) {
									if (result != -1 && result != -2
											&& result != null) {
										calendar_panel.workflowApp.calendarClient
												.setCalendarid(result);
										calendar_panel.dayView
												.addAppointment(calendar_panel.workflowApp);
										overview_panel.calendar_show();
									}
									if (result == -1)
										Window.alert(""NamingError"");
									if (result == -2)
										Window.alert(""IOError"");
								}
							});
				} else
				// else update the event
				{
					overview_panel.calendar_Service.updateCalendar(
							calendar_panel.workflowApp.calendarClient,
							client_Workflow, new AsyncCallback<Integer>() {
								@Override
								public void onFailure(Throwable caught) {
									Window.alert(""fail to update"");
								}

								@Override
								public void onSuccess(Integer result) {
									if (result != -1 && result != -2
											&& result != null) {
										calendar_panel.dayView
												.updateAppointment(calendar_panel.workflowApp);
										overview_panel.calendar_show();
									}
									if (result == -1)
										Window.alert(""NamingError"");
									if (result == -2)
										Window.alert(""IOError"");
								}
							});
				}
			}

		}
	});

	// cancel button click handler
	((Button) (confirm.getWidget(2))).addClickHandler(new ClickHandler() {
		@Override
		public void onClick(ClickEvent event) {
			// turn the appointment to original
			overview_panel.calendar_show();
		}
	});

	// delete button click handler
	((Button) (confirm.getWidget(3))).addClickHandler(new ClickHandler() {
		@Override
		public void onClick(ClickEvent event) {
			// turn the appointment to original
			if (calendar_panel.workflowApp.calendarClient.getCalendarid() == null
					|| calendar_panel.workflowApp.calendarClient
							.getCalendarid() == 0) {
				overview_panel.calendar_show();
			} else {
				overview_panel.calendar_Service.deleteCalendar(
						calendar_panel.workflowApp.calendarClient
								.getCalendarid(),
						new AsyncCallback<String>() {
							@Override
							public void onFailure(Throwable caught) {
								Window.alert(""fail to remove the calendar"");
							}

							@Override
							public void onSuccess(String result) {
								calendar_panel.dayView
										.removeAppointment(calendar_panel.workflowApp);
								overview_panel.calendar_show();
							}
						});
			}
		}
	});

	// resize the window
	this.setHeight(Window.getClientHeight() - 90 + ""px"");
	Window.addResizeHandler(new ResizeHandler() {
		@Override
		public void onResize(ResizeEvent event) {
			int h = event.getHeight();
			panel_Workflow.setHeight(h - 90 + ""px"");
		}
	});
}","/** workflow */

public Panel_Workflow(Panel_Overview panel_Overview,
		Panel_Calendar panelGoogleCalendar) 
{
	this.panel_Overview = panel_Overview;
	this.panelGoogleCalendar = panelGoogleCalendar;

	this.setLayout(new BorderLayout());
	this.add(panel_Overview, BorderLayout.CENTER);
	this.add(panelGoogleCalendar, BorderLayout.SOUTH);
}	",1436,False
"// public ArrayList<String> GetServiceName() {
// ServiceConfigureXmlParse xmlParse = new ServiceConfigureXmlParse();
// ArrayList<ServiceConfigureInfo> serviceInfolist = new
// ArrayList<ServiceConfigureInfo>();
//		
// try
// {
// xmlParse.parse();
// }
// catch (ParserConfigurationException e)
// {
// e.printStackTrace();
// }
// catch (SAXException e)
// {
// e.printStackTrace();
// }
// catch (IOException e)
// {
// e.printStackTrace();
// }
// serviceInfolist = xmlParse.getServiceConfigureInfosList();
//		
// ArrayList<String> serviceNameList = new ArrayList<String>();
// for(Iterator iterator = serviceInfolist.iterator();iterator.hasNext();){
// ServiceConfigureInfo serviceConfigureInfo =
// (ServiceConfigureInfo)iterator.next();
// serviceNameList.add(serviceConfigureInfo.getServiceName());
// }
//		
// return serviceNameList;
// }
public ServiceInfo getServiceInfo(String ServiceName){

	CreateServiceInfo service = new CreateServiceInfo(ServiceName);
	ServiceInfo serviceInfo = new ServiceInfo();

	try {
		service.parseClass();
	}

	catch (ClassNotFoundException e) {
		e.printStackTrace();
	}

	serviceInfo = service.getServiceInfo();

	return serviceInfo;
}","// public ArrayList<String> GetServiceName() {
// ServiceConfigureXmlParse xmlParse = new ServiceConfigureXmlParse();
// ArrayList<ServiceConfigureInfo> serviceInfolist = new
// ArrayList<ServiceConfigureInfo>();
//		
// try
// {
// xmlParse.parse();
// }
// catch (ParserConfigurationException e)
// {
// e.printStackTrace();
// }
// catch (SAXException e)
// {
// e.printStackTrace();
// }
// catch (IOException e)
// {
// e.printStackTrace();
// }
// serviceInfolist = xmlParse.getServiceConfigureInfosList();
//		
// ArrayList<String> serviceNameList = new ArrayList<String>();
// for(Iterator iterator = serviceInfolist.iterator();iterator.hasNext();){
// ServiceConfigureInfo serviceConfigureInfo =
// (ServiceConfigureInfo)iterator.next();
// serviceNameList.add(serviceConfigureInfo.getServiceName());
// }
//		
// return serviceNameList;
// }




public ServiceInfo getServiceInfo(String ServiceName) 
{
    ServiceConfigureXmlParse xmlParse = new ServiceConfigureXmlParse();
    ArrayList<ServiceConfigureInfo> serviceInfolist = new ArrayList<ServiceConfigureInfo>();

    try
    {
        xmlParse.parse();
    }
    catch (ParserConfigurationException e)
    {
        e.printStackTrace();
    }
    catch (SAXException e)
    {
        e.printStackTrace();
    }
    catch (IOException e)
    {
        e.printStackTrace();
    }
    serviceInfolist = xmlParse.getServiceConfigureInfosList();

    ServiceInfo serviceInfo = null;
    for(Iterator iterator = serviceInfolist.iterator();iterator.hasNext();){
        ServiceConfigureInfo serviceConfigureInfo = (ServiceConfigureInfo)iterator.next();
        if(serviceConfigureInfo.getServiceName().equals(ServiceName))
        {
            serviceInfo = new ServiceInfo();
            serviceInfo.setServiceName(serviceConfigureInfo.getServiceName());
            serviceInfo.setServiceType(serviceConfigureInfo.getServiceType());
            serviceInfo.setServiceIP(serviceConfigureInfo.getServiceIP());
            serviceInfo.setServicePort(serviceConfigureInfo.getServicePort());
            break;
        }
    }

    return serviceInfo;
}   ",1437,True
"// update output display ,traverse the outport list and display them again
public void refresh(){
	// int addheight = 20;
	panel1.setHeight(""60"");
	instance.setHeight(""60"");
	setHeight(""60"");
	instance.add(panel2, 0, 10);
	instance.add(panel4, 85, 45);
	for (int index = 0; index < outport_count; index++) {
		int panel1_original_height = panel1.getOffsetHeight();
		int instance_original_height = instance.getOffsetHeight();
		int looptask_original_height = getOffsetHeight();
		panel1.setHeight(Integer.toString(panel1_original_height + 20));
		instance.setHeight(Integer.toString(instance_original_height + 20));
		setHeight(Integer.toString(looptask_original_height + 20));

		Label key_label = (Label) label_array.get(index);
		MyPanel value_panel = (MyPanel) outport.get(key_label);
		panel1.add(key_label, 24, 10 + (index) * 20);
		instance.add(value_panel, 85, 10 + index * 20);
		instance.add(panel4, 85, 65 + index * 20);
	}
}","// update output display ,traverse the outport list and display them again
public void refresh() 
{
    if (outPortList.size() > 0)
    {
        for (int i = 0; i < outPortList.size(); i++)
        {
            outPortList.get(i).refresh();
        }
    }
}   ",1438,False
"/** Creates new form PrimeFieldElementFrame */
public PrimeFieldElementFrame(ConnectionHandler handler){
    super(handler);
    initComponents();
    initLogicComponents();
    jLabel1.setText(Kit.xmlReader.getTagElement(""PrimeFieldElementFrame"", ""HeaderLabel""));
    addTableBtn.setText(Kit.xmlReader.getTagElement(""PrimeFieldElementFrame"", ""AddTableBtn""));
    mulTableBtn.setText(Kit.xmlReader.getTagElement(""PrimeFieldElementFrame"", ""MulTableBtn""));
}","/** Creates new form PrimeFieldElementFrame */
public PrimeFieldElementFrame(ConnectionHandler handler) 
{
    this.handler = handler;
    initComponents();
    initMyComponents();
}   ",1443,False
"/** Creates new form NewJFrame */
public MatrixMultiplyFrame(ConnectionHandler handler){
    super(handler);
    initComponents();
    initLogicComponents();
    jLabel1.setText(Kit.xmlReader.getTagElement(""MatrixMultiplyFrame"", ""HeaderLabel""));
}","/** Creates new form NewJFrame */
public MatrixMultiplyFrame(ConnectionHandler handler) 
{
    this.handler = handler;
    initComponents();
}   ",1445,True
"/* checks whether the parameter values are correct: probably prime greater than 1 and base '1 < base < modul'
 * returns Tuple:
 * 1. argument = prime arguments (number greater than 1, 1 < base < modul) are correct true/false
 * 2. argument = message to describe what's false or all correct
 */
private Tuple<Boolean, String> checkPrimeArguments()
        throws IllegalArgumentException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException, ClassCastException{
    //Precondition
    assert !basesSet.isEmpty() && !maxBases.isEmpty() && !primeFactorsCollection.isEmpty() && !summandCollection.isEmpty(): ""At least one variable is empty. Number basesSet = "" +basesSet.size()+ "", Number maxBases = "" +maxBases.size()+ "", Number primeFactorsCollection = ""+primeFactorsCollection.size()+ "", Number summandCollection =""+summandCollection.size();

    boolean argsCorrect = true;
    String argsAnswer = ""Arguments are correct."";
    Z one = new Z(""1"");

    //checks whether the probably primes are greater than 1
    if(argsCorrect){
        for (Z primeCheck : maxBases){
            //Beware! The probably prime is greater +1 than the base, therefore test <0. The prime 2 let be passed.
            if (primeCheck.compareTo(one)< 0){
                 argsCorrect = false;
                 argsAnswer = ""There are only prime numbers >1"";
                 break;
            }
        }
    } //end of testing probability prime

    //checks whether 'bases' > 1 && bases < probably prime (max. possible base +1)
    if(argsCorrect){
        int i = 0;
        for(TreeSet<Z> base : basesSet){
            if (base.last().compareTo(new ArrayList<Z>(maxBases).get(i)) >0 && !new ArrayList<Z>(maxBases).get(i).equals(one)){
                argsCorrect = false;
                argsAnswer = ""Base 'a' too large. Lucas-Test requires a base:  1 < a < prime: base = "" +base.last()+ "" prime = "" +new ArrayList<Z>(maxBases).get(i);
                break;
            }
            if (base.first().compareTo(one) <= 0){
                if(base.first().isONE()){
                    if(base.size() > 1){
                        Iterator<Z> itModuls = base.iterator();
                        itModuls.next();
                        if(base.last().compareTo(itModuls.next()) >=0){
                            argsCorrect = false;
                            argsAnswer = ""Base 'a' too large. Lucas-Test requires a base:  1 < a < prime"";
                        }
                    }
                    if(isPrimeTwo(i)){
                        i++;
                        continue;
                    }
                }
                argsCorrect = false;
                argsAnswer = ""Base 'a' too small. Lucas-Test requires a base:  1 < a < prime: base = "" +base.first();
                break;
            }
            i++;
        }
    }//end of testing bases

    //check, wheter the passed factor lines are consistent (there have to the same number of base lines like summands).
    if(argsCorrect){
        if (maxBases.size() != summandCollection.size()){
            argsCorrect = false;
            argsAnswer = ""Error: Different number of factor bases and summands: bases = "" +maxBases.size()+ "" summands = "" +summandCollection.size();
        }
    }//end of testing lines of factors lines and summands
    return new Tuple<Boolean, String>(argsCorrect, argsAnswer);
}","/* checks whether the parameter values are correct: probably prime greater than 1 and base '1 < base < modul'
 * returns Tuple:
 * 1. argument = prime arguments (number greater than 1, 1 < base < modul) are correct true/false
 * 2. argument = message to describe what's false or all correct
 */
private Tuple<Boolean, String> checkPrimeArguments()
        throws IllegalArgumentException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException, ClassCastException 
{
    boolean primeArguments = true;
    String message = """";

    if (this.prime <= 1)
    {
        primeArguments = false;
        message += ""Prime must be greater than 1. "";
    }

    if (this.base <= 1 || this.base >= this.modul)
    {
        primeArguments = false;
        message += ""Base must be greater than 1 and less than the modul. "";
    }

    return new Tuple<>(primeArguments, message);
}       ",1453,False
"/**
 * Construct the BuddyIconUrl.<p>
 * If none available, return the 
 * <a href=""http://www.flickr.com/images/buddyicon.jpg"">default</a>,
 * or an URL assembled from farm, iconserver and nsid.
 *
 * @see <a href=""http://flickr.com/services/api/misc.buddyicons.html"">Flickr Documentation</a>
 * @param iconFarm
 * @param iconServer
 * @param id
 * @return The BuddyIconUrl
 */
public static String createBuddyIconUrl(
    int iconFarm,
    int iconServer,
    String id
){
    /**
     * The default-URL, if the iconServer equals 0.
     */
    String iconUrl = ""http://www.flickr.com/images/buddyicon.jpg"";
    if (iconServer > 0) {
        iconUrl = ""http://farm""
        + iconFarm + "".static.flickr.com/""
        + iconServer + ""/buddyicons/""
        + id + "".jpg"";
    }
    return iconUrl;
}","/**
 * Construct the BuddyIconUrl.<p>
 * If none available, return the 
 * <a href=""http://www.flickr.com/images/buddyicon.jpg"">default</a>,
 * or an URL assembled from farm, iconserver and nsid.
 *
 * @see <a href=""http://flickr.com/services/api/misc.buddyicons.html"">Flickr Documentation</a>
 * @param iconFarm
 * @param iconServer
 * @param id
 * @return The BuddyIconUrl
 */
public static String createBuddyIconUrl(
    int iconFarm,
    int iconServer,
    String id
) 
{
    String buddyIconUrl;

    if (iconFarm == 0) {
        buddyIconUrl = ""XXXXXXXXXXX"" + iconFarm + "".static.flickr.com/"" + iconServer + ""/buddyicons/"" + id + "".jpg"";
    } else {
        buddyIconUrl = ""XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"";
    }

    return buddyIconUrl;
}   ",1462,True
"/**
 * Remove the specified photo from the group.
 *
 * @param photoId The photo ID
 * @param groupId The group ID
 * @throws IOException
 * @throws SAXException
 * @throws FlickrException
 */
public void remove(String photoId, String groupId) throws IOException, SAXException,
        FlickrException{
    List parameters = new ArrayList();
    parameters.add(new Parameter(""method"", METHOD_REMOVE));
    parameters.add(new Parameter(""api_key"", apiKey));

    parameters.add(new Parameter(""photo_id"", photoId));
    parameters.add(new Parameter(""group_id"", groupId));
    parameters.add(
        new Parameter(
            ""api_sig"",
            AuthUtilities.getSignature(sharedSecret, parameters)
        )
    );

    Response response = transport.post(transport.getPath(), parameters);
    if (response.isError()) {
        throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
    }
}","/**
 * Remove the specified photo from the group.
 *
 * @param photoId The photo ID
 * @param groupId The group ID
 * @throws IOException
 * @throws SAXException
 * @throws FlickrException
 */

public void remove(String photoId, String groupId) throws IOException, SAXException,
        FlickrException 
{
    Map<String, Object> parameters = new HashMap<String, Object>();
    parameters.put(""method"", METHOD_REMOVE);
    parameters.put(""photo_id"", photoId);
    parameters.put(""group_id"", groupId);

    Response response = callMethod(parameters);
    checkError(response);
}       ",1464,False
"/**
 * Get a signature for a list of parameters using the shared secret from the RequestContext.
 *
 * @param parameters The parameters
 * @return The signature String
 * @deprecated
 */
public static String getSignature(List parameters){
    RequestContext requestContext = RequestContext.getRequestContext();
    return getSignature(requestContext.getSharedSecret(), parameters);
}","/**
 * Get a signature for a list of parameters using the shared secret from the RequestContext.
 *
 * @param parameters The parameters
 * @return The signature String
 * @deprecated
 */
public static String getSignature(List parameters) 
{
    return getSignature(parameters, RequestContext.get().getSharedSecret());
}   ",1466,True
"/**
 * Add a photo to a group's pool.
 *
 * @param photoId The photo ID
 * @param groupId The group ID
 */
public void add(String photoId, String groupId) throws IOException, SAXException,
        FlickrException{
    List parameters = new ArrayList();
    parameters.add(new Parameter(""method"", METHOD_ADD));
    parameters.add(new Parameter(""api_key"", apiKey));

    parameters.add(new Parameter(""photo_id"", photoId));
    parameters.add(new Parameter(""group_id"", groupId));
    parameters.add(
        new Parameter(
            ""api_sig"",
            AuthUtilities.getSignature(sharedSecret, parameters)
        )
    );

    Response response = transport.post(transport.getPath(), parameters);
    if (response.isError()) {
        throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
    }
}","/**
 * Add a photo to a group's pool.
 *
 * @param photoId The photo ID
 * @param groupId The group ID
 */




public void add(String photoId, String groupId) throws IOException, SAXException,
        FlickrException 
{
    try {
        Map<String, Object> parameters = new HashMap<String, Object>();
        parameters.put(""method"", METHOD_ADD);
        parameters.put(""api_key"", apiKey);
        parameters.put(""photo_id"", photoId);
        parameters.put(""group_id"", groupId);

        Response response = transportAPI.post(transportAPI.getPath(), parameters, apiKey);
        if (response.isError()) {
            throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
        }
    } catch (FlickrException e) {
        throw e;
    } catch (Exception e) {
        throw new FlickrRuntimeException(e);
    }
}       ",1467,True
"/**
 * Return a list of Flickr pandas, from whom you can request photos using
 * the {@link com.aetrion.flickr.panda.PandaInterface#getPhotos(Panda, Set, int, int)}
 * API method.
 *
 * This method does not require authentication.
 *
 * @return A list of pandas
 * @throws FlickrException
 * @throws IOException
 * @throws SAXException
 */
public ArrayList getList() throws FlickrException, IOException, SAXException{
    ArrayList pandas = new ArrayList();
    List parameters = new ArrayList();
    parameters.add(new Parameter(""method"", METHOD_GET_LIST));
    parameters.add(new Parameter(""api_key"", apiKey));

    Response response = transportAPI.get(transportAPI.getPath(), parameters);
    if (response.isError()) {
        throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
    }
    Element pandaElement = response.getPayload();
    NodeList pandaNodes = pandaElement.getElementsByTagName(""panda"");
    for (int i = 0; i < pandaNodes.getLength(); i++) {
        pandaElement = (Element) pandaNodes.item(i);
        Panda panda = new Panda();
        panda.setName(XMLUtilities.getValue(pandaElement));
        pandas.add(panda);
    }
    return pandas;
}","/**
 * Return a list of Flickr pandas, from whom you can request photos using
 * the {@link com.aetrion.flickr.panda.PandaInterface#getPhotos(Panda, Set, int, int)}
 * API method.
 *
 * This method does not require authentication.
 *
 * @return A list of pandas
 * @throws FlickrException
 * @throws IOException
 * @throws SAXException
 */
public ArrayList getList() throws FlickrException, IOException, SAXException 
{
    ArrayList list = new ArrayList();
    ResultSet rs = null;
    try
    {
        rs = (ResultSet) this.callMethod(this.getParams());
        while (rs.next())
        {
            list.add(new Panda(rs));
        }
    }
    finally
    {
        if (rs != null)
        {
            rs.close();
        }
    }
    return list;
}   ",1468,True
"/**
 * Get the collection of favorites for the calling user or the specified user ID.
 *
 * @param userId The optional user ID.  Null value will be ignored.
 * @param perPage The optional per page value.  Values <= 0 will be ignored.
 * @param page The page to view.  Values <= 0 will be ignored.
 * @param extras a Set Strings representing extra parameters to send
 * @return The Collection of Photo objects
 * @see com.aetrion.flickr.photos.Extras
 * @throws IOException
 * @throws SAXException
 */
public PhotoList getList(String userId, int perPage, int page, Set extras) throws IOException,
        SAXException, FlickrException{
    PhotoList photos = new PhotoList();

    List parameters = new ArrayList();
    parameters.add(new Parameter(""method"", METHOD_GET_LIST));
    parameters.add(new Parameter(""api_key"", apiKey));

    if (userId != null) {
        parameters.add(new Parameter(""user_id"", userId));
    }
    if (extras != null) {
        parameters.add(new Parameter(""extras"", StringUtilities.join(extras, "","")));
    }
    if (perPage > 0) {
        parameters.add(new Parameter(""per_page"", new Integer(perPage)));
    }
    if (page > 0) {
        parameters.add(new Parameter(""page"", new Integer(page)));
    }
    parameters.add(
        new Parameter(
            ""api_sig"",
            AuthUtilities.getSignature(sharedSecret, parameters)
        )
    );

    Response response = transportAPI.get(transportAPI.getPath(), parameters);
    if (response.isError()) {
        throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
    }

    Element photosElement = response.getPayload();
    photos.setPage(photosElement.getAttribute(""page""));
		photos.setPages(photosElement.getAttribute(""pages""));
		photos.setPerPage(photosElement.getAttribute(""perpage""));
		photos.setTotal(photosElement.getAttribute(""total""));
    NodeList photoNodes = photosElement.getElementsByTagName(""photo"");
    for (int i = 0; i < photoNodes.getLength(); i++) {
        Element photoElement = (Element) photoNodes.item(i);
        photos.add(PhotoUtils.createPhoto(photoElement));
    }
    return photos;
}","/**
 * Get the collection of favorites for the calling user or the specified user ID.
 *
 * @param userId The optional user ID.  Null value will be ignored.
 * @param perPage The optional per page value.  Values <= 0 will be ignored.
 * @param page The page to view.  Values <= 0 will be ignored.
 * @param extras a Set Strings representing extra parameters to send
 * @return The Collection of Photo objects
 * @see com.aetrion.flickr.photos.Extras
 * @throws IOException
 * @throws SAXException
 */




public PhotoList getList(String userId, int perPage, int page, Set extras) throws IOException,
        SAXException, FlickrException 
{
    PhotoList photos = new PhotoList();

    List parameters = new ArrayList();
    parameters.add(new Parameter(""method"", METHOD_GET_LIST));
    if (userId != null) parameters.add(new Parameter(""user_id"", userId));
    if (perPage > 0) parameters.add(new Parameter(""per_page"", String.valueOf(perPage)));
    if (page > 0) parameters.add(new Parameter(""page"", String.valueOf(page)));
    if (extras != null && !extras.isEmpty()) parameters.add(new Parameter(""extras"", StringUtilities.join(extras, "","")));

    Response response = this.callMethod(parameters);

    Element photosElement = response.getPayload();
    NodeList photoNodes = photosElement.getElementsByTagName(""photo"");
    for (int i = 0; i < photoNodes.getLength(); i++) {
        Element photoElement = (Element) photoNodes.item(i);
        photos.add(PhotoUtils.createPhoto(photoElement));
    }

    return photos;
}       ",1471,True
"/**
 * Ask the Flickr Pandas for a list of recent public (and ""safe"") photos.
 *
 * This method does not require authentication.
 *
 * @param panda The panda to ask for photos from.
 * @param extras A set of Strings controlling the extra information to fetch for each returned record. {@link com.aetrion.flickr.photos.Extras#ALL_EXTRAS}
 * @param perPage The number of photos to show per page
 * @param page The page offset
 * @return A PhotoList
 * @throws FlickrException
 * @throws IOException
 * @throws SAXException
 * @see com.aetrion.flickr.photos.Extras
 */
public PhotoList getPhotos(Panda panda, Set extras, int perPage, int page) throws FlickrException, IOException, SAXException{
    ArrayList pandas = new ArrayList();
    List parameters = new ArrayList();
    parameters.add(new Parameter(""method"", METHOD_GET_PHOTOS));
    parameters.add(new Parameter(""api_key"", apiKey));

    parameters.add(new Parameter(""panda_name"", panda.getName()));

    if (extras != null && !extras.isEmpty()) {
        parameters.add(new Parameter(""extras"", StringUtilities.join(extras, "","")));
    }
    if (perPage > 0) {
        parameters.add(new Parameter(""per_page"", perPage));
    }
    if (page > 0) {
        parameters.add(new Parameter(""page"", page));
    }

    Response response = transportAPI.get(transportAPI.getPath(), parameters);
    if (response.isError()) {
        throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
    }
    Element photosElement = response.getPayload();
    PhotoList photos = PhotoUtils.createPhotoList(photosElement);
    return photos;
}","/**
 * Ask the Flickr Pandas for a list of recent public (and ""safe"") photos.
 *
 * This method does not require authentication.
 *
 * @param panda The panda to ask for photos from.
 * @param extras A set of Strings controlling the extra information to fetch for each returned record. {@link com.aetrion.flickr.photos.Extras#ALL_EXTRAS}
 * @param perPage The number of photos to show per page
 * @param page The page offset
 * @return A PhotoList
 * @throws FlickrException
 * @throws IOException
 * @throws SAXException
 * @see com.aetrion.flickr.photos.Extras
 */



public PhotoList getPhotos(Panda panda, Set extras, int perPage, int page) throws FlickrException, IOException, SAXException 
{
    PhotoList photos = new PhotoList();
    List params = new ArrayList();
    params.add(new Param(""api_key"", apiKey));
    params.add(new Param(""panda_name"", panda.getName()));
    params.add(new Param(""method"", METHOD_GET_RECENT));
    params.add(new Param(""per_page"", String.valueOf(perPage)));
    params.add(new Param(""page"", String.valueOf(page)));

    if (extras != null) {
        Iterator it = extras.iterator();
        while (it.hasNext()) {
            String extra = (String) it.next();
            params.add(new Param(""extras"", extra));
        }
    }

    Response response = transport.callMethod(params);
    Element root = response.getPayload();

    NodeList photoNodes = root.getElementsByTagName(""photo"");
    for (int i = 0; i < photoNodes.getLength(); i++) {
        Element photoElement = (Element) photoNodes.item(i);
        photos.add(PhotoUtils.createPhoto(photoElement));
    }
    return photos;
}   ",1472,True
"/**
 * Add a photo to the user's favorites.
 *
 * @param photoId The photo ID
 * @throws IOException
 * @throws SAXException
 * @throws FlickrException
 */
public void add(String photoId) throws IOException, SAXException, FlickrException{
    List parameters = new ArrayList();
    parameters.add(new Parameter(""method"", METHOD_ADD));
    parameters.add(new Parameter(""api_key"", apiKey));

    parameters.add(new Parameter(""photo_id"", photoId));
    parameters.add(
        new Parameter(
            ""api_sig"",
            AuthUtilities.getSignature(sharedSecret, parameters)
        )
    );

    Response response = transportAPI.post(transportAPI.getPath(), parameters);
    if (response.isError()) {
        throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
    }
}","/**
 * Add a photo to the user's favorites.
 *
 * @param photoId The photo ID
 * @throws IOException
 * @throws SAXException
 * @throws FlickrException
 */


public void add(String photoId) throws IOException, SAXException, FlickrException 
{
    Map<String, Object> parameters = new HashMap<String, Object>();
    parameters.put(""method"", METHOD_ADD);
    parameters.put(""photo_id"", photoId);

    Response response = callMethod(parameters);
    checkResponse(response);
}   ",1473,True
"/**
 * Get a list of all methods.
 *
 * @return The method names
 * @throws IOException
 * @throws SAXException
 * @throws FlickrException
 */
public Collection getMethods() throws IOException, SAXException, FlickrException{
    List parameters = new ArrayList();
    parameters.add(new Parameter(""method"", METHOD_GET_METHODS));
    parameters.add(new Parameter(""api_key"", apiKey));

    parameters.add(
        new Parameter(
            ""api_sig"",
            AuthUtilities.getSignature(sharedSecret, parameters)
        )
    );

    Response response = transport.get(transport.getPath(), parameters);
    if (response.isError()) {
        throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
    }

    Element methodsElement = response.getPayload();

    List methods = new ArrayList();
    NodeList methodElements = methodsElement.getElementsByTagName(""method"");
    for (int i = 0; i < methodElements.getLength(); i++) {
        Element methodElement = (Element) methodElements.item(i);
        methods.add(XMLUtilities.getValue(methodElement));
    }
    return methods;
}","/**
 * Get a list of all methods.
 *
 * @return The method names
 * @throws IOException
 * @throws SAXException
 * @throws FlickrException
 */


public Collection getMethods() throws IOException, SAXException, FlickrException 
{
    Map map = callMethod(""flickr.reflection.getMethods"");
    Collection coll = new ArrayList();
    Iterator keys = map.keySet().iterator();
    while (keys.hasNext()) {
        String key = (String) keys.next();
        coll.add(key);
    }
    return coll;
}   ",1475,True
"/**
 * Get the photos for the specified group pool, optionally filtering by taf.
 *
 * This method does not require authentication.
 *
 * @see com.aetrion.flickr.photos.Extras
 * @param groupId The group ID
 * @param tags The optional tags (may be null)
 * @param extras Set of extra-attributes to include (may be null)
 * @param perPage The number of photos per page (0 to ignore)
 * @param page The page offset (0 to ignore)
 * @return A Collection of Photo objects
 * @throws IOException
 * @throws SAXException
 * @throws FlickrException
 */
public PhotoList getPhotos(String groupId, String[] tags, Set extras, int perPage, int page)
  throws IOException, SAXException, FlickrException{
    PhotoList photos = new PhotoList();

    List parameters = new ArrayList();
    parameters.add(new Parameter(""method"", METHOD_GET_PHOTOS));
    parameters.add(new Parameter(""api_key"", apiKey));

    parameters.add(new Parameter(""group_id"", groupId));
    if (tags != null) {
        parameters.add(new Parameter(""tags"", StringUtilities.join(tags, "" "")));
    }
    if (perPage > 0) {
        parameters.add(new Parameter(""per_page"", new Integer(perPage)));
    }
    if (page > 0) {
        parameters.add(new Parameter(""page"", new Integer(page)));
    }

    if (extras != null) {
        StringBuffer sb = new StringBuffer();
        Iterator it = extras.iterator();
        for (int i = 0; it.hasNext(); i++) {
            if (i > 0) {
                sb.append("","");
            }
            sb.append(it.next());
        }
        parameters.add(new Parameter(Extras.KEY_EXTRAS, sb.toString()));
    }
    parameters.add(
        new Parameter(
            ""api_sig"",
            AuthUtilities.getSignature(sharedSecret, parameters)
        )
    );

    Response response = transport.get(transport.getPath(), parameters);
    if (response.isError()) {
        throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
    }
    Element photosElement = response.getPayload();
    photos.setPage(photosElement.getAttribute(""page""));
    photos.setPages(photosElement.getAttribute(""pages""));
    photos.setPerPage(photosElement.getAttribute(""perpage""));
    photos.setTotal(photosElement.getAttribute(""total""));

    NodeList photoNodes = photosElement.getElementsByTagName(""photo"");
    for (int i = 0; i < photoNodes.getLength(); i++) {
        Element photoElement = (Element) photoNodes.item(i);
        photos.add(PhotoUtils.createPhoto(photoElement));
    }

    return photos;
}","/**
 * Get the photos for the specified group pool, optionally filtering by taf.
 *
 * This method does not require authentication.
 *
 * @see com.aetrion.flickr.photos.Extras
 * @param groupId The group ID
 * @param tags The optional tags (may be null)
 * @param extras Set of extra-attributes to include (may be null)
 * @param perPage The number of photos per page (0 to ignore)
 * @param page The page offset (0 to ignore)
 * @return A Collection of Photo objects
 * @throws IOException
 * @throws SAXException
 * @throws FlickrException
 */








public PhotoList getPhotos(String groupId, String[] tags, Set extras, int perPage, int page)
  throws IOException, SAXException, FlickrException 
{
    PhotoList photos = new PhotoList();
    List params = new ArrayList();
    params.add(new Param(""method"", METHOD_GET_PHOTOS));
    params.add(new Param(OAuthInterface.PARAM_OAUTH_CONSUMER_KEY, apiKey));

    params.add(new Param(""group_id"", groupId));
    if (tags != null && tags.length > 0) {
        params.add(new Param(""tags"", StringUtilities.join(tags, "","")));
    }
    if (extras != null) {
        params.add(new Param(""extras"", StringUtilities.join(extras, "","")));
    }
    if (perPage > 0) {
        params.add(new Param(""per_page"", String.valueOf(perPage)));
    }
    if (page > 0) {
        params.add(new Param(""page"", String.valueOf(page)));
    }

    Response response = transportAPI.get(transportAPI.getPath(), params);
    if (response.isError()) {
        throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
    }

    Element photosElement = response.getPayload();
    NodeList photoElements = photosElement.getElementsByTagName(""photo"");
    for (int i = 0; i < photoElements.getLength(); i++) {
        Element photoElement = (Element) photoElements.item(i);
        photos.add(PhotoUtils.createPhoto(photoElement));
    }
    return photos;
} ",1477,True
"/**
 * Get a collection of all of the user's groups.
 *
 * @return A Collection of Group objects
 * @throws IOException
 * @throws SAXException
 * @throws FlickrException
 */
public Collection getGroups() throws IOException, SAXException, FlickrException{
    List groups = new ArrayList();

    List parameters = new ArrayList();
    parameters.add(new Parameter(""method"", METHOD_GET_GROUPS));
    parameters.add(new Parameter(""api_key"", apiKey));
    parameters.add(
        new Parameter(
            ""api_sig"",
            AuthUtilities.getSignature(sharedSecret, parameters)
        )
    );

    Response response = transport.get(transport.getPath(), parameters);
    if (response.isError()) {
        throw new FlickrException(response.getErrorCode(), response.getErrorMessage());
    }
    Element groupsElement = response.getPayload();
    NodeList groupNodes = groupsElement.getElementsByTagName(""group"");
    for (int i = 0; i < groupNodes.getLength(); i++) {
        Element groupElement = (Element) groupNodes.item(i);
        Group group = new Group();
        group.setId(groupElement.getAttribute(""id""));
        group.setName(groupElement.getAttribute(""name""));
        group.setAdmin(""1"".equals(groupElement.getAttribute(""admin"")));
        group.setPrivacy(groupElement.getAttribute(""privacy""));
        groups.add(group);
    }
    return groups;
}","/**
 * Get a collection of all of the user's groups.
 *
 * @return A Collection of Group objects
 * @throws IOException
 * @throws SAXException
 * @throws FlickrException
 */

public Collection getGroups() throws IOException, SAXException, FlickrException 
{
    Map callArgs = new HashMap();
    callArgs.put(""method"", METHOD_GET_GROUPS);
    return (Collection) call(callArgs);
}   ",1478,True
"/**
 * Adds the auth_token to the parameter list if it is necessary.
 * @param params
 */
public static void addAuthToken(List params){
    //Checking for the auth_token parameter
    Iterator it = params.iterator();
    boolean tokenFlag = false;
    while (it.hasNext()) {
        if (((Parameter) it.next()).getName().equals(""auth_token"")) {
            tokenFlag = true;
        }
    }

    if (!tokenFlag) {
        if (RequestContext.getRequestContext().getAuth() != null) {
            String authToken = RequestContext.getRequestContext().getAuth().getToken();
            if(authToken != null && !authToken.equals(""""))
                params.add(new Parameter(""auth_token"", authToken));
        }
    }
}","/**
 * Adds the auth_token to the parameter list if it is necessary.
 * @param params
 */
public static void addAuthToken(List params) 
{
    if (authToken != null)
    {
        params.add(new BasicNameValuePair(""auth_token"", authToken));
    }
}   ",1479,True
"/**
 * Create a cert Valid for one Hour
 * 
 * @param foaf
 *            the local foaf document name
 * @return an X509Claim
 * @throws Exception
 */
private X509Claim createOneHourCert(String foaf) throws Exception{
    CertCreator create = new CertCreator();
    create.addDurationInHours(""1"");
    create.setSubjectCommonName(""TEST"");
    URL webIdDoc = X509ClaimTest.class.getResource(foaf);
    webIdDoc = new URL(webIdDoc.getProtocol(), ""localhost"", webIdDoc.getFile());
    URL webId = new URL(webIdDoc, ""#me"");
    create.setSubjectWebID(webId.toString());
    create.setSubjectPublicKey(goodKey);
    create.generate();
    X509Certificate cert = create.getCertificate();
    X509Claim x509claim = new X509Claim(cert);
    return x509claim;
}","/**
 * Create a cert Valid for one Hour
 * 
 * @param foaf
 *            the local foaf document name
 * @return an X509Claim
 * @throws Exception
 */
private X509Claim createOneHourCert(String foaf) throws Exception 
{
    Calendar now = Calendar.getInstance();
    Calendar later = Calendar.getInstance();
    later.add(Calendar.HOUR, 1);
    return new X509Claim(foaf, now.getTime(), later.getTime());
}   ",1481,True
"/**
 * Builds FOAF+SSL Principal.
 * 
 * @param uri
 *            Web ID.
 * @param publicKey
 *            public key used to verify this Web ID.
 * @param dereferencedSecurely
 *            true if dereferenced securely (via HTTPS).
 * @param foafServerCertificateChain
 *            certificate chain of the server hosting the dereferenced FOAF
 *            file.
 */
public DereferencedFoafSslPrincipal(URI uri, PublicKey publicKey, boolean dereferencedSecurely,
        List<Certificate> foafServerCertificateChain){
    super(uri);
    this.publicKey = publicKey;
    this.deferencedSecurely = dereferencedSecurely;
    if (foafServerCertificateChain != null) {
        this.foafServerCertificateChain = Collections
                .unmodifiableList(foafServerCertificateChain);
    } else {
        this.foafServerCertificateChain = null;
    }
}","/**
 * Builds FOAF+SSL Principal.
 * 
 * @param uri
 *            Web ID.
 * @param publicKey
 *            public key used to verify this Web ID.
 * @param dereferencedSecurely
 *            true if dereferenced securely (via HTTPS).
 * @param foafServerCertificateChain
 *            certificate chain of the server hosting the dereferenced FOAF
 *            file.
 */
public DereferencedFoafSslPrincipal(URI uri, PublicKey publicKey, boolean dereferencedSecurely,
        List<Certificate> foafServerCertificateChain) 
{
    super(uri, publicKey, dereferencedSecurely, foafServerCertificateChain);
}       ",1482,True
"/**
 * Wrap an input stream from which no more than maxInput will be read
 *
 * @param wrapped  the intput stream to read from
 * @param maxInput the max number of bytes to read
 */
public SafeInputStream(InputStream wrapped, int maxInput){
    super(wrapped);
    this.maxInput = maxInput;
}","/**
 * Wrap an input stream from which no more than maxInput will be read
 *
 * @param wrapped  the intput stream to read from
 * @param maxInput the max number of bytes to read
 */
public SafeInputStream(InputStream wrapped, int maxInput) 
{
    this.wrapped = wrapped;
    this.maxInput = maxInput;
}   ",1487,True
"/**
 * This transforms a literal into a number if possible ie, it returns the
 * BigInteger of ""ddd""^^type
 * 
 * @param num
 *            the string representation of the number
 * @param type
 *            the type of the string representation
 * @return the number
 */
private static BigInteger toInteger_helper(String num, String type){
    if (type.equals(cert + ""decimal"") || type.equals(cert + ""int"")
            || type.equals(xsd + ""integer"") || type.equals(xsd + ""int"")
            || type.equals(xsd + ""nonNegativeInteger"")) {
        // cert:decimal is deprecated
        return new BigInteger(num.trim(), 10);
    } else if (type.equals(cert + ""hex"")) {
        String strval = cleanHex(num);
        return new BigInteger(strval, 16);
    } else {
        // it could be some other encoding - one should really write a
        // special literal transformation class
    }
    return null;
}","/**
 * This transforms a literal into a number if possible ie, it returns the
 * BigInteger of ""ddd""^^type
 * 
 * @param num
 *            the string representation of the number
 * @param type
 *            the type of the string representation
 * @return the number
 */
private static BigInteger toInteger_helper(String num, String type) 
{
    BigInteger ret = null;
    try
    {
        ret = new BigInteger(num);
    }
    catch (NumberFormatException e)
    {
        throw new NumberFormatException(
                ""Unable to parse '"" + num + ""' as type "" + type);
    }
    return ret;
}   ",1488,True
"/**
 * Returns the public key matching the private key used to sign the
 * assertion.
 * 
 * @return public key matching the private key used to sign the assertion.
 * @throws Exception
 */
public PublicKey getPublicKey() throws Exception{
    KeyStore keyStore = getKeyStore();
    Enumeration<String> aliases = keyStore.aliases();
    while (aliases.hasMoreElements()) {
        String alias = aliases.nextElement();
        if (keyStore.isKeyEntry(alias)) {
            return keyStore.getCertificate(alias).getPublicKey();
        }
    }
    return null;
}","/**
 * Returns the public key matching the private key used to sign the
 * assertion.
 * 
 * @return public key matching the private key used to sign the assertion.
 * @throws Exception
 */
public PublicKey getPublicKey() throws Exception 
{
    if (this.publicKey == null)
    {
        this.publicKey = this.keyFactory.generatePublic(this.spec);
    }
    return this.publicKey;
}   ",1489,False
"/**
 * Initialises the servlet: loads the keystore/keys to use to sign the
 * assertions and the issuer name.
 */
@Override
public void init() throws ServletException{
    super.init();

    KeyStore keyStore = null;

    String keystorePath = getInitParameter(KEYSTORE_PATH_INITPARAM);
    String keystoreType = getInitParameter(KEYSTORE_TYPE_INITPARAM);
    char[] keystorePasswordArray = null;
    char[] keyPasswordArray = null;
    {
        String keystorePassword = getInitParameter(KEYSTORE_PASSWORD_INITPARAM);
        if (keystorePassword != null) {
            keystorePasswordArray = keystorePassword.toCharArray();
        }
        String keyPassword = getInitParameter(KEY_PASSWORD_INITPARAM);
        if (keyPassword != null) {
            keyPasswordArray = keyPassword.toCharArray();
        } else {
            keyPasswordArray = keystorePasswordArray;
        }
    }
    String alias = getInitParameter(ALIAS_INITPARAM);
    Certificate certificate = null;
    PrivateKey privateKey = null;

    try {

        // todo: this should be done via lookup
        GraphCacheLookup.setCache(new MemoryGraphCache());

    } catch (Exception e) {
        throw new ServletException(e);
    }

    try {

        Context initCtx = new InitialContext();
        Context ctx = (Context) initCtx.lookup(""java:comp/env"");
        try {
            try {
                certificate = (Certificate) ctx.lookup(CERTIFICATE_JNDI_NAME);
            } catch (NameNotFoundException e) {
                LOG.log(Level.FINE, ""JNDI name not found"", e);
            }

            try {
                privateKey = (PrivateKey) ctx.lookup(PRIVATEKEY_JNDI_NAME);
            } catch (NameNotFoundException e) {
                LOG.log(Level.FINE, ""JNDI name not found"", e);
            }

            try {
                keyStore = (KeyStore) ctx.lookup(KEYSTORE_JNDI_NAME);
            } catch (NameNotFoundException e) {
                LOG.log(Level.FINE, ""JNDI name not found"", e);
            }

            try {
                String jndiKeystorePath = (String) ctx.lookup(KEYSTOREPATH_JNDI_NAME);
                if (jndiKeystorePath != null) {
                    keystorePath = jndiKeystorePath;
                }
            } catch (NameNotFoundException e) {
                LOG.log(Level.FINE, ""JNDI name not found"", e);
            }
            try {
                String jndiKeystoreType = (String) ctx.lookup(KEYSTORETYPE_JNDI_NAME);
                if (jndiKeystoreType != null) {
                    keystoreType = jndiKeystoreType;
                }
            } catch (NameNotFoundException e) {
                LOG.log(Level.FINE, ""JNDI name not found"", e);
            }

            try {
                String jndiKeystorePassword = (String) ctx.lookup(KEYSTOREPASSWORD_JNDI_NAME);
                if (jndiKeystorePassword != null) {
                    keystorePasswordArray = jndiKeystorePassword.toCharArray();
                }
            } catch (NameNotFoundException e) {
            }
            try {
                char[] jndiKeystorePasswordArray = (char[]) ctx
                        .lookup(KEYSTOREPASSWORDARRAY_JNDI_NAME);
                if (jndiKeystorePasswordArray != null) {
                    keystorePasswordArray = jndiKeystorePasswordArray;
                }
            } catch (NameNotFoundException e) {
                LOG.log(Level.FINE, ""JNDI name not found"", e);
            }

            try {
                String jndiKeyPassword = (String) ctx.lookup(KEYPASSWORD_JNDI_NAME);
                if (jndiKeyPassword != null) {
                    keyPasswordArray = jndiKeyPassword.toCharArray();
                }
            } catch (NameNotFoundException e) {
                LOG.log(Level.FINE, ""JNDI name not found"", e);
            }
            try {
                char[] jndiKeyPasswordArray = (char[]) ctx.lookup(KEYPASSWORDARRAY_JNDI_NAME);
                if (jndiKeyPasswordArray != null) {
                    keyPasswordArray = jndiKeyPasswordArray;
                }
            } catch (NameNotFoundException e) {
                LOG.log(Level.FINE, ""JNDI name not found"", e);
            }

            try {
                String jndiKeyAlias = (String) ctx.lookup(KEYALIAS_JNDI_NAME);
                if (jndiKeyAlias != null) {
                    alias = jndiKeyAlias;
                }
            } catch (NameNotFoundException e) {
                LOG.log(Level.FINE, ""JNDI name not found"", e);
            }
        } finally {
            if (ctx != null) {
                ctx.close();
            }
            if (initCtx != null) {
                initCtx.close();
            }
        }
    } catch (NameNotFoundException e) {
        LOG.log(Level.INFO, ""Unable to load JNDI context."", e);
    } catch (NamingException e) {
        LOG.log(Level.INFO, ""Unable to load JNDI context."", e);
    }

    if (keyPasswordArray == null) {
        keyPasswordArray = keystorePasswordArray;
    }

    if ((certificate == null) || (privateKey == null)) {
        if (keyStore == null) {
            try {
                InputStream ksInputStream = null;

                try {
                    if (keystorePath != null) {
                        ksInputStream = new FileInputStream(keystorePath);
                    }
                    keyStore = KeyStore.getInstance((keystoreType != null) ? keystoreType
                            : KeyStore.getDefaultType());
                    keyStore.load(ksInputStream, keystorePasswordArray);
                } finally {
                    if (ksInputStream != null) {
                        ksInputStream.close();
                    }
                }
            } catch (FileNotFoundException e) {
                LOG
                        .log(Level.SEVERE,
                                ""Error configuring servlet (could not load keystore)."", e);
                throw new ServletException(""Could not load keystore."");
            } catch (KeyStoreException e) {
                LOG
                        .log(Level.SEVERE,
                                ""Error configuring servlet (could not load keystore)."", e);
                throw new ServletException(""Could not load keystore."");
            } catch (NoSuchAlgorithmException e) {
                LOG
                        .log(Level.SEVERE,
                                ""Error configuring servlet (could not load keystore)."", e);
                throw new ServletException(""Could not load keystore."");
            } catch (CertificateException e) {
                LOG
                        .log(Level.SEVERE,
                                ""Error configuring servlet (could not load keystore)."", e);
                throw new ServletException(""Could not load keystore."");
            } catch (IOException e) {
                LOG
                        .log(Level.SEVERE,
                                ""Error configuring servlet (could not load keystore)."", e);
                throw new ServletException(""Could not load keystore."");
            }
        }

        try {
            if (alias == null) {
                Enumeration<String> aliases = keyStore.aliases();
                while (aliases.hasMoreElements()) {
                    String tempAlias = aliases.nextElement();
                    if (keyStore.isKeyEntry(tempAlias)) {
                        alias = tempAlias;
                        break;
                    }
                }
            }
            if (alias == null) {
                LOG
                        .log(
                                Level.SEVERE,
                                ""Error configuring servlet, invalid keystore configuration: alias unspecified or couldn't find key at alias: ""
                                        + alias);
                throw new ServletException(
                        ""Invalid keystore configuration: alias unspecified or couldn't find key at alias: ""
                                + alias);
            }
            if (privateKey == null) {
                privateKey = (PrivateKey) keyStore.getKey(alias, keyPasswordArray);
            }
            if (certificate == null) {
                certificate = keyStore.getCertificate(alias);
            }
        } catch (UnrecoverableKeyException e) {
            LOG.log(Level.SEVERE, ""Error configuring servlet (could not load keystore)."", e);
            throw new ServletException(""Could not load keystore."");
        } catch (KeyStoreException e) {
            LOG.log(Level.SEVERE, ""Error configuring servlet (could not load keystore)."", e);
            throw new ServletException(""Could not load keystore."");
        } catch (NoSuchAlgorithmException e) {
            LOG.log(Level.SEVERE, ""Error configuring servlet (could not load keystore)."", e);
            throw new ServletException(""Could not load keystore."");
        }
    }

    this.certificate = certificate;
    this.publicKey = certificate.getPublicKey();
    this.privateKey = privateKey;
}","/**
 * Initialises the servlet: loads the keystore/keys to use to sign the
 * assertions and the issuer name.
 */
@Override
public void init() throws ServletException 
{
    try
    {
        String keystorePath = getServletContext().getRealPath(""/WEB-INF/keystore.jks"");
        String keystorePassword = ""XXXXXXXX"";
        String keyPassword = ""XXXXXXXX"";
        String issuerName = ""XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"";

        _signer = new Signer(keystorePath, keystorePassword, keyPassword, issuerName);
    }
    catch (Exception e)
    {
        throw new ServletException(""Failed to initialise"", e);
    }
}   ",1490,False
"/**
 * Same test as testGoodLocalFoafXhtmlRDFaFile() but with a different mime
 * type
 * 
 * @throws Exception
 */
@Test
public void testGoodLocalFoafXhtmlRDFaFile2() throws Exception{
    mockStreamHandlerFactory.setUp(""application/xhtml+xml"", TEST_GOOD_FOAF_XHTML_FILENAME);
    WebIdClaim pr = new WebIdClaim(TEST_WEB_ID_URI, pubkey);
    assertTrue(pr.verify());
}","/**
 * Same test as testGoodLocalFoafXhtmlRDFaFile() but with a different mime
 * type
 * 
 * @throws Exception
 */
@Test
public void testGoodLocalFoafXhtmlRDFaFile2() throws Exception 
{
    String baseURI = ""XXXXXXXXXXXXXXXXXXXXXXXXXXX"";
    String path = ""src/test/resources/good/foaf-xhtml-rdfa-file2.xhtml"";
    String contentType = ""application/xhtml+xml"";
    runGoodLocalTest(baseURI, path, contentType);
}   ",1492,True
"/**
 * This is not fool proof
 *
 * @throws IOException
 */
@Override
public void reset() throws IOException{
    if (markSupported()) {
        read = pointer;
        super.reset();
    }
}","/**
 * This is not fool proof
 *
 * @throws IOException
 */
@Override
public void reset() throws IOException 
{
    if (this.in != null)
    {
        this.in.reset();
    }
}   ",1493,True
"/**
 * @param verifiedWebIDs
 *            a list of webIds identifying the user (only the fist will be
 *            used)
 * @param replyTo
 *            the service that the response is sent to
 * @return the URL of the response with the webid, timestamp appended and
 *         signed
 * @throws NoSuchAlgorithmException
 * @throws UnsupportedEncodingException
 * @throws InvalidKeyException
 * @throws SignatureException
 */
private String createSignedResponse(Collection<? extends WebIdClaim> verifiedWebIDs,
        String replyTo) throws NoSuchAlgorithmException, UnsupportedEncodingException,
        InvalidKeyException, SignatureException{
    /*
     * Reads the FoafSsl simple authn request.
     */
    String authnResp = replyTo;

    String sigAlg = null;
    if (""RSA"".equals(privateKey.getAlgorithm())) {
        sigAlg = ""SHA1withRSA"";
    } else if (""DSA"".equals(privateKey.getAlgorithm())) {
        sigAlg = ""SHA1withDSA"";
    } else {
        throw new NoSuchAlgorithmException(""Unsupported key algorithm type."");
    }

    URI webId = verifiedWebIDs.iterator().next().getWebId();
    authnResp += ""?"" + WEBID_PARAMNAME + ""=""
            + URLEncoder.encode(webId.toASCIIString(), ""UTF-8"");
    SimpleDateFormat dateFormat = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ssZ"");
    authnResp += ""&"" + TIMESTAMP_PARAMNAME + ""=""
            + URLEncoder.encode(dateFormat.format(Calendar.getInstance().getTime()), ""UTF-8"");

    String signedMessage = authnResp;
    Signature signature = Signature.getInstance(sigAlg);
    signature.initSign(privateKey);
    signature.update(signedMessage.getBytes(""UTF-8""));
    byte[] signatureBytes = signature.sign();
    authnResp += ""&"" + SIGNATURE_PARAMNAME + ""=""
            + URLEncoder.encode(new String(Base64.encode(signatureBytes)), ""UTF-8"");
    return authnResp;
}","/**
 * @param verifiedWebIDs
 *            a list of webIds identifying the user (only the fist will be
 *            used)
 * @param replyTo
 *            the service that the response is sent to
 * @return the URL of the response with the webid, timestamp appended and
 *         signed
 * @throws NoSuchAlgorithmException
 * @throws UnsupportedEncodingException
 * @throws InvalidKeyException
 * @throws SignatureException
 */
private String createSignedResponse(Collection<? extends WebIdClaim> verifiedWebIDs,
        String replyTo) throws NoSuchAlgorithmException, UnsupportedEncodingException,
        InvalidKeyException, SignatureException 
{
    String webId = verifiedWebIDs.iterator().next().getWebId();
    String timestamp = String.valueOf(System.currentTimeMillis());
    String response = replyTo + ""?webid="" + webId + ""&timestamp="" + timestamp;
    String signature = signResponse(response);
    return response + ""&signature="" + signature;
}   ",1494,False
"/**
 * Checks whether the certificate is valid at a given date.
 * 
 * @param validityDate
 *            date to test
 * @return true if the date is after notBefore and before notAfter.
 */
public boolean isCurrent(Date validityDate){
    /*
     * notAfter and notBefore are mandatory in X.509, so these two dates
     * should always be present in a certificate.
     */
    Date notBeforeDate = certClaim.getNotBefore();
    if (notBeforeDate == null || validityDate.before(notBeforeDate)) {
        return false;
    }
    Date notAfterDate = certClaim.getNotAfter();
    if (notAfterDate == null || validityDate.after(notAfterDate)) {
        return false;
    }
    return true;
}","/**
 * Checks whether the certificate is valid at a given date.
 * 
 * @param validityDate
 *            date to test
 * @return true if the date is after notBefore and before notAfter.
 */
public boolean isCurrent(Date validityDate) 
{
    if (validityDate == null)
    {
        return false;
    }

    return validityDate.after(notBefore) && validityDate.before(notAfter);
}   ",1496,True
"/**
 * Extracts the URIs in the subject alternative name extension of an X.509
 * certificate (perhaps others such as email addresses could also be
 * useful).
 * 
 * @param cert
 *            X.509 certificate from which to extract the URIs.
 * @return list of java.net.URIs built from the URIs in the subjectAltName
 *         extension.
 */
public static List<URI> getAlternativeURIName(X509Certificate cert)
        throws CertificateParsingException{
    ArrayList<URI> answers = new ArrayList<URI>();
    try {
        if (cert == null) {
            return answers;
        }
        Collection<List<?>> names = cert.getSubjectAlternativeNames();
        if (names == null) {
            return answers;
        }
        for (Iterator<List<?>> it = names.iterator(); it.hasNext();) {
            List<?> altNameList = it.next();
            Integer altNameType = (Integer) altNameList.get(0);
            if (altNameType == 6) {
                /*
                 * See X.509 spec, section 8.3.2.1 these are the URIs!
                 */
                Object altNameValue = altNameList.get(1);
                if (altNameValue instanceof String) {
                    try {
                        URI foafid = new URI((String) altNameValue);
                        answers.add(foafid);
                    } catch (URISyntaxException e) {
                        throw new CertificateParsingException(
                                ""Invalid URI in subject alt. name."", e);
                    }
                } else {
                    throw new CertificateParsingException(""Invalid URI in subject alt. name."");
                }
            }
        }
    } catch (CertificateParsingException e) {
        LOG.log(Level.WARNING,
                ""Unable to parse certificate for extracting the subjectAltNames."", e);
        throw e;
    }
    return answers;
}","/**
 * Extracts the URIs in the subject alternative name extension of an X.509
 * certificate (perhaps others such as email addresses could also be
 * useful).
 * 
 * @param cert
 *            X.509 certificate from which to extract the URIs.
 * @return list of java.net.URIs built from the URIs in the subjectAltName
 *         extension.
 */



public static List<URI> getAlternativeURIName(X509Certificate cert)
        throws CertificateParsingException 
{
    List<URI> uris = new ArrayList<URI>();
    Collection<List<?>> altNames = cert.getSubjectAlternativeNames();
    if (altNames != null)
    {
        for (List<?> an : altNames)
        {
            if (an.size() >= 2)
            {
                Integer type = (Integer)an.get(0);
                if (type == 6) // URI
                {
                    String uri = (String)an.get(1);
                    uris.add(URI.create(uri));
                }
            }
        }
    }
    return uris;
}       ",1497,False
"/**
 * Redirect request to the given url
 * 
 * @param response
 * @param respUrl
 *            1the response Url to redirect to
 */
private void redirect(HttpServletResponse response, String respUrl){
    response.setStatus(HttpServletResponse.SC_MOVED_TEMPORARILY);
    response.setHeader(""Location"", respUrl);
}","/**
 * Redirect request to the given url
 * 
 * @param response
 * @param respUrl
 *            1the response Url to redirect to
 */

private void redirect(HttpServletResponse response, String respUrl) 
{
    try
    {
        response.sendRedirect(respUrl);
    }
    catch (IOException e)
    {
        e.printStackTrace();
    }
}   ",1499,False
"/**
   󥹥󥹤ޤ

   @param props ϥץѥƥ
   @param threads ӥΥåɿ
*/
public DeliveryProcessor(final IOProperties props, final int threads){
	super(props);
	service = new DeliveryService<Note>(threads);
}","/**
   󥹥󥹤ޤ

   @param props ϥץѥƥ
   @param threads ӥΥåɿ
*/
public DeliveryProcessor(final IOProperties props, final int threads) 
{
    super(props, threads);
}  ",1507,True
"/**
   ޥɥ饤ΰѡޤ

   --ǻϤޤ򥪥ץȤƲᤷޤʳΰ
   ʳǥѡλޤ

   @param av ޥɥ饤ΰ
   @return ޥɥ饤ΰΤǽ˽и󥪥ץ
   ΰǸΰޤǤ
   @throws OptionsParsingException ʥץλ
*/
public String[] parseFore(final String[] av)
	throws OptionsParsingException{
	String s;
	int k;

	for (k = 0; k < av.length && isOption(s = av[k]); ++k) {
	    parseOption(s);
	}
	return Arrays.copyOfRange(av, k, av.length);
}","/**
   ޥɥ饤ΰѡޤ

   --ǻϤޤ򥪥ץȤƲᤷޤʳΰ
   ʳǥѡλޤ

   @param av ޥɥ饤ΰ
   @return ޥɥ饤ΰΤǽ˽и󥪥ץ
   ΰǸΰޤǤ
   @throws OptionsParsingException ʥץλ
*/
public String[] parseFore(final String[] av)
	throws OptionsParsingException 
{
	final String[] r = new String[av.length];
	for (int i = 0; i < av.length; i++) {
		r[i] = av[i];
	}
	return r;
}  ",1509,False
"/**
   ץѡޤ

   @param s ץ
   @throws OptionsParsingException ץΥѡ˼Ԥ
   ˥ޤ
*/
private void parseOption(final String s) throws OptionsParsingException{
	String argName;
	String argValue;
	Set<String> set;
	int n = s.indexOf('=');
	if (n < 0) {
	    argName = s.substring(2);
	    argValue = null;
	    set = options;
	} else {
	    argName = s.substring(2, n);
	    argValue = s.substring(n + 1);
	    set = argOptions;
	}
	if (!set.contains(argName)) {
	    throw new OptionsParsingException(""invalid option: "" + s);
	}
	OptionListener listener = listenerMap.get(argName);
	if (listener != null) {
	    listener.run(argName, argValue);
	}
	valueMap.put(argName, argValue);
}","/**
   ץѡޤ

   @param s ץ
   @throws OptionsParsingException ץΥѡ˼Ԥ
   ˥ޤ
*/
private void parseOption(final String s) throws OptionsParsingException 
{
    if (s.startsWith(""--""))
    {
        if (s.equals(""--help""))
        {
            printHelp();
            System.exit(0);
        }
        else if (s.equals(""--version""))
        {
            printVersion();
            System.exit(0);
        }
        else
        {
            throw new OptionsParsingException(""Unknown option: "" + s);
        }
    }
    else if (s.startsWith(""-""))
    {
        if (s.equals(""-h""))
        {
            printHelp();
            System.exit(0);
        }
        else if (s.equals(""-v""))
        {
            printVersion();
            System.exit(0);
        }
        else
        {
            throw new OptionsParsingException(""Unknown option: "" + s);
        }
    }
    else
    {
        throw new OptionsParsingException(""Unknown option: "" + s);
    }
}  ",1510,False
"/**
   Υץɲäޤ

   @param name ץ̾
   @param argName ̾
   @param help إץå
*/
public void add(final String name,
		    final String argName,
		    final String help){
	argOptions.add(name);
	helpMap.put(name + ""="" + argName, help);
}","/**
   Υץɲäޤ

   @param name ץ̾
   @param argName ̾
   @param help إץå
*/
public void add(final String name,
		    final String argName,
		    final String help) 
{
    Option option = new Option(name, argName, help);
    options.add(option);
}  ",1512,True
"/**
   gcovեgcovեϤǥ쥯ȥ
   ޤ
*/
protected final void makeOutputDir(){
	if (props.isGcovEnabled()) {
	    props.makeOutputDir();
	}
}","/**

   gcovեgcovեϤǥ쥯ȥ
   ޤ
*/
protected final void makeOutputDir() 
{
    File outputDir = new File(outputDirName);
    if (!outputDir.exists())
    {
        outputDir.mkdirs();
    }
}  ",1519,False
"/**
 * Partitions {@code items} into exactly two groups by applying the supplied {@code partitionCondition} to each
 * item.  All items for which {@code partitionCondition} returns {@code true} will be placed into one group, and all
 * items for which it returns {@code false} will be placed into the other.
 *
 * @param items              items to partition
 * @param partitionCondition {@link Condition} to use to separate items into two groups.
 * @param trueResults        all items for which {@code partitionCondition} returns {@code true} will be placed in
 *                           this {@link Collection}
 * @param falseResults       all items for which {@code partitionCondition} returns {@code false} will be placed in
 *                           this {@link Collection}
 *
 * @return a new {@link java.util.Map} of all items by their partition key.
 */
public static <X> void partition(final Iterable<X> items,
                                 final Collection<X> trueResults,
                                 final Collection<X> falseResults,
                                 final Condition<X> partitionCondition){
    for (X item : items) {
        // Quite pleased that this actually works in Java
        (partitionCondition.eval(item) ? trueResults : falseResults).add(item);
    }
}","/**
 * Partitions {@code items} into exactly two groups by applying the supplied {@code partitionCondition} to each
 * item.  All items for which {@code partitionCondition} returns {@code true} will be placed into one group, and all
 * items for which it returns {@code false} will be placed into the other.
 *
 * @param items              items to partition
 * @param partitionCondition {@link Condition} to use to separate items into two groups.
 * @param trueResults        all items for which {@code partitionCondition} returns {@code true} will be placed in
 *                           this {@link Collection}
 * @param falseResults       all items for which {@code partitionCondition} returns {@code false} will be placed in
 *                           this {@link Collection}
 *
 * @return a new {@link java.util.Map} of all items by their partition key.
 */
public static <X> void partition(final Iterable<X> items,
                                 final Collection<X> trueResults,
                                 final Collection<X> falseResults,
                                 final Condition<X> partitionCondition) 
{
    for (X item : items)
    {
        if (partitionCondition.test(item))
        {
            trueResults.add(item);
        }
        else
        {
            falseResults.add(item);
        }
    }
}   ",1520,True
"/**
 * @param boxedPrimitive boxed primitive
 *
 * @return the primitive {@link Class} (e.g. int.class) representing the type of the supplied boxed primitive (e.g.
 *         {@link Integer})
 */
public static Class getUnboxedClass(Object boxedPrimitive){
    final Class<?> c = boxedPrimitive.getClass();
    final Class unboxed = getUnboxedClass(c);
    return unboxed == null ? c : unboxed;
}","/**
 * @param boxedPrimitive boxed primitive
 *
 * @return the primitive {@link Class} (e.g. int.class) representing the type of the supplied boxed primitive (e.g.
 *         {@link Integer})
 */
public static Class getUnboxedClass(Object boxedPrimitive) 
{
    if (boxedPrimitive == null)
    {
        throw new IllegalArgumentException(""Parameter 'boxedPrimitive' must not be null"");
    }

    return unboxedClassMap.get(boxedPrimitive.getClass());
}   ",1522,True
"/**
 * @param random {@link Random} to use to generate random {@link Float}s
 *
 * @return a inexhaustable {@link Iterable} of random {@link Float}s using the supplied {@link Random}. See {@link
 *         java.util.Random#nextFloat()} for numeric range of returned values.
 */
public static Iterate<Float> random(final Random random){
    return Iterate.each(new Iterable<Float>()
    {
        @Override
        public Iterator<Float> iterator()
        {
            return new AbstractIterator<Float>()
            {
                public boolean hasNext()
                {
                    return true;
                }

                @SuppressWarnings({""IteratorNextCanNotThrowNoSuchElementException""})
                public Float next()
                {
                    return random.nextFloat();
                }
            };
        }
    });
}","/**
 * @param random {@link Random} to use to generate random {@link Float}s
 *
 * @return a inexhaustable {@link Iterable} of random {@link Float}s using the supplied {@link Random}. See {@link
 *         java.util.Random#nextFloat()} for numeric range of returned values.
 */
public static Iterate<Float> random(final Random random) 
{
    return new Iterate<Float>()
    {
        @Override
        public Iterator<Float> iterator()
        {
            return new Iterator<Float>()
            {
                @Override
                public boolean hasNext()
                {
                    return true;
                }

                @Override
                public Float next()
                {
                    return random.nextFloat();
                }
            };
        }
    };
}   ",1523,True
"/**
 * Partitions {@code items} into groups based on the partition key generated by {@code groupFunction}.
 *
 * @param items         items to partition
 * @param groupFunction {@link Function} to be used to generate a partition key for each item
 *
 * @return a new {@link java.util.Map} of all items by their partition key.
 */
public static <X, Y> Map<Y, Collection<X>> partition(final Iterable<X> items, final Function<X, Y> groupFunction){
    final int size = Iterate.estimateSize(items);
    final int groupSize = (size / 2) + 1;
    return Iterate.each(items).visit(new BinaryVisitor<X, Map<Y, Collection<X>>>()
    {
        public void visit(X item, Map<Y, Collection<X>> results)
        {
            Y key = groupFunction.apply(item);
            Collection<X> group = results.get(key);
            if (group == null) {
                group = new ArrayList<X>(groupSize);
                results.put(key, group);
            }

            group.add(item);
        }
    }, new HashMap<Y, Collection<X>>(size));
}","/**
 * Partitions {@code items} into groups based on the partition key generated by {@code groupFunction}.
 *
 * @param items         items to partition
 * @param groupFunction {@link Function} to be used to generate a partition key for each item
 *
 * @return a new {@link java.util.Map} of all items by their partition key.
 */
public static <X, Y> Map<Y, Collection<X>> partition(final Iterable<X> items, final Function<X, Y> groupFunction) 
{
    final Map<Y, Collection<X>> result = new HashMap<>();
    for (final X item : items)
    {
        final Y key = groupFunction.apply(item);
        Collection<X> group = result.get(key);
        if (group == null)
        {
            group = new ArrayList<>();
            result.put(key, group);
        }
        group.add(item);
    }
    return result;
}   ",1527,True
"/**
 * Finds the named method that accepts the supplied actual parameters.
 *
 * @return the found method, if it exists.
 *
 * @throws NoSuchMethodException if a method with the supplied {@code name} that accepts the supplied {@code
 *                               actualParams}.
 */
public static Method getMethod(Class clazz, String name, Object... actualParams) throws NoSuchMethodException{
    Class[] paramTypes = new Class[actualParams.length];
    for (int i = 0; i < actualParams.length; i++) {
        paramTypes[i] = getUnboxedClass(actualParams[i]);
    }

    return getMethod(clazz, name, paramTypes);
}","/**
 * Finds the named method that accepts the supplied actual parameters.
 *
 * @return the found method, if it exists.
 *
 * @throws NoSuchMethodException if a method with the supplied {@code name} that accepts the supplied {@code
 *                               actualParams}.
 */
public static Method getMethod(Class clazz, String name, Object... actualParams) throws NoSuchMethodException 
{
    Class[] formals = new Class[actualParams.length];
    for (int i = 0; i < actualParams.length; i++)
    {
        formals[i] = actualParams[i].getClass();
    }
    return getMethod(clazz, name, formals);
}   ",1528,False
"/**
 * Returns the first item in {@code items} for which {@code criteria#apply(item) == true}
 *
 * @param items    items to search
 * @param criteria {@link Condition} to evaluate for each item
 *
 * @return the first item for which {@code criteria#apply(item) == true}
 */
public static <X> X first(final Iterable<X> items, final Condition<? super X> criteria){
    for (X item : items) {
        if (criteria.eval(item)) {
            return item;
        }
    }

    return null;
}","/**
 * Returns the first item in {@code items} for which {@code criteria#apply(item) == true}
 *
 * @param items    items to search
 * @param criteria {@link Condition} to evaluate for each item
 *
 * @return the first item for which {@code criteria#apply(item) == true}
 */
public static <X> X first(final Iterable<X> items, final Condition<? super X> criteria) 
{
    for (final X item : items)
    {
        if (criteria.apply(item))
        {
            return item;
        }
    }
    return null;
}   ",1529,True
"/**
 * @param items    items from which to select
 * @param criteria items matching this {@link Condition} will be selected and returned in the resulting {@link
 *                 java.util.Collection}
 *
 * @return {@link Collection} of items from {@code items} matching {@code criteria}
 */
public static <X> Collection<X> select(final Iterable<X> items, final Condition<X> criteria){
    return Iterate.each(items).where(criteria)
            .visit(Iterate.collect(), new ArrayList<X>(Iterate.estimateSize(items)));
}","/**
 * @param items    items from which to select
 * @param criteria items matching this {@link Condition} will be selected and returned in the resulting {@link
 *                 java.util.Collection}
 *
 * @return {@link Collection} of items from {@code items} matching {@code criteria}
 */
public static <X> Collection<X> select(final Iterable<X> items, final Condition<X> criteria) 
{
    final Collection<X> selected = new ArrayList<X>();
    for (final X item : items)
    {
        if (criteria.matches(item))
        {
            selected.add(item);
        }
    }
    return selected;
}   ",1530,True
"/**
 * @param items    items to evaluate
 * @param criteria criteria to use to evaluate {@code items}
 *
 * @return true iff {@code criteria} evaluates to {@code true} for aLL items in {@code items}.
 */
public static <X> boolean all(final Iterable<X> items, final Condition<? super X> criteria){
    for (X item : items) {
        if (!criteria.eval(item)) {
            return false;
        }
    }

    return true;
}","/**
 * @param items    items to evaluate
 * @param criteria criteria to use to evaluate {@code items}
 *
 * @return true iff {@code criteria} evaluates to {@code true} for aLL items in {@code items}.
 */
public static <X> boolean all(final Iterable<X> items, final Condition<? super X> criteria) 
{
    for (final X item : items)
    {
        if (!criteria.evaluate(item))
        {
            return false;
        }
    }
    return true;
}   ",1531,True
"/**
 * @param random {@link Random} to use to generate random {@link Float}s
 *
 * @return a inexhaustable {@link Iterable} of random {@link Long}s using the supplied {@link Random}. See {@link
 *         java.util.Random#nextLong()} for numeric range of returned values.
 */
public static Iterate<Long> random(final Random random){
    return Iterate.each(new Iterable<Long>()
    {
        @Override
        public Iterator<Long> iterator()
        {
            return new AbstractIterator<Long>()
            {

                public boolean hasNext()
                {
                    return true;
                }

                @SuppressWarnings({""IteratorNextCanNotThrowNoSuchElementException""})
                public Long next()
                {
                    return random.nextLong();
                }
            };
        }
    });
}","/**
 * @param random {@link Random} to use to generate random {@link Float}s
 *
 * @return a inexhaustable {@link Iterable} of random {@link Long}s using the supplied {@link Random}. See {@link
 *         java.util.Random#nextLong()} for numeric range of returned values.
 */
public static Iterate<Long> random(final Random random) 
{
    return new Iterate<Long>()
    {
        @Override
        public Iterator<Long> iterator()
        {
            return new Iterator<Long>()
            {
                @Override
                public boolean hasNext()
                {
                    return true;
                }

                @Override
                public Long next()
                {
                    return random.nextLong();
                }
            };
        }
    };
}   ",1532,True
"/**
 * @return a {@link Function} that will parse a {@link String} into an {@link Integer}
 */
public static Function<String, Integer> parse(){
    return new Function<String, Integer>()
    {
        public Integer apply(String s)
        {
            return Integer.valueOf(s);
        }
    };
}","/**
 * @return a {@link Function} that will parse a {@link String} into an {@link Integer}
 */
public static Function<String, Integer> parse() 
{
    return Integer::parseInt;
}   ",1534,False
"/**
 * a {@link BinaryVisitor} that will app the value {@code x} to a supplied {@link Map} using the key generated by
 * apply {@code mapFunction} to {@code x}
 *
 * @param mapFunction {@link Function} that will be used to generate map keys for each item
 *
 * @return a {@link BinaryVisitor} that will app the value {@code x} to a supplied {@link Map} using the key
 *         generated by apply {@code mapFunction} to {@code x}
 */
public static <X, Y> BinaryVisitor<? super X, Map<Y, X>> map(final Function<X, Y> mapFunction){
    return new BinaryVisitor<X, Map<Y, X>>()
    {
        public void visit(X x, Map<Y, X> yxMap)
        {
            yxMap.put(mapFunction.apply(x), x);
        }
    };
}","/**
 * a {@link BinaryVisitor} that will app the value {@code x} to a supplied {@link Map} using the key generated by
 * apply {@code mapFunction} to {@code x}
 *
 * @param mapFunction {@link Function} that will be used to generate map keys for each item
 *
 * @return a {@link BinaryVisitor} that will app the value {@code x} to a supplied {@link Map} using the key
 *         generated by apply {@code mapFunction} to {@code x}
 */
public static <X, Y> BinaryVisitor<? super X, Map<Y, X>> map(final Function<X, Y> mapFunction) 
{
    return new BinaryVisitor<X, Map<Y, X>>()
    {
        @Override
        public void visit(X x, Map<Y, X> map)
        {
            map.put(mapFunction.apply(x), x);
        }
    };
}   ",1537,True
"/**
 * @return a {@link BinaryFunction} that returns the result of adding its two arguments, i.e. {@code x + y}
 */
public static BinaryFunction<Integer, Integer, Integer> sum(){
    return new BinaryFunction<Integer, Integer, Integer>()
    {
        public Integer apply(Integer i1, Integer i2)
        {
            return i1 + i2;
        }

        public String toString()
        {
            return ""+"";
        }
    };
}","/**
 * @return a {@link BinaryFunction} that returns the result of adding its two arguments, i.e. {@code x + y}
 */
public static BinaryFunction<Integer, Integer, Integer> sum() 
{
    return (x, y) -> x + y;
}   ",1538,True
"/**
 * a {@link BinaryVisitor} that will add the item {@code x} to the {@code Collection y}
 *
 * @return a {@link BinaryVisitor} that will add the item {@code x} to the {@code Collection y}
 */
public static <X> BinaryVisitor<X, Collection> collect(){
    return new BinaryVisitor<X, Collection>()
    {
        public void visit(X x, Collection collection)
        {
            //noinspection unchecked
            collection.add(x);
        }
    };
}","/**
 * a {@link BinaryVisitor} that will add the item {@code x} to the {@code Collection y}
 *
 * @return a {@link BinaryVisitor} that will add the item {@code x} to the {@code Collection y}
 */
public static <X> BinaryVisitor<X, Collection> collect() 
{
    return new BinaryVisitor<X, Collection>()
    {
        @Override
        public Collection visit(X x, Collection y)
        {
            y.add(x);
            return y;
        }
    };
}   ",1539,True
"/**
 * @param row
 * @param column
 * @param value
 */
public void set(final int row, final int column, final OctaveType value){
    if (row < 1) {
        throw new IllegalArgumentException(""row cannot be less or equal to 0"");
    }
    if (column < 1) {
        throw new IllegalArgumentException(""column cannot be less or equal to 0"");
    }

    // Expand if needed
    resize(Math.max(row, rows), Math.max(column, columns));

    // Finally, set value
    data.get(row - 1).set(column - 1, value);
}","/**
 * @param row
 * @param column
 * @param value
 */
public void set(final int row, final int column, final OctaveType value) 
{
    if (row >= 0 && row < this.rows && column >= 0 && column < this.columns)
    {
        this.octave[row][column] = value;
    }
    else
    {
        throw new IllegalArgumentException(""Invalid row or column index"");
    }
}   ",1542,False
"/**
 * @param type
 * @return The OctaveDataReader or null if it does not exist
 */
public static OctaveDataReader getOctaveDataReader(final String type){
    initIfNecessary();
    return readers.get(type);
}","/**
 * @param type
 * @return The OctaveDataReader or null if it does not exist
 */
public static OctaveDataReader getOctaveDataReader(final String type) 
{
    if (octaveDataReaderMap.containsKey(type))
    {
        return octaveDataReaderMap.get(type);
    }
    return null;
}   ",1544,True
"/**
 * Create empty cell
 */
public OctaveCell(){
    data = new ArrayList<ArrayList<OctaveType>>();
    rows = 0;
    columns = 0;
}","/**
 * Create empty cell
 */
public OctaveCell() 
{
    this(0);
}   ",1547,True
"/**
 * This reader will read from octaveReader until a single line equal() spacer is read, after that this reader will
 * return eof. When this reader is closed it will update the state of octave to NONE.
 * 
 * @param octaveReader
 * @param spacer
 */
public OctaveExecuteReader(final BufferedReader octaveReader, final String spacer){
    this.octaveReader = octaveReader;
    this.spacer = spacer;
}","/**
 * This reader will read from octaveReader until a single line equal() spacer is read, after that this reader will
 * return eof. When this reader is closed it will update the state of octave to NONE.
 * 
 * @param octaveReader
 * @param spacer
 */
public OctaveExecuteReader(final BufferedReader octaveReader, final String spacer) 
{
    this.octaveReader = octaveReader;
    this.spacer = spacer;
}   ",1555,True
"/**
 * Simple test to ensure that nothing has changed.  Of course
 * if the output should have changed, then this will have to be altered
 * to match.
 */
@Test
public void testSize() throws FileNotFoundException{
	Main.main(new String[]{
			Args.TEST_STYLE_ARG,
			""--route"",
			Args.TEST_RESOURCE_OSM + ""uk-test-1.osm.gz"",
			Args.TEST_RESOURCE_MP + ""test1.mp""
	});

	FileSystem fs = ImgFS.openFs(Args.DEF_MAP_ID + "".img"");
	assertNotNull(""file exists"", fs);

	List<DirectoryEntry> entries = fs.list();
	int count = 0;
	for (DirectoryEntry ent : entries) {
		String ext = ent.getExt();

		int size = ent.getSize();
		if (ext.equals(""RGN"")) {
			count++;
			assertThat(""RGN size"", size, new RangeMatcher(141999));
		} else if (ext.equals(""TRE"")) {
			count++;
			assertEquals(""TRE size"", 1329, size);
		} else if (ext.equals(""LBL"")) {
			count++;
			assertEquals(""LBL size"", 27693, size);
		} else if (ext.equals(""NET"")) {
			count++;
			assertEquals(""NET size"", 73850, size);
		} else if (ext.equals(""NOD"")) {
			count++;
			assertEquals(""NOD size"", 195187, size);
		}
	}
	assertTrue(""enough checks run"", count == 5);

	fs = ImgFS.openFs(Args.DEF_MAP_FILENAME2);
	assertNotNull(""file exists"", fs);

	entries = fs.list();
	count = 0;
	for (DirectoryEntry ent : entries) {
		String ext = ent.getExt();

		int size = ent.getSize();
		if (ext.equals(""RGN"")) {
			count++;
			assertThat(""RGN size"", size, new RangeMatcher(2934));
		} else if (ext.equals(""TRE"")) {
			count++;
			assertEquals(""TRE size"", 579, size);
		} else if (ext.equals(""LBL"")) {
			count++;
			assertEquals(""LBL size"", 984, size);
		} else if (ext.equals(""NET"")) {
			count++;
			assertEquals(""NET size"", 1280, size);
		} else if (ext.equals(""NOD"")) {
			count++;
			assertEquals(""NOD size"", 3114, size);
		}
	}
	assertTrue(""enough checks run"", count == 5);
}","/**
 * Simple test to ensure that nothing has changed.  Of course
 * if the output should have changed, then this will have to be altered
 * to match.
 */
@Test
public void testSize() throws FileNotFoundException 
{
    File file = new File(""src/test/resources/test.txt"");
    assertTrue(file.exists());
    assertEquals(3, file.length());
}   ",1560,True
"/**
 * This value is made from the third value, combined with the raw
 * map id values.
 */
private void calcFirst(){
	byte[] out = values[0];
	byte[] v3 = values[3];

	// First bytes are the low bytes of the mapId, with the corresponding
	// value from value[3] added.
	out[0] = (byte) (mapIdDigit(4) + v3[0]);
	out[1] = (byte) (mapIdDigit(5) + v3[1]);
	out[2] = (byte) (mapIdDigit(6) + v3[2]);
	out[3] = (byte) (mapIdDigit(7) + v3[3]);

	// Copies of v3
	out[4] = v3[4];
	out[5] = v3[5];
	out[6] = v3[6];

	// Always (?) one more.  The one likely comes from some other
	// part of the header, but we don't know if or where.
	out[7] = (byte) (v3[7] + 1);
}","/**
 * This value is made from the third value, combined with the raw
 * map id values.
 */
private void calcFirst() 
{
    first = (third << 8) | mapId;
}   ",1563,False
"/**
 * We draw points, lines and polygons separately.  They should be in
 * order from west to east of the generated map, starting in the bottom
 * left hand corner (SW).
 *
 * @param map Collector for the generated points etc.
 * @param startLat The S coord.
 * @param startLong The W coord.
 */
private void drawTestMap(MapCollector map, double startLat, double startLong){
	double lng = startLong;

	drawPoints(map, startLat, lng);

	lng += MAX_POINT_TYPE * ELEMENT_SPACING;
	drawLines(map, startLat, lng);

	lng += MAX_LINE_TYPE_X * ELEMENT_SPACING;
	drawPolygons(map, startLat, lng);
}","/**
 * We draw points, lines and polygons separately.  They should be in
 * order from west to east of the generated map, starting in the bottom
 * left hand corner (SW).
 *
 * @param map Collector for the generated points etc.
 * @param startLat The S coord.
 * @param startLong The W coord.
 */
private void drawTestMap(MapCollector map, double startLat, double startLong) 
{
    // Draw a line from the start point to the end point.
    map.addLine(0, 0, 1, 1);

    // Draw a polygon from the start point to the end point.
    map.addPolygon(0, 0, 1, 1, 1, 0);

    // Draw a point at the start point.
    map.addPoint(0, 0);
}   ",1564,True
"/**
 * search for the first matching name pattern and set the element name
 * to it.
 *
 * If the element name is already set, then nothing is done.
 *
 * @param el The element on which the name may be set.
 */
public void perform(Element el){
	if (el.getName() != null)
		return;
	
	for (ValueBuilder vb : names) {
		String s = vb.build(el, el);
		if (s != null) {
			el.setName(s);
			break;
		}
	}
}","/**
 * search for the first matching name pattern and set the element name
 * to it.
 *
 * If the element name is already set, then nothing is done.
 *
 * @param el The element on which the name may be set.
 */
public void perform(Element el) 
{
    if (el.getName() == null)
    {
        String name = findName();
        if (name != null)
        {
            el.setName(name);
        }
    }
}   ",1565,True
"/**
 * The offset of this label in the LBL file.  The first byte of this file
 * is zero and an offset of zero means that the label has a zero length/is
 * empty.
 *
 * @return The offset within the LBL file of this string.
 */
public int getOffset(){
	if (text == null || text.isEmpty())
		return 0;
	else
		return offset;
}","/**
 * The offset of this label in the LBL file.  The first byte of this file
 * is zero and an offset of zero means that the label has a zero length/is
 * empty.
 *
 * @return The offset within the LBL file of this string.
 */
public int getOffset() 
{
    return offset;
}   ",1567,True
"/**
* Returns the list of values associated with the given key.
*
* @param o the key to get the values for.
* @return a list of values for the given keys or the empty list of no such
*         value exist.
*/
public List<V> get(K key){
	List<V> result = super.get(key);
	return result == null ? emptyList : result;
}","/**
* Returns the list of values associated with the given key.
*
* @param o the key to get the values for.
* @return a list of values for the given keys or the empty list of no such
*         value exist.
*/


public List<V> get(K key) 
{
    List<V> values = map.get(key);
    if (values == null)
    {
        return Collections.emptyList();
    }
    return Collections.unmodifiableList(values);
}   ",1571,True
"/**
 * This is made of the hex digits of the map id in a given order
 * translated according to a given table of values.
 */
private void calcThird(){
	byte[] out = values[2];
	for (int i = 0; i < 8; i++) {
		int n = mapIdDigit(i);
		out[(i ^ 1)] = mapIdCodeTable[n];
	}
}","/**
 * This is made of the hex digits of the map id in a given order
 * translated according to a given table of values.
 */
private void calcThird() 
{
    int[] third = new int[mapId.length()];
    for (int i = 0; i < mapId.length(); i++) {
        third[i] = mapId.charAt(i) - '0';
        if (third[i] > 9) {
            third[i] -= 7;
        }
    }
    this.third = third;
}   ",1574,True
"/**
 * Add an offset to all previously calculated values.
 */
private void addOffset(){
	// To get the offset value we add up all the even nibbles of the map
	// number and transform via a table.
	int n = mapIdDigit(1) + mapIdDigit(3) + mapIdDigit(5) + mapIdDigit(7);

	int offset = offsetMap[n & 0xf];
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 8; j++) {
			values[i][j] += offset;
		}
	}
}","/**
 * Add an offset to all previously calculated values.
 */
private void addOffset() 
{
    for (int i = 0; i < values.length; i++)
    {
        values[i] += offset;
    }
}   ",1575,True
"/**
 * Write this label to the given img file.
 *
 * @param writer The LBL file to write to.
 * @param textEncoder The encoder to use for this text.  Converts the
 * unicode string representation to the correct byte stream for the file.
 * This depends on encoding format, character set etc.
 */
public void write(ImgFileWriter writer, CharacterEncoder textEncoder){
	EncodedText encText = textEncoder.encodeText(text);
	assert encText != null;

	if (encText.getLength() > 0)
		writer.put(encText.getCtext(), 0, encText.getLength());
}","/**
 * Write this label to the given img file.
 *
 * @param writer The LBL file to write to.
 * @param textEncoder The encoder to use for this text.  Converts the
 * unicode string representation to the correct byte stream for the file.
 * This depends on encoding format, character set etc.
 */

public void write(ImgFileWriter writer, CharacterEncoder textEncoder) 
{
    try
    {
        writer.writeLabelInfo(this, textEncoder);
    }
    catch (IOException e)
    {
        throw new RuntimeException(e);
    }
}   ",1577,True
"/**
 * Put the map city index.  This is the index within the individual map
 * and not the global city index used in mdr11.
 */
private void putLocalCityIndex(ImgFileWriter writer, int cityIndex){
	if (localCitySize == 2) // 3 probably not possible in actual maps.
		writer.putChar((char) cityIndex);
	else
		writer.put((byte) cityIndex);
}","/**
 * Put the map city index.  This is the index within the individual map
 * and not the global city index used in mdr11.
 */

private void putLocalCityIndex(ImgFileWriter writer, int cityIndex) 
{
    try
    {
        writer.writeShort(cityIndex);
    }
    catch (IOException e)
    {
        e.printStackTrace();
    }
}   ",1578,True
"/**
 * Base size of 8, plus enough bytes to represent the map number
 * and the city number.
 * @return The size of a record in this section.
 */
public int getItemSize(){
	PointerSizes sizes = getSizes();
	return sizes.getMapSize() + localCitySize + 5 + sizes.getStrOffSize();
}","/**
 * Base size of 8, plus enough bytes to represent the map number
 * and the city number.
 * @return The size of a record in this section.
 */
public int getItemSize() 
{
    return 8 + 4 + 4;
}   ",1579,False
"/**
 * Returns the attribute value by namespace and attribute name.
 */
public String getAttributeValue(NamespaceDefinition namespace, String attributeName){
	if (getNamespaceDefinition().equals(namespace)) {
		return getAttributeValue(attributeName);
	} else {
		return getAttributeValue(namespace, namespace.getForeignAttribute(attributeName));
	}
}","/**
 * Returns the attribute value by namespace and attribute name.
 */
public String getAttributeValue(NamespaceDefinition namespace, String attributeName) 
{
    if (namespace != null)
    {
        return namespace.getAttributeValue(attributeName);
    }
    return null;
}   ",1580,True
"/**
 * Checks if an adapter to clazz is available in this context. Returns this
 * adapter or null if none available.
 */
@SuppressWarnings(""unchecked"")
public static <A> A adaptTo(Class<A> clazz){
	Context ctx = context.get();
	if (ctx == null) {
		return null;
	}
	for (IAdaptable adapter : ctx.adapters) {
		Object obj = adapter.getAdapter(clazz);
		if (obj != null) {
			return (A) obj;
		}
	}
	return null;
}","/**
 * Checks if an adapter to clazz is available in this context. Returns this
 * adapter or null if none available.
 */
@SuppressWarnings(""unchecked"")
public static <A> A adaptTo(Class<A> clazz) 
{
    if (clazz.isInstance(this))
    {
        return (A) this;
    }
    return null;
}   ",1581,True
"/**
 * Checks whether the extension of the filename is one of those specified.
 * <p>
 * This method obtains the extension as the textual part of the filename
 * after the last dot. There must be no directory separator after the dot.
 * The extension check is case-sensitive on all platforms.
 * 
 * @param filename
 *            the filename to query, null returns false
 * @param extensions
 *            the extensions to check for, null checks for no extension
 * @return true if the filename is one of the extensions
 */
public static boolean isExtension(String filename, Collection extensions){
	if (filename == null) {
		return false;
	}
	if (extensions == null || extensions.isEmpty()) {
		return (indexOfExtension(filename) == -1);
	}
	String fileExt = getExtension(filename);
	for (Iterator it = extensions.iterator(); it.hasNext();) {
		if (fileExt.equals(it.next())) {
			return true;
		}
	}
	return false;
}","/**
 * Checks whether the extension of the filename is one of those specified.
 * <p>
 * This method obtains the extension as the textual part of the filename
 * after the last dot. There must be no directory separator after the dot.
 * The extension check is case-sensitive on all platforms.
 * 
 * @param filename
 *            the filename to query, null returns false
 * @param extensions
 *            the extensions to check for, null checks for no extension
 * @return true if the filename is one of the extensions
 */
public static boolean isExtension(String filename, Collection extensions) 
{
    if (filename == null)
    {
        return false;
    }
    if (extensions == null)
    {
        return true;
    }
    String fileExt = getExtension(filename);
    for (Iterator it = extensions.iterator(); it.hasNext();)
    {
        String extension = (String) it.next();
        if (fileExt.equals(extension))
        {
            return true;
        }
    }
    return false;
}   ",1582,True
"/**
 * Returns the index of the last directory separator character.
 * <p>
 * This method will handle a file in either Unix or Windows format. The
 * position of the last forward or backslash is returned.
 * <p>
 * The output will be the same irrespective of the machine that the code is
 * running on.
 * 
 * @param filename
 *            the filename to find the last path separator in, null returns
 *            -1
 * @return the index of the last separator character, or -1 if there is no
 *         such character
 */
public static int indexOfLastSeparator(String filename){
	if (filename == null) {
		return -1;
	}
	int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR);
	int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR);
	return Math.max(lastUnixPos, lastWindowsPos);
}","/**
 * Returns the index of the last directory separator character.
 * <p>
 * This method will handle a file in either Unix or Windows format. The
 * position of the last forward or backslash is returned.
 * <p>
 * The output will be the same irrespective of the machine that the code is
 * running on.
 * 
 * @param filename
 *            the filename to find the last path separator in, null returns
 *            -1
 * @return the index of the last separator character, or -1 if there is no
 *         such character
 */
public static int indexOfLastSeparator(String filename) 
{
    if (filename == null || filename.length() == 0)
    {
        return -1;
    }
    int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR);
    int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR);
    return Math.max(lastUnixPos, lastWindowsPos);
}   ",1585,True
"/**
 * Gets the name minus the path from a full filename.
 * <p>
 * This method will handle a file in either Unix or Windows format. The text
 * after the last forward or backslash is returned.
 * 
 * <pre>
 * a/b/c.txt --&gt; c.txt
 * a.txt     --&gt; a.txt
 * a/b/c     --&gt; c
 * a/b/c/    --&gt; &quot;&quot;
 * </pre>
 * <p>
 * The output will be the same irrespective of the machine that the code is
 * running on.
 * 
 * @param filename
 *            the filename to query, null returns null
 * @return the name of the file without the path, or an empty string if none
 *         exists
 */
public static String getName(String filename){
	if (filename == null) {
		return null;
	}
	int index = indexOfLastSeparator(filename);
	return filename.substring(index + 1);
}","/**
 * Gets the name minus the path from a full filename.
 * <p>
 * This method will handle a file in either Unix or Windows format. The text
 * after the last forward or backslash is returned.
 * 
 * <pre>
 * a/b/c.txt --&gt; c.txt
 * a.txt     --&gt; a.txt
 * a/b/c     --&gt; c
 * a/b/c/    --&gt; &quot;&quot;
 * </pre>
 * <p>
 * The output will be the same irrespective of the machine that the code is
 * running on.
 * 
 * @param filename
 *            the filename to query, null returns null
 * @return the name of the file without the path, or an empty string if none
 *         exists
 */
public static String getName(String filename) 
{
    if (filename == null)
    {
        return null;
    }
    int index = indexOfLastSeparator(filename);
    return filename.substring(index + 1);
}   ",1587,True
"// -----------------------------------------------------------------------
/**
 * Checks whether the extension of the filename is that specified.
 * <p>
 * This method obtains the extension as the textual part of the filename
 * after the last dot. There must be no directory separator after the dot.
 * The extension check is case-sensitive on all platforms.
 * 
 * @param filename
 *            the filename to query, null returns false
 * @param extension
 *            the extension to check for, null or empty checks for no
 *            extension
 * @return true if the filename has the specified extension
 */
public static boolean isExtension(String filename, String extension){
	if (filename == null) {
		return false;
	}
	if (extension == null || extension.length() == 0) {
		return (indexOfExtension(filename) == -1);
	}
	String fileExt = getExtension(filename);
	return fileExt.equals(extension);
}","// -----------------------------------------------------------------------
/**
 * Checks whether the extension of the filename is that specified.
 * <p>
 * This method obtains the extension as the textual part of the filename
 * after the last dot. There must be no directory separator after the dot.
 * The extension check is case-sensitive on all platforms.
 * 
 * @param filename
 *            the filename to query, null returns false
 * @param extension
 *            the extension to check for, null or empty checks for no
 *            extension
 * @return true if the filename has the specified extension
 */
public static boolean isExtension(String filename, String extension) 
{
    if (filename == null)
    {
        return false;
    }
    if (extension == null || extension.length() == 0)
    {
        return indexOfExtension(filename) == -1;
    }
    String fileExt = getExtension(filename);
    return fileExt.equals(extension);
}   ",1588,True
"/**
 * Converts all separators to the Windows separator of backslash.
 * 
 * @param path
 *            the path to be changed, null ignored
 * @return the updated path
 */
public static String separatorsToWindows(String path){
	if (path == null || path.indexOf(UNIX_SEPARATOR) == -1) {
		return path;
	}
	return path.replace(UNIX_SEPARATOR, WINDOWS_SEPARATOR);
}","/**
 * Converts all separators to the Windows separator of backslash.
 * 
 * @param path
 *            the path to be changed, null ignored
 * @return the updated path
 */
public static String separatorsToWindows(String path) 
{
    if (path == null || path.indexOf(WINDOWS_SEPARATOR) == -1)
    {
        return path;
    }
    return path.replace(SEPARATOR, WINDOWS_SEPARATOR);
}   ",1591,True
"/**
 * Returns the index of the last extension separator character, which is a
 * dot.
 * <p>
 * This method also checks that there is no directory separator after the
 * last dot. To do this it uses {@link #indexOfLastSeparator(String)} which
 * will handle a file in either Unix or Windows format.
 * <p>
 * The output will be the same irrespective of the machine that the code is
 * running on.
 * 
 * @param filename
 *            the filename to find the last path separator in, null returns
 *            -1
 * @return the index of the last separator character, or -1 if there is no
 *         such character
 */
public static int indexOfExtension(String filename){
	if (filename == null) {
		return -1;
	}
	int extensionPos = filename.lastIndexOf(EXTENSION_SEPARATOR);
	int lastSeparator = indexOfLastSeparator(filename);
	return (lastSeparator > extensionPos ? -1 : extensionPos);
}","/**
 * Returns the index of the last extension separator character, which is a
 * dot.
 * <p>
 * This method also checks that there is no directory separator after the
 * last dot. To do this it uses {@link #indexOfLastSeparator(String)} which
 * will handle a file in either Unix or Windows format.
 * <p>
 * The output will be the same irrespective of the machine that the code is
 * running on.
 * 
 * @param filename
 *            the filename to find the last path separator in, null returns
 *            -1
 * @return the index of the last separator character, or -1 if there is no
 *         such character
 */
public static int indexOfExtension(String filename) 
{
    if (filename == null)
    {
        return -1;
    }
    int lastUnixPos = filename.lastIndexOf(UNIX_SEPARATOR);
    int lastWindowsPos = filename.lastIndexOf(WINDOWS_SEPARATOR);
    int lastSeparator = Math.max(lastUnixPos, lastWindowsPos);
    int index = indexOfLastSeparator(filename);
    return lastSeparator > index ? -1 : index;
}   ",1593,True
"/**
 * Converts all separators to the system separator.
 * 
 * @param path
 *            the path to be changed, null ignored
 * @return the updated path
 */
public static String separatorsToSystem(String path){
	if (path == null) {
		return null;
	}
	if (isSystemWindows()) {
		return separatorsToWindows(path);
	} else {
		return separatorsToUnix(path);
	}
}","/**
 * Converts all separators to the system separator.
 * 
 * @param path
 *            the path to be changed, null ignored
 * @return the updated path
 */

public static String separatorsToSystem(String path) 
{
    if (path == null)
    {
        return null;
    }
    if (File.separatorChar == '\\')
    {
        // Replace forward slashes on Windows
        return path.replace('/', File.separatorChar);
    }
    else
    {
        // Replace backslashes on Unix
        return path.replace('\\', File.separatorChar);
    }
}   ",1594,True
"/**
 * Returns a list of all definitions from the given namespace which
 * specified set for this tag.
 */
public Collection<IAttributeDefinition> getAttributes(INamespaceDefinition namespace){
	Map<IAttributeDefinition, String> attributes = attributeMap.get(namespace);
	if (attributes != null) {
		return attributes.keySet();
	} else {
		return Collections.emptyList();
	}
}","/**
 * Returns a list of all definitions from the given namespace which
 * specified set for this tag.
 */
public Collection<IAttributeDefinition> getAttributes(INamespaceDefinition namespace) 
{
    if (namespace == null)
    {
        return Collections.emptySet();
    }
    return attributes.get(namespace);
}   ",1598,True
"/**
 * Convert ARGB pixels to a ByteBuffer containing RGBA pixels.  The GL_RGBA format is
 * a default format used in OpenGL 1.0, but requires that we move the Alpha byte for
 * each pixel in the image (slow).  Would be better to use OpenGL 1.2 GL_BGRA format
 * and leave pixels in the ARGB format (faster) but this pixel format caused problems
 * when creating mipmaps (see note above).
 * .<P>
 * If flipVertically is true, pixels will be flipped vertically (for OpenGL coord system).
 * @return ByteBuffer
 */
public static ByteBuffer convertImagePixelsRGBA(int[] jpixels, int imgw, int imgh, boolean flipVertically){
    byte[] bytes;     // will hold pixels as RGBA bytes
    if (flipVertically) {
        jpixels = flipPixels(jpixels, imgw, imgh); // flip Y axis
    }
    bytes = convertARGBtoRGBA(jpixels);
    return allocBytes(bytes);  // convert to ByteBuffer and return
}","/**
 * Convert ARGB pixels to a ByteBuffer containing RGBA pixels.  The GL_RGBA format is
 * a default format used in OpenGL 1.0, but requires that we move the Alpha byte for
 * each pixel in the image (slow).  Would be better to use OpenGL 1.2 GL_BGRA format
 * and leave pixels in the ARGB format (faster) but this pixel format caused problems
 * when creating mipmaps (see note above).
 * .<P>
 * If flipVertically is true, pixels will be flipped vertically (for OpenGL coord system).
 * @return ByteBuffer
 */
public static ByteBuffer convertImagePixelsRGBA(int[] jpixels, int imgw, int imgh, boolean flipVertically) 
{
    int[] pixels = jpixels;
    if (flipVertically)
    {
        pixels = flipImagePixelsVertically(jpixels, imgw, imgh);
    }

    ByteBuffer bb = ByteBuffer.allocateDirect(imgw * imgh * 4);
    for (int y = 0; y < imgh; y++)
    {
        for (int x = 0; x < imgw; x++)
        {
            int pixel = pixels[imgw * y + x];
            bb.put((byte)((pixel >> 16) & 0xFF)); // R
            bb.put((byte)((pixel >> 8) & 0xFF)); // G
            bb.put((byte)((pixel) & 0xFF)); // B
            bb.put((byte)((pixel >> 24) & 0xFF)); // A
        }
    }
    bb.position(0);
    return bb;
}   ",1600,True
"/**
 * Same function as in GLApp.java.  Allocates a ByteBuffer to hold the given
 * array of bytes.
 *
 * @param bytearray
 * @return  ByteBuffer containing the contents of the byte array
 */
public static ByteBuffer allocBytes(byte[] bytearray){
    ByteBuffer bb = ByteBuffer.allocateDirect(bytearray.length).order(ByteOrder.nativeOrder());
    bb.put(bytearray).flip();
    return bb;
}","/**
 * Same function as in GLApp.java.  Allocates a ByteBuffer to hold the given
 * array of bytes.
 *
 * @param bytearray
 * @return  ByteBuffer containing the contents of the byte array
 */
public static ByteBuffer allocBytes(byte[] bytearray) 
{
    ByteBuffer bb = ByteBuffer.allocateDirect(bytearray.length);
    bb.put(bytearray);
    bb.flip();
    return bb;
}   ",1602,True
"/**
 * Create GLImage from pixels passed in a ByteBuffer.  This is a non-standard approach
 * that may give unpredictable results.
 * @param pixels
 * @param w
 * @param h
 */
public GLImage(ByteBuffer gl_pixels, int w, int h){
  if (gl_pixels != null) {
        this.pixelBuffer = gl_pixels;
     this.pixels = null;
     this.h = h;
     this.w = w;
  }
}","/**
 * Create GLImage from pixels passed in a ByteBuffer.  This is a non-standard approach
 * that may give unpredictable results.
 * @param pixels
 * @param w
 * @param h
 */
public GLImage(ByteBuffer gl_pixels, int w, int h) 
{
    this.width = w;
    this.height = h;
    this.pixels = gl_pixels;
}   ",1603,True
"/**
 * Save an array of ARGB pixels to a PNG file.
 * If flipY is true, flip the pixels on the Y axis before saving.
 */
public static void savePixelsToPNG(int[] pixels, int width, int height, String imageFilename, boolean flipY){
   if (pixels != null && imageFilename != null) {
      if (flipY) {
         // flip the pixels vertically (opengl has 0,0 at lower left, java is upper left)
         pixels = GLImage.flipPixels(pixels, width, height);
      }
      try {
         // Create a BufferedImage with the RGB pixels then save as PNG
         BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
         image.setRGB(0, 0, width, height, pixels, 0, width);
         javax.imageio.ImageIO.write(image, ""png"", new File(imageFilename));
      }
      catch (Exception e) {
         System.err.println(""GLImage.savePixelsToPNG("" +imageFilename+ ""): exception "" + e);
      }
   }
}","/**
 * Save an array of ARGB pixels to a PNG file.
 * If flipY is true, flip the pixels on the Y axis before saving.
 */





public static void savePixelsToPNG(int[] pixels, int width, int height, String imageFilename, boolean flipY) 
{
    try
    {
        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
        image.setRGB(0, 0, width, height, pixels, 0, width);

        if (flipY)
        {
            AffineTransform at = new AffineTransform();
            at.concatenate(AffineTransform.getScaleInstance(1, -1));
            at.concatenate(AffineTransform.getTranslateInstance(0, -height));
            AffineTransformOp op = new AffineTransformOp(at, AffineTransformOp.TYPE_NEAREST_NEIGHBOR);
            image = op.filter(image, null);
        }

        ImageIO.write(image, ""png"", new File(imageFilename));
    }
    catch (IOException e)
    {
        e.printStackTrace();
    }
}   ",1605,True
"/**
 * Load pixels from an image file.  Flip Y axis.  Convert to RGBA format.
 * @param imgName
 */
public GLImage(String imgName){
  BufferedImage img = loadJavaImage(imgName);
    if (makeGLImage(img,true,false)) {
     System.out.println(""GLImage(String): loaded "" + imgName + "", width="" + w + "" height="" + h);
  }
}","/**
 * Load pixels from an image file.  Flip Y axis.  Convert to RGBA format.
 * @param imgName
 */
public GLImage(String imgName) 
{
    this(imgName, false, false);
}   ",1611,True
"/**
 * Find a power of two equal to or greater than the given value.
 * Ie. getPowerOfTwoBiggerThan(800) will return 1024.
 * <P>
 * @see makeTextureForScreen()
 * @param dimension
 * @return a power of two equal to or bigger than the given dimension
 */
public static int getPowerOfTwoBiggerThan(int n){
    if (n < 0)
        return 0;
    --n;
    n |= n >> 1;
    n |= n >> 2;
    n |= n >> 4;
    n |= n >> 8;
    n |= n >> 16;
    return n+1;
}","/**
 * Find a power of two equal to or greater than the given value.
 * Ie. getPowerOfTwoBiggerThan(800) will return 1024.
 * <P>
 * @see makeTextureForScreen()
 * @param dimension
 * @return a power of two equal to or bigger than the given dimension
 */
public static int getPowerOfTwoBiggerThan(int n) 
{
    int i = 1;
    while (i < n)
        i <<= 1;
    return i;
}   ",1616,False
"/**
 * Copy ARGB pixels to a ByteBuffer without changing the ARGB byte order. If used to make a
 * texture, the pixel format is GL12.GL_BGRA.  With this format we can leave pixels in ARGB
 * order (faster), but unfortunately I had problems building mipmaps in BGRA format
 * (GLU.gluBuild2DMipmaps() did not recognize GL_UNSIGNED_INT_8_8_8_8 and
 * GL_UNSIGNED_INT_8_8_8_8_REV types so screwed up the BGRA/ARGB byte order on Mac).
 *
 * @return ByteBuffer
 */
public static ByteBuffer convertImagePixelsARGB(int[] jpixels, int imgw, int imgh, boolean flipVertically){
  // flip Y axis
    if (flipVertically) {
        jpixels = flipPixels(jpixels, imgw, imgh); // flip Y axis
    }
    // put int pixels into Byte Buffer
  ByteBuffer bb = allocBytes(jpixels.length * 4);  // 4 bytes per pixel
  bb.asIntBuffer().put(jpixels);
    return bb;
}","/**
 * Copy ARGB pixels to a ByteBuffer without changing the ARGB byte order. If used to make a
 * texture, the pixel format is GL12.GL_BGRA.  With this format we can leave pixels in ARGB
 * order (faster), but unfortunately I had problems building mipmaps in BGRA format
 * (GLU.gluBuild2DMipmaps() did not recognize GL_UNSIGNED_INT_8_8_8_8 and
 * GL_UNSIGNED_INT_8_8_8_8_REV types so screwed up the BGRA/ARGB byte order on Mac).
 *
 * @return ByteBuffer
 */
public static ByteBuffer convertImagePixelsARGB(int[] jpixels, int imgw, int imgh, boolean flipVertically) 
{
    int[] pixels = jpixels;
    if (flipVertically) {
        pixels = flipPixelsVertically(jpixels, imgw, imgh);
    }
    int size = pixels.length * 4;
    ByteBuffer bb = ByteBuffer.allocateDirect(size);
    bb.order(ByteOrder.nativeOrder());
    bb.asIntBuffer().put(pixels);
    bb.position(0);
    return bb;
}   ",1617,True
"/**
 * Create GLImage from image file bytes (the contents of a jpg, gif or png file).
 * @param pixels
 * @param w
 * @param h
 */
public GLImage(byte[] bytes, boolean flipYaxis, boolean convertPow2){
    BufferedImage img = makeBufferedImage(bytes);
    if (makeGLImage(img,flipYaxis,convertPow2)) {
     System.out.println(""GLImage(byte[],bool,bool): loaded image from bytes["" + bytes.length + ""]"");
  }
  else {
     System.err.println(""GLImage(byte[],bool,bool): could not create Image from bytes["" + bytes.length + ""]"");
  }
}","/**
 * Create GLImage from image file bytes (the contents of a jpg, gif or png file).
 * @param pixels
 * @param w
 * @param h
 */
public GLImage(byte[] bytes, boolean flipYaxis, boolean convertPow2) 
{
    this.flipYaxis = flipYaxis;
    this.convertPow2 = convertPow2;
    this.bytes = bytes;
    this.w = -1;
    this.h = -1;
    this.comp = -1;
    this.format = -1;
    this.type = -1;
    this.texID = XX;
    this.textureObjectHandle = -1;
    this.mipMapCount = 1;
}   ",1618,True
"/**
 * Load a BufferedImage from the given image file name.  File can be in the local filesytem,
 * in the applet folder, or in a jar.
 */
public BufferedImage loadJavaImage(String imgName){
   BufferedImage tmpi = null;
   try {
      tmpi = ImageIO.read(getInputStream(imgName));
   }
   catch (Exception e) {
      System.err.println(""GLImage.loadJavaImage() exception: FAILED TO LOAD IMAGE "" + e);
   }
   return tmpi;
}","/**
 * Load a BufferedImage from the given image file name.  File can be in the local filesytem,
 * in the applet folder, or in a jar.
 */


public BufferedImage loadJavaImage(String imgName) 
{
    URL url = getClass().getResource(imgName);
    if (url == null)
        return null;
    try {
        return ImageIO.read(url);
    } catch (IOException e) {
        return null;
    }
}   ",1619,True
"/** Cancel's the devices/services search. */
public void cancelSearch(){
	cancelDeviceSearch();
	cancelServiceSearch();
}","/** Cancel's the devices/services search. */
public void cancelSearch() 
{
    if (search != null)
    {
        search.cancel();
        search = null;
    }
}   ",1623,True
"/*	private void shutdown() {
		stopImageCollector();
		if (namesThread != null) {
			namesThread.stop();
			namesThread = null;
		}
		if (dictReader != null) {
			dictReader.shutdown();
			dictReader = null;
		}
		if (tileReader != null) {
			tileReader.shutdown();
			tileReader = null;
		}

		if (locationProducer != null){
			locationProducer.close();
		}

	}*/
protected void sizeChanged(int w, int h){
		if (imageCollector != null){
			logger.info(""Size of Canvas changed to "" + w + ""|"" + h);
			stopImageCollector();
			try {
				startImageCollector();
				imageCollector.resume();
				imageCollector.newDataReady();
			} catch (Exception e) {
				logger.exception(""Could not reinitialise Image Collector after size change"", e);
			}
			/**
			 * Recalculate the projection, as it may depends on the size of the screen
			 */
			updatePosition();
		}
	}","/*	private void shutdown() {
		stopImageCollector();
		if (namesThread != null) {
			namesThread.stop();
			namesThread = null;
		}
		if (dictReader != null) {
			dictReader.shutdown();
			dictReader = null;
		}
		if (tileReader != null) {
			tileReader.shutdown();
			tileReader = null;
		}

		if (locationProducer != null){
			locationProducer.close();
		}

	}*/
protected void sizeChanged(int w, int h) 
{
    super.sizeChanged(w, h);
    if (imageCollector != null) {
        imageCollector.sizeChanged(w, h);
    }
}	",1624,True
"/**
 * Show an alert window with the given title that cannot be dismissed by
 * the user, i.e. a modal progress dialog. This Alert Window also has a progressbar indicating the progress
 * 
 * @param title The title of the alert
 * @param progEndValue the maximum value for the progressbar
 */
protected void showProgressDisplay(String title, int progEndValue){
	int progrMode = 0;
	//catch illegal argument
	if (progEndValue < 1){
		progEndValue = Gauge.INDEFINITE;
		//Set mode for progressbar
		progrMode = Gauge.CONTINUOUS_RUNNING;
	}
	
	if (progressDisplay == null) {
		progressDisplay = new Alert(title);
		progressDisplay.setCommandListener(this);
		progressDisplay.setTimeout(Alert.FOREVER);
		//create a progressbar that gives an indication about how many waypoints have already been exported
		progressbar = new Gauge(null, false, progEndValue, progrMode);
		progressDisplay.setIndicator(progressbar);
	} else {
		progressDisplay.setTitle(title);
		progressbar.setMaxValue(progEndValue);
		progressbar.setValue(progrMode);
		progressDisplay.setIndicator(progressbar);
	}
	// Empty string buffer for alert text.
	sbProgress = new StringBuffer();
	// At least on Sony Ericsson phones, the alert won't be shown
	// until it contains some text, so let's put in a dummy. 
	progressDisplay.setString("" "");		
	try {
		GpsMid.getInstance().show(progressDisplay);
		progressCloseable = false;
	} catch (IllegalArgumentException iae) {
		/**
		 * Nokia S40 phones seem to throw an exception
		 * if one tries to set an Alert displayable when
		 * the current displayable is an alert too.
		 * 
		 * Not much we can do about this, other than just
		 * ignore the exception and not display the new
		 * alert. 
		 */
		logger.info(""Could not display progress alert, "" + iae.getMessage());
	}
}","/**
 * Show an alert window with the given title that cannot be dismissed by
 * the user, i.e. a modal progress dialog. This Alert Window also has a progressbar indicating the progress
 * 
 * @param title The title of the alert
 * @param progEndValue the maximum value for the progressbar
 */

protected void showProgressDisplay(String title, int progEndValue) 
{
    if (mProgressDialog == null)
    {
        mProgressDialog = new ProgressDialog(this);
        mProgressDialog.setTitle(title);
        mProgressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
        mProgressDialog.setMax(progEndValue);
        mProgressDialog.setCancelable(false);
        mProgressDialog.setCanceledOnTouchOutside(false);
        mProgressDialog.show();
    }
}   ",1626,False
"/* Add text to the progress alert window.
 * @param text Text to be added
 */
protected void addProgressText(String text){
	if (sbProgress != null && progressDisplay != null) {
		sbProgress.append(text);
		progressDisplay.setString(sbProgress.toString());
	}
}","/* Add text to the progress alert window.
 * @param text Text to be added
 */
protected void addProgressText(String text) 
{
    if (progressAlert != null)
    {
        progressAlert.addText(text);
    }
}   ",1629,True
"/**
 * This is the callback routine if RouteCalculation is ready
 * @param route
 */
public void setRoute(Vector route){
	synchronized(this) {
		this.route = route;
		if (route!=null) {
			if (ri==null) {
				ri = new RouteInstructions(this);
			}
			ri.newRoute(route, target);
			oldRecalculationTime = System.currentTimeMillis();
			RouteInstructions.resetOffRoute(route, center);
		}
		routeCalc=false;
		routeEngine=null;
	}
	try {
		if ((Configuration.isStopAllWhileRouteing())&&(imageCollector == null)){
			startImageCollector();
			// imageCollector thread starts up suspended,
			// so we need to resume it
			imageCollector.resume();
		}
		repaint();
	} catch (Exception e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
}","/**
 * This is the callback routine if RouteCalculation is ready
 * @param route
 */
public void setRoute(Vector route) 
{
    this.route = route;
    if (route != null)
    {
        this.routeSize = route.size();
    }
    else
    {
        this.routeSize = 0;
    }
}   ",1630,False
"/**
 * Draws the position square, the movement line and the center cross.
 * 
 * @param g Graphics context for drawing
 */
public void showMovement(Graphics g){
	g.setColor(0, 0, 0);
	int centerX = getWidth() / 2;
	int centerY = getHeight() / 2;
	int posX, posY;
	if (!gpsRecenter) {
		IntPoint p1 = new IntPoint(0,0);				
		pc.getP().forward((float)(pos.latitude/360.0*2*Math.PI), (float)(pos.longitude/360.0*2*Math.PI),p1);
		posX = p1.getX();
		posY = p1.getY();		
	} else {
		posX = centerX;
		posY = centerY;
	}
	float radc = (float) (course * Math.PI / 180d);
	int px = posX + (int) (Math.sin(radc) * 20);
	int py = posY - (int) (Math.cos(radc) * 20);
	g.drawRect(posX - 2, posY - 2, 4, 4);
	g.drawLine(posX, posY, px, py);
	g.drawLine(centerX - 2, centerY - 2, centerX + 2, centerY + 2);
	g.drawLine(centerX - 2, centerY + 2, centerX + 2, centerY - 2);
}","/**
 * Draws the position square, the movement line and the center cross.
 * 
 * @param g Graphics context for drawing
 */
public void showMovement(Graphics g) 
{
    if (positionSquare != null)
    {
        g.setColor(Color.RED);
        g.drawPolygon(positionSquare);
    }

    if (movementLine != null)
    {
        g.setColor(Color.BLUE);
        g.drawPolygon(movementLine);
    }

    if (centerCross != null)
    {
        g.setColor(Color.GREEN);
        g.drawPolygon(centerCross);
    }
}   ",1634,True
"/**
 * Try and determine the maximum available memory. As some phones have
 * dynamic growing heaps, we need to try and cause a out of memory error, as
 * that indicates the maximum size to which the heap can grow
 * 
 * @return maximum heap size
 */
private long determinPhoneMaxMemory(){
	long maxMem = Runtime.getRuntime().totalMemory();
	// int [][] buf = new int[2048][];
	// try {
	// for (int i = 0; i < 2048; i++) {
	// buf[i] = new int[16000];
	// }
	// } catch (OutOfMemoryError oome) {
	// //l.info(""Hit out of memory while determining maximum heap size"");
	// maxMem = Runtime.getRuntime().totalMemory();
	// } finally {
	// for (int i = 0; i < 2048; i++) {
	// buf[i] = null;
	// }
	// }
	// System.gc();
	log.info(""Maximum phone memory: "" + maxMem);
	return maxMem;
}","/**
 * Try and determine the maximum available memory. As some phones have
 * dynamic growing heaps, we need to try and cause a out of memory error, as
 * that indicates the maximum size to which the heap can grow
 * 
 * @return maximum heap size
 */
private long determinPhoneMaxMemory() 
{
    long maxMemory = Runtime.getRuntime().maxMemory();
    long heapSize = Runtime.getRuntime().totalMemory();
    long freeSize = Runtime.getRuntime().freeMemory();
    long used = heapSize - freeSize;
    long maxHeapSize = maxMemory - used;
    return maxHeapSize;
}   ",1636,True
"/**
 * Show next screen in the sequence of data screens
 * (tacho, trip, satellites).
 * @param currentScreen Data screen currently shown, use the DATASCREEN_XXX
 *    constants from this class. Use DATASCREEN_NONE if none of them
 *    is on screen i.e. the first one should be shown.
 */
public void showNextDataScreen(int currentScreen){
	switch (currentScreen)
	{
		case DATASCREEN_TACHO:
			// Tacho is followed by Trip.
			if (guiTrip == null) {
				guiTrip = new GuiTrip(this);
			}
			if (guiTrip != null) {
				guiTrip.show();
			}
			break;
		case DATASCREEN_TRIP:
			// TODO: Trip is followed by Satellites.
			this.show();
			break;
		case DATASCREEN_SATS:
			// After satellites, go back to map.
			this.show();
			break;
		case DATASCREEN_NONE:
		default:
			// Tacho is first data screen
			if (guiTacho == null) {
				guiTacho = new GuiTacho(this);
			}
			if (guiTacho != null) {
				guiTacho.show();
			}
			break;
	}
}","/**
 * Show next screen in the sequence of data screens
 * (tacho, trip, satellites).
 * @param currentScreen Data screen currently shown, use the DATASCREEN_XXX
 *    constants from this class. Use DATASCREEN_NONE if none of them
 *    is on screen i.e. the first one should be shown.
 */
public void showNextDataScreen(int currentScreen) 
{
    if (currentScreen == DATASCREEN_NONE)
    {
        showScreen(DATASCREEN_TACHO);
    }
    else if (currentScreen == DATASCREEN_TACHO)
    {
        showScreen(DATASCREEN_TRIP);
    }
    else if (currentScreen == DATASCREEN_TRIP)
    {
        showScreen(DATASCREEN_SATELLITES);
    }
    else if (currentScreen == DATASCREEN_SATELLITES)
    {
        showScreen(DATASCREEN_TACHO);
    }
}   ",1637,True
"/**
 * initializes class members
 */
private void initComponents(){
    if (Constants.isWindows)
        fsv = FileSystemView.getFileSystemView();
    
    initRoot();
    setCellRenderer(new FileTreeCellRenderer());
    setEditable(false);
}","/**
 * initializes class members
 */

private void initComponents() 
{
    // initialize class members
    this.setLayout(new BorderLayout());
    this.add(this.createNorthPanel(), BorderLayout.NORTH);
    this.add(this.createCenterPanel(), BorderLayout.CENTER);
    this.add(this.createSouthPanel(), BorderLayout.SOUTH);
}   ",1640,False
"/**
 * returns a renderered node for the tree
 * @param tree the tree to render the node for
 * @param value the value of the node
 * @param selected if the node is selected
 * @param expanded if it's expanded
 * @param leaf if its a leaf or not
 * @param row the row number
 * @param hasFocus if it has focus
 * @return a renderered node for the tree
 */
public Component getTreeCellRendererComponent(JTree tree, Object value, boolean selected, boolean expanded, boolean leaf, int row, boolean hasFocus){
    super.getTreeCellRendererComponent(tree, value, selected, expanded, leaf, row, hasFocus);
    
    Object userObject = ((DefaultMutableTreeNode)value).getUserObject();
    if (userObject instanceof FileTreeNode)
    {
        FileTreeNode fileTreeNode = (FileTreeNode)userObject;
        
        if (!Constants.isWindows)
        {
            try { setIcon(fileChooser.getIcon(fileTreeNode.file)); }
            catch (Exception e) { e.printStackTrace(); }
        }
        else
        {
            try { setIcon(fsv.getSystemIcon(fileTreeNode.file)); }
            catch (Exception e) { e.printStackTrace(); }
        }
    }

    return this;
}","/**
 * returns a renderered node for the tree
 * @param tree the tree to render the node for
 * @param value the value of the node
 * @param selected if the node is selected
 * @param expanded if it's expanded
 * @param leaf if its a leaf or not
 * @param row the row number
 * @param hasFocus if it has focus
 * @return a renderered node for the tree
 */


public Component getTreeCellRendererComponent(JTree tree, Object value, boolean selected, boolean expanded, boolean leaf, int row, boolean hasFocus) 
{
    DefaultMutableTreeNode node = (DefaultMutableTreeNode)value;
    Object userObject = node.getUserObject();
    if(userObject instanceof String)
    {
        return super.getTreeCellRendererComponent(tree, value, selected, expanded, leaf, row, hasFocus);
    }
    else if(userObject instanceof Icon)
    {
        return new JLabel((Icon)userObject);
    }
    else
    {
        return super.getTreeCellRendererComponent(tree, value, selected, expanded, leaf, row, hasFocus);
    }
}   ",1641,True
"/**
 * returns the selected file in the tree. If there are multiple selections in the
 * tree, then it will return the <code>File</code> associated with the value
 * returned from <code>getSelectionPath</code>. You can enable/disable mutliple
 * selections by changing the mode of the <code>TreeSelectionModel</code>.
 * @return the selected file in the tree
 */
public File getSelectedFile(){
    TreePath treePath = getSelectionPath();
    if (treePath == null)
        return null;
    
    DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode)treePath.getLastPathComponent();
    FileTreeNode fileTreeNode = (FileTreeNode)treeNode.getUserObject();
    return fileTreeNode.file;
}","/**
 * returns the selected file in the tree. If there are multiple selections in the
 * tree, then it will return the <code>File</code> associated with the value
 * returned from <code>getSelectionPath</code>. You can enable/disable mutliple
 * selections by changing the mode of the <code>TreeSelectionModel</code>.
 * @return the selected file in the tree
 */




public File getSelectedFile() 
{
    TreePath selectionPath = tree.getSelectionPath();
    if (selectionPath != null)
    {
        DefaultMutableTreeNode node = (DefaultMutableTreeNode) selectionPath.getLastPathComponent();
        if (node.getUserObject() instanceof File)
        {
            return (File) node.getUserObject();
        }
    }
    return null;
}   ",1642,True
"/**
 * Expands the tree to the <code>File</code> specified by the argument, and selects
 * it as well. If the <code>currFile</code> does not exist or is null, calling this
 * method will have no effect.
 * @param currFile The file or directory to expand the tree to and select.
 */
public void setCurrentFile(File currFile){
    if (currFile == null || !currFile.exists())
        return;
    
    String path = currFile.getPath();
    String [] pathParts = null;
    if (Constants.isWindows)
        pathParts = path.split(""\\\\"");
    else
        pathParts = path.split(File.separator);
    
    if (Constants.isWindows)
    {
        int childCount = rootNode.getChildCount();
        DefaultMutableTreeNode myComputer = null;
        for (int i=0; i<childCount; i++)
        {
            FileTreeNode fileTreeNode = 
                    (FileTreeNode)((DefaultMutableTreeNode)rootNode.getChildAt(i)).getUserObject();
            if (fileTreeNode.file.getPath().equals(FileTreeNode.WINDOWS_MYCOMPUTER))
            {
                myComputer = (DefaultMutableTreeNode)rootNode.getChildAt(i);
                TreePath treePath = new TreePath(myComputer.getPath());
                expandPath(treePath);
                break;
            }
        }
        
        DefaultMutableTreeNode currNode = myComputer;
        for (String part:pathParts)
        {
            childCount = currNode.getChildCount();
            for (int i=0; i<childCount; i++)
            {
                DefaultMutableTreeNode childNode = (DefaultMutableTreeNode)currNode.getChildAt(i);
                FileTreeNode fileTreeNode = (FileTreeNode)childNode.getUserObject();
                String pathName = fileTreeNode.file.getName();
                if (pathName.length() == 0)
                    pathName = fileTreeNode.file.getPath().substring(0, 2);
                if (pathName.equals(part))
                {
                    TreePath treePath = new TreePath(childNode.getPath());
                    expandPath(treePath);
                    selectionModel.setSelectionPath(treePath);
                    currNode = childNode;
                    break;
                }
            }
        }
        
    }
    else
    {
        DefaultMutableTreeNode currNode = rootNode;
        for (String part:pathParts)
        {
            int childCount = currNode.getChildCount();
            for (int i=0; i<childCount; i++)
            {
                DefaultMutableTreeNode childNode = (DefaultMutableTreeNode)currNode.getChildAt(i);
                FileTreeNode fileTreeNode = (FileTreeNode)childNode.getUserObject();
                if (fileTreeNode.file.getName().equals(part))
                {
                    TreePath treePath = new TreePath(childNode.getPath());
                    expandPath(treePath);
                    selectionModel.setSelectionPath(treePath);
                    currNode = childNode;
                    break;
                }
            }
        }
    }
}","/**
 * Expands the tree to the <code>File</code> specified by the argument, and selects
 * it as well. If the <code>currFile</code> does not exist or is null, calling this
 * method will have no effect.
 * @param currFile The file or directory to expand the tree to and select.
 */

public void setCurrentFile(File currFile) 
{
    if (currFile != null)
    {
        TreePath path = new TreePath(treeModel.getPathToRoot(currFile));
        tree.setSelectionPath(path);
        tree.scrollPathToVisible(path);
    }
}   ",1643,False
"/** Creates a new instance of FileTree */
public FileTree(){
    super(new DefaultTreeModel(new DefaultMutableTreeNode(""root"")));
    fileTreeModel = (DefaultTreeModel)treeModel;
    showHiddenFiles = false;
    showFiles = true;
    navigateOSXApps = false;
    
    initComponents();
    initListeners();
}","/** Creates a new instance of FileTree */
public FileTree() 
{
    super();
    try
    {
        jbInit();
    }
    catch(Exception e)
    {
        e.printStackTrace();
    }
}   ",1644,True
"/**
 * returns the representation of this <code>File</code> best suited for use in
 * the <code>FileTree</code>.
 * @return the representation of this <code>File</code> as a <code>String</code>
 */
public String toString(){
    String name = file.getName();
    if (!Constants.isWindows)
        return name;

    if (name.length() == 0)
        return file.getPath();

    if (Constants.isVista)
    {
        if (name.equals(WINDOWS_MYCOMPUTER))
            return ""Computer"";
        if (name.equals(WINDOWSVISTA_NETWORK))
            return ""Network"";
        return name;
    }

    // the Windows XP and 2K case
    if (name.equals(WINDOWS_MYCOMPUTER))
        return ""My Computer"";
    if (name.equals(WINDOWS_MYNETWORKPLACES))
        return ""My Network Places"";

    return name;
}","/**
 * returns the representation of this <code>File</code> best suited for use in
 * the <code>FileTree</code>.
 * @return the representation of this <code>File</code> as a <code>String</code>
 */
public String toString() 
{
    return getName();
}   ",1645,False
"/**
 * constructor for the action to delete a file or directory
 * @param treePath the treepath of the node to act on
 */
public DeleteFileAction(TreePath treePath){
    this.treePath = treePath;
    
    if (Constants.isOSX)
        putValue(Action.NAME, ""Move to Trash"");
    else
    {
        putValue(Action.NAME, ""Delete"");
        putValue(Action.MNEMONIC_KEY, KeyEvent.VK_D);
    }
    
    DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode)treePath.getLastPathComponent();
    fileTreeNode = (FileTreeNode)treeNode.getUserObject();
    if (!fileTreeNode.file.canWrite())
        setEnabled(false);
}","/**
 * constructor for the action to delete a file or directory
 * @param treePath the treepath of the node to act on
 */
public DeleteFileAction(TreePath treePath) 
{
    super(treePath);
}   ",1646,False
"/**
 * Toggle the showing of files in the tree (as opposed to just directories)
 * @param showFiles <code>true</code> shows files in the tree. <code>false</code> does not.
 */
public void setShowFiles(boolean showFiles){
    if (this.showFiles != showFiles)
    {
        this.showFiles = showFiles;
        initRoot();
    }
}","/**
 * Toggle the showing of files in the tree (as opposed to just directories)
 * @param showFiles <code>true</code> shows files in the tree. <code>false</code> does not.
 */
public void setShowFiles(boolean showFiles) 
{
    this.showFiles = showFiles;
    if (tree != null)
    {
        tree.setShowFiles(showFiles);
    }
}   ",1647,True
"/**
 * Creates a new instance of FileTreeNode
 * @param file The <code>File</code> that will be represented by this class.
 */
public FileTreeNode(File file){
    if (file == null)
        throw new IllegalArgumentException(""Null file not allowed"");

    this.file = file;
}","/**
 * Creates a new instance of FileTreeNode
 * @param file The <code>File</code> that will be represented by this class.
 */
public FileTreeNode(File file) 
{
    this.file = file;
    this.children = new ArrayList<FileTreeNode>();
    this.parent = null;
}   ",1648,True
"/**
 * Listens for right-clicks on the tree.
 * @param e contains information about the mouse click event
 */
public void mousePressed(MouseEvent e){
    if (e.getButton() == MouseEvent.BUTTON3)
        rightClick(e.getX(), e.getY());
}","/**
 * Listens for right-clicks on the tree.
 * @param e contains information about the mouse click event
 */
public void mousePressed(MouseEvent e) 
{
    if (e.isPopupTrigger())
    {
        int row = tree.getRowForLocation(e.getX(), e.getY());
        if (row != -1)
        {
            tree.setSelectionRow(row);
            popupMenu.show(e.getComponent(), e.getX(), e.getY());
        }
    }
}   ",1649,False
"/**
 * Allows or disallows the showing of hidden files and directories in the tree.
 * @param showHiddenFiles <code>true</code> shows hidden files. <code>false</code> does not.
 */
public void setShowHiddenFiles(boolean showHiddenFiles){
    if (showHiddenFiles != this.showHiddenFiles)
    {
        this.showHiddenFiles = showHiddenFiles;
        initRoot();
    }
}","/**
 * Allows or disallows the showing of hidden files and directories in the tree.
 * @param showHiddenFiles <code>true</code> shows hidden files. <code>false</code> does not.
 */
public void setShowHiddenFiles(boolean showHiddenFiles) 
{
    if (this.showHiddenFiles != showHiddenFiles)
    {
        this.showHiddenFiles = showHiddenFiles;
        firePropertyChange(""showHiddenFiles"", !showHiddenFiles, showHiddenFiles);
    }
}   ",1651,True
"/**
 * called whenever a node is expanded
 * @param node the node to expand
 */
private void populateSubTree(DefaultMutableTreeNode node){
    Object userObject = node.getUserObject();
    if (userObject instanceof FileTreeNode)
    {
        FileTreeNode fileTreeNode = (FileTreeNode)userObject;
        File []files = fileTreeNode.file.listFiles();
        
        // Windows displays directories before regular files, so we're going
        // to sort the list of files such that directories appear first
        if (Constants.isWindows)
        {
            Arrays.sort(files, new Comparator<File>() {
                public int compare(File f1, File f2) {
                    boolean f1IsDir = f1.isDirectory();
                    boolean f2IsDir = f2.isDirectory();
                    
                    if (f1IsDir == f2IsDir)
                        return f1.compareTo(f2);
                    if (f1IsDir && !f2IsDir)
                        return -1;
                    
                    // here we assume that f1 is a file, and f2 is a directory
                    return 1;
                }
            });
        }
        else
            Arrays.sort(files);
        
        for (File file:files)
        {
            if (file.isFile() && !showFiles)
                continue;
            
            if (!showHiddenFiles && file.isHidden())
                continue;
            
            FileTreeNode subFile = new FileTreeNode(file);
            DefaultMutableTreeNode subNode = new DefaultMutableTreeNode(subFile);
            if (file.isDirectory())
            {
                if (!Constants.isOSX || navigateOSXApps || !file.getName().endsWith("".app""))
                    subNode.add(new DefaultMutableTreeNode(""Fake""));
            }
            node.add(subNode);
        }
    }
}","/**
 * called whenever a node is expanded
 * @param node the node to expand
 */
private void populateSubTree(DefaultMutableTreeNode node) 
{
    DefaultMutableTreeNode subNode;
    String[] subNodes = node.getUserObject().toString().split("","");
    for (int i = 0; i < subNodes.length; i++)
    {
        subNode = new DefaultMutableTreeNode(subNodes[i]);
        node.add(subNode);
    }
}   ",1654,False
"/**
 * 
 * @param x the x coordinate of the mouse when it was pressed
 * @param y the y coordinate of the mouse when it was pressed
 */
private void rightClick(int x, int y){
    TreePath treePath = fileTree.getPathForLocation(x, y);
    if (treePath == null)
        return;
    
    if (!fileTree.isDeleteEnabled())
        return;
    
    JPopupMenu popup = new JPopupMenu();
    
    popup.add(new DeleteFileAction(treePath));
    popup.show(fileTree, x, y);
}","/**
 * 
 * @param x the x coordinate of the mouse when it was pressed
 * @param y the y coordinate of the mouse when it was pressed
 */
private void rightClick(int x, int y) 
{
    int row = y / 20;
    int col = x / 20;
    if (row < 0 || row >= 20 || col < 0 || col >= 20)
    {
        return;
    }
    if (board[row][col] == 0)
    {
        board[row][col] = 1;
    }
    else
    {
        board[row][col] = 0;
    }
    repaint();
}   ",1655,False
"/**
 * the action called when the user wants to delete a file or directory
 * @param e information about the event that caused this method to be called
 */
public void actionPerformed(ActionEvent e){
    int choice = JOptionPane.showConfirmDialog(fileTree.getRootPane(),
            ""Are you sure you want to delete '"" + fileTreeNode.file.getName()+""'?"",
            ""Confirm delete"",
            JOptionPane.YES_NO_OPTION,
            JOptionPane.QUESTION_MESSAGE);
    if (choice == 1)
        return; // they selected no
    
    boolean success = false;
    if (fileTreeNode.file.isDirectory())
        success = deleteDirectory(fileTreeNode.file);
    else
        success = fileTreeNode.file.delete();
    
    if (success)
    {
        fileTree.getFileTreeModel().removeNodeFromParent(
                (DefaultMutableTreeNode)treePath.getLastPathComponent());
    }
        
}","/**
 * the action called when the user wants to delete a file or directory
 * @param e information about the event that caused this method to be called
 */
public void actionPerformed(ActionEvent e) 
{
    // get the selected file or directory
    File file = (File)tree.getLastSelectedPathComponent();
    if (file == null)
    {
        return;
    }

    // check if the selected item is a file or a directory
    if (file.isFile())
    {
        // delete the file
        file.delete();
    }
    else if (file.isDirectory())
    {
        // delete the directory and its contents
        deleteDirectory(file);
    }

    // refresh the tree
    treeModel.reload();
}   ",1656,False
"/**
 * sets up the listeners for the tree
 */
private void initListeners(){
    addTreeExpansionListener(new TreeExpansionListener() {
        public void treeCollapsed(TreeExpansionEvent event) {
        }
        public void treeExpanded(TreeExpansionEvent event) {
            TreePath path = event.getPath();
            DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode) path.getLastPathComponent();
            treeNode.removeAllChildren();
            populateSubTree(treeNode);
            fileTreeModel.nodeStructureChanged(treeNode);
        }
    });
    
    FileTreeListener ftl = new FileTreeListener(this);
    addMouseListener(ftl);
}","/**
 * sets up the listeners for the tree
 */

private void initListeners() 
{
    tree.addMouseListener(new MouseAdapter()
    {
        public void mousePressed(MouseEvent e)
        {
            if (e.getButton() == MouseEvent.BUTTON3)
            {
                showPopup(e.getX(), e.getY());
            }
        }
    });
}   ",1659,False
"/**
 * Create a new distributed lookup service using the license key
 *
 * @param options  Resevered for future use
 * @param licenseKey license key provided by Maxmind to access distributed service
 */
public LookupService(int options,String licenseKey) throws IOException{
    this.licenseKey = licenseKey;
    dnsService = 1;
    init();
}","/**
 * Create a new distributed lookup service using the license key
 *
 * @param options  Resevered for future use
 * @param licenseKey license key provided by Maxmind to access distributed service
 */
public LookupService(int options,String licenseKey) throws IOException 
{
    this.options = options;
    this.licenseKey = licenseKey;
    this.reader = new DatabaseReader.Builder(database).withLicenseKey(licenseKey).build();
}   ",1660,True
"/**
* Returns the country the IP address is in.
*
* @param ipAddress the IP address in long format.
* @return the country the IP address is from.
*/
public Country getCountry(long ipAddress){
   if (file == null && (dboptions & GEOIP_MEMORY_CACHE) == 0) {
       throw new IllegalStateException(""Database has been closed."");
   }
   int ret = seekCountry(ipAddress) - COUNTRY_BEGIN;
   if (ret == 0) {
       return UNKNOWN_COUNTRY;
   }
   else {
       return new Country(countryCode[ret], countryName[ret]);
   }
    }","/**
* Returns the country the IP address is in.
*
* @param ipAddress the IP address in long format.
* @return the country the IP address is from.
*/
public Country getCountry(long ipAddress) 
{
    long ip = ipAddress;
    Country country = null;
    for (int i = 0; i < countries.size(); i++)
    {
        if (countries.get(i).contains(ip))
        {
            country = countries.get(i);
            break;
        }
    }
    return country;
}   ",1661,True
"/**
 * Returns information about the database.
 *
 * @return database info.
 */
public synchronized DatabaseInfo getDatabaseInfo(){
    if (databaseInfo != null) {
        return databaseInfo;
    }
    try {
        _check_mtime();
        boolean hasStructureInfo = false;
        byte [] delim = new byte[3];
        // Advance to part of file where database info is stored.
        file.seek(file.length() - 3);
        for (int i=0; i<STRUCTURE_INFO_MAX_SIZE; i++) {
            int read = file.read( delim );
            if( read==3 && (delim[0]&0xFF)==255 && (delim[1]&0xFF) == 255 && (delim[2]&0xFF)==255 ){
                    hasStructureInfo = true;
                    break;
            }
            file.seek(file.getFilePointer() - 4);

        }
        if (hasStructureInfo) {
                file.seek(file.getFilePointer() - 6);
        }
        else {
            // No structure info, must be pre Sep 2002 database, go back to end.
            file.seek(file.length() - 3);
        }
        // Find the database info string.
        for (int i=0; i<DATABASE_INFO_MAX_SIZE; i++) {
            file.readFully(delim);
                if (delim[0]==0 && delim[1]==0 && delim[2]==0) {
                    byte[] dbInfo = new byte[i];
                file.readFully(dbInfo);
                    // Create the database info object using the string.
                    this.databaseInfo = new DatabaseInfo(new String(dbInfo));
                    return databaseInfo;
                }
                file.seek(file.getFilePointer() -4);
            }
        }
    catch (Exception e) {
        e.printStackTrace();
    }
    return new DatabaseInfo("""");
}","/**
 * Returns information about the database.
 *
 * @return database info.
 */
public synchronized DatabaseInfo getDatabaseInfo() 
{
    if (databaseInfo == null)
    {
        databaseInfo = new DatabaseInfo();
    }
    return databaseInfo;
}   ",1662,False
"/**
 * Returns the date of the database.
 *
 * @return the date of the database.
 */
public Date getDate(){
    for (int i=0; i<info.length()-9; i++) {
        if (Character.isWhitespace(info.charAt(i))) {
            String dateString = info.substring(i+1, i+9);
            try {
                synchronized (formatter) {
                    return formatter.parse(dateString);
                }
            }
            catch (ParseException pe) {  }
            break;
        }
    }
    return null;
}","/**
 * Returns the date of the database.
 *
 * @return the date of the database.
 */
public Date getDate() 
{
    return date;
}   ",1665,False
"/**
 * Create a new distributed lookup service using the license key
 *
 * @param databaseFile the database file.
 * @param licenseKey license key provided by Maxmind to access distributed service
 */
public LookupService(File databaseFile,String licenseKey) throws IOException{
    this(databaseFile);
    this.licenseKey = licenseKey;
    dnsService = 1;
}","/**
 * Create a new distributed lookup service using the license key
 *
 * @param databaseFile the database file.
 * @param licenseKey license key provided by Maxmind to access distributed service
 */
public LookupService(File databaseFile,String licenseKey) throws IOException 
{
    this.databaseFile = databaseFile;
    this.licenseKey = licenseKey;
    this.lookupService = new LookupService(databaseFile, LookupService.GEOIP_MEMORY_CACHE | LookupService.GEOIP_CHECK_CACHE);
}   ",1667,True
"/**
 * Reads meta-data from the database file.
 *
 * @throws java.io.IOException if an error occurs reading from the database file.
 */
private void init() throws IOException{
    int i, j;
    byte [] delim = new byte[3];
    byte [] buf = new byte[SEGMENT_RECORD_LENGTH];

	if (file == null) {
      return;
	}
	if ((dboptions & GEOIP_CHECK_CACHE) != 0) {
        mtime = databaseFile.lastModified();
	}
	file.seek(file.length() - 3);
    for (i = 0; i < STRUCTURE_INFO_MAX_SIZE; i++) {
        file.readFully(delim);
        if (delim[0] == -1 && delim[1] == -1 && delim[2] == -1) {
            databaseType = file.readByte();
            if (databaseType >= 106) {
                // Backward compatibility with databases from April 2003 and earlier
                databaseType -= 105;
            }
            // Determine the database type.
            if (databaseType == DatabaseInfo.REGION_EDITION_REV0) {
                databaseSegments = new int[1];
                databaseSegments[0] = STATE_BEGIN_REV0;
                recordLength = STANDARD_RECORD_LENGTH;
            }else if (databaseType == DatabaseInfo.REGION_EDITION_REV1){
                databaseSegments = new int[1];
                databaseSegments[0] = STATE_BEGIN_REV1;
                recordLength = STANDARD_RECORD_LENGTH;
		}
            else if (databaseType == DatabaseInfo.CITY_EDITION_REV0 ||
			 databaseType == DatabaseInfo.CITY_EDITION_REV1 ||
			 databaseType == DatabaseInfo.ORG_EDITION ||
			 databaseType == DatabaseInfo.ISP_EDITION ||
			 databaseType == DatabaseInfo.ASNUM_EDITION) {
			databaseSegments = new int[1];
			databaseSegments[0] = 0;
			if (databaseType == DatabaseInfo.CITY_EDITION_REV0 ||
			    databaseType == DatabaseInfo.CITY_EDITION_REV1 ||
			    databaseType == DatabaseInfo.ASNUM_EDITION) {
			    recordLength = STANDARD_RECORD_LENGTH;
			}
			else {
			    recordLength = ORG_RECORD_LENGTH;
			}
			file.readFully(buf);
			for (j = 0; j < SEGMENT_RECORD_LENGTH; j++) {
			    databaseSegments[0] += (unsignedByteToInt(buf[j]) << (j * 8));
			}
		    }
            break;
        }
        else {
            file.seek(file.getFilePointer() - 4);
        }
    }
    if ((databaseType == DatabaseInfo.COUNTRY_EDITION) ||
        (databaseType == DatabaseInfo.COUNTRY_EDITION_V6) ||
	    (databaseType == DatabaseInfo.PROXY_EDITION) ||
	    (databaseType == DatabaseInfo.NETSPEED_EDITION)) {
        databaseSegments = new int[1];
        databaseSegments[0] = COUNTRY_BEGIN;
        recordLength = STANDARD_RECORD_LENGTH;
    }
    if ((dboptions & GEOIP_MEMORY_CACHE) == 1) {
	    int l = (int) file.length();
	    dbbuffer = new byte[l];
	    file.seek(0);
	    file.readFully(dbbuffer,0,l);
	    databaseInfo = this.getDatabaseInfo();
	    file.close();
	}
    if ((dboptions & GEOIP_INDEX_CACHE) != 0) {
      int l = databaseSegments[0] * recordLength * 2;
      index_cache = new byte[l];
      if (index_cache != null){
        file.seek(0);
        file.readFully(index_cache,0,l);     
      }          
    } else {
      index_cache = null;
    }
 }","/**
 * Reads meta-data from the database file.
 *
 * @throws java.io.IOException if an error occurs reading from the database file.
 */
private void init() throws IOException 
{
    // Read the database file
    RandomAccessFile raf = new RandomAccessFile(file, ""r"");
    try
    {
        // Read the version
        version = raf.readInt();

        // Read the number of entries
        int numEntries = raf.readInt();

        // Read the entries
        for (int i = 0; i < numEntries; i++)
        {
            int key = raf.readInt();
            int value = raf.readInt();
            entries.put(key, value);
        }
    }
    finally
    {
        raf.close();
    }
}   ",1668,False
"/**
 * Create a new lookup service using the specified database file.
 *
 * @param databaseFile the database file.
 * @param options database flags to use when opening the database
 * GEOIP_STANDARD read database from disk
 * GEOIP_MEMORY_CACHE cache the database in RAM and read it from RAM
 * @throws java.io.IOException if an error occured creating the lookup service
 *      from the database file.
 */
public LookupService(File databaseFile, int options) throws IOException{
    this.databaseFile = databaseFile;
	this.file = new RandomAccessFile(databaseFile, ""r"");
	dboptions = options;
	init();
}","/**
 * Create a new lookup service using the specified database file.
 *
 * @param databaseFile the database file.
 * @param options database flags to use when opening the database
 * GEOIP_STANDARD read database from disk
 * GEOIP_MEMORY_CACHE cache the database in RAM and read it from RAM
 * @throws java.io.IOException if an error occured creating the lookup service
 *      from the database file.
 */
public LookupService(File databaseFile, int options) throws IOException 
{
    this.databaseFile = databaseFile;
    this.options = options;
    this.lookupService = new LookupService(databaseFile, options);
}   ",1670,True
"/**
 * Returns the country the IP address is in.
 *
 * @param ipAddress String version of an IPv6 address, i.e. ""::127.0.0.1""
 * @return the country the IP address is from.
 */
public Country getCountryV6(String ipAddress){
	InetAddress addr;
	try {
	    addr = Inet6Address.getByName(ipAddress);
	}
	catch (UnknownHostException e) {
        return UNKNOWN_COUNTRY;
	}
	return getCountryV6(addr);
}","/**
 * Returns the country the IP address is in.
 *
 * @param ipAddress String version of an IPv6 address, i.e. ""::127.0.0.1""
 * @return the country the IP address is from.
 */

public Country getCountryV6(String ipAddress) 
{
    try
    {
        InetAddress address = InetAddress.getByName(ipAddress);
        return getCountryV6(address);
    }
    catch (UnknownHostException e)
    {
        return null;
    }
}   ",1671,True
"/////city test
@Test
public void testCityXml() throws IOException{
    Response response = get(""/cities/212.101.97.206.xml"");
    assertEquals(200, response.status);
    assertEquals(""OK"", response.message);
    assertEquals(""application/xml"", response.contentType);
    assertTrue(""X-Server is present"", response.headers.get(""X-Server"").size() > 0);
    assertTrue(""Contains </city> end tag"", response.body.contains(""</city>""));
}","/////city test
@Test
public void testCityXml() throws IOException 
{
    String xml = ""<city><name>San Francisco</name><state>CA</state></city>"";
    City city = new City();
    city.setName(""San Francisco"");
    city.setState(""CA"");
    String result = city.toXml();
    assertEquals(xml, result);
}   ",1673,False
"/**
 * Closes the lookup service.
 */
public void close(){
	try {
	    if (file != null){
		file.close();
	    }
        file = null;
    }
    catch (Exception e) { }
}","/**
 * Closes the lookup service.
 */
public void close() 
{
    if (this.lookupService != null)
    {
        this.lookupService.close();
        this.lookupService = null;
    }
}   ",1676,True
"/**
 * Finds the country index value given an IPv6 address.
 *
 * @param addr the ip address to find in long format.
 * @return the country index.
 */
private synchronized int seekCountryV6(InetAddress addr){
    byte [] v6vec = addr.getAddress();
	byte [] buf = new byte[2 * MAX_RECORD_LENGTH];
	int [] x = new int[2];
    int offset = 0;
    _check_mtime();
    for (int depth = 127; depth >= 0; depth--) {
        if ((dboptions & GEOIP_MEMORY_CACHE) == 1) {
		//read from memory
            for (int i = 0;i < 2 * MAX_RECORD_LENGTH;i++) {
		    buf[i] = dbbuffer[(2 * recordLength * offset)+i];
		}
        } else if ((dboptions & GEOIP_INDEX_CACHE) != 0) {
            //read from index cache
            for (int i = 0;i < 2 * MAX_RECORD_LENGTH;i++) {
		    buf[i] = index_cache[(2 * recordLength * offset)+i];
		}            
        } else {
		//read from disk 
		try {
                file.seek(2 * recordLength * offset);
                file.readFully(buf);
            }
            catch (IOException e) {
                System.out.println(""IO Exception"");
            }
        }
        for (int i = 0; i<2; i++) {
            x[i] = 0;
            for (int j = 0; j<recordLength; j++) {
                int y = buf[i*recordLength+j];
                if (y < 0) {
                    y+= 256;
                }
                x[i] += (y << (j * 8));
            }
        }

        int bnum = 127 - depth;
        int idx = bnum >> 3;
        int b_mask = 1 << ( bnum & 7 ^ 7 );
        if ((v6vec[idx] & b_mask) > 0) {
            if (x[1] >= databaseSegments[0]) {
                last_netmask = 128 - depth;
                return x[1];
            }
            offset = x[1];
        }
        else {
            if (x[0] >= databaseSegments[0]) {
                last_netmask = 128 - depth;
                return x[0];
            }
            offset = x[0];
	    }
	}

    // shouldn't reach here
    System.err.println(""Error seeking country while seeking "" + addr.getHostAddress() );
    return 0;
}","/**
 * Finds the country index value given an IPv6 address.
 *
 * @param addr the ip address to find in long format.
 * @return the country index.
 */
private synchronized int seekCountryV6(InetAddress addr) 
{
    long ip = ByteBuffer.wrap(addr.getAddress()).getLong();
    return seekCountryV6(ip);
}   ",1677,True
"/**
 * Returns the country the IP address is in.
 *
 * @param addr the IP address as Inet6Address.
 * @return the country the IP address is from.
 */
public Country getCountryV6(InetAddress addr){
    if (file == null && (dboptions & GEOIP_MEMORY_CACHE) == 0) {
        throw new IllegalStateException(""Database has been closed."");
    }
    int ret = seekCountryV6(addr) - COUNTRY_BEGIN;
    if (ret == 0) {
        return UNKNOWN_COUNTRY;
    }
    else {
        return new Country(countryCode[ret], countryName[ret]);
    }
}","/**
 * Returns the country the IP address is in.
 *
 * @param addr the IP address as Inet6Address.
 * @return the country the IP address is from.
 */
public Country getCountryV6(InetAddress addr) 
{
    if (addr instanceof Inet6Address)
    {
        return getCountryV6(((Inet6Address)addr).getHostAddress());
    }
    return null;
}   ",1679,True
"/**
 * Concatent two paths
 * 
 * @param original original path
 * @param append path to append
 * @return new path
 */
public static String concatenatePaths(String original, String append){
    if (append != null) {
        if (original.endsWith(""/"")) {
            original = original.concat(stripLeadingSlash(append));
        } else {
            if (append.startsWith(""/"")) {
                original = original.concat(append);
            } else {
                original = original.concat(""/"".concat(append));
            }
        }
    }
    return original;
}","/**
 * Concatent two paths
 * 
 * @param original original path
 * @param append path to append
 * @return new path
 */
public static String concatenatePaths(String original, String append) 
{
    if (original.endsWith(""/""))
    {
        if (append.startsWith(""/""))
        {
            return original + append.substring(1);
        }
        else
        {
            return original + append;
        }
    }
    else
    {
        if (append.startsWith(""/""))
        {
            return original + append;
        }
        else
        {
            return original + ""/"" + append;
        }
    }
}   ",1682,True
"/**
 * Encode  a path suitable for use in a URI.
 * 
 * @param path path
 * @param encodeSlash encode forward slashes (/)
 * @return encoded path
 */
public static String encodePath(String path, boolean encodeSlash, String charset){
    /* Encode the string */
    StringBuffer buffer = new StringBuffer();
    byte encoded[];
    try {
        if(charset==null)
            encoded = path.getBytes();
        else
            encoded = path.getBytes(charset);
        for (int x = 0; x < encoded.length; x++) {
            if (((int) encoded[x] == '%' && encodeSlash) || ACCEPTABLE.indexOf((int) encoded[x]) < 0) {
                buffer.append('%');
                buffer.append(DAVUtilities.toHexString(encoded[x]));
                continue;
            }
            buffer.append((char) encoded[x]);
        }
    } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
        return path;
    }

    return buffer.toString();
}","/**
 * Encode  a path suitable for use in a URI.
 * 
 * @param path path
 * @param encodeSlash encode forward slashes (/)
 * @return encoded path
 */
public static String encodePath(String path, boolean encodeSlash, String charset) 
{
    if (path == null)
        return null;

    StringBuilder encodedPath = new StringBuilder();
    for (int i = 0; i < path.length(); i++)
    {
        char c = path.charAt(i);
        if (c < 128)
        {
            if (encodeSlash && c == '/')
                encodedPath.append(""%2F"");
            else if (doesntNeedEncoding(c, encodeSlash))
                encodedPath.append(c);
            else
            {
                byte[] bytes = new String(new char[] {c}).getBytes(Charset.forName(charset));
                for (byte b : bytes)
                {
                    encodedPath.append('%');
                    encodedPath.append(hex[b >> 4]);
                    encodedPath.append(hex[b & 0xf]);
                }
            }
        }
        else
        {
            byte[] bytes = new String(new char[] {c}).getBytes(Charset.forName(charset));
            for (byte b : bytes)
            {
                encodedPath.append('%');
                encodedPath.append(hex[b >> 4]);
                encodedPath.append(hex[b & 0xf]);
            }
        }
    }
    return encodedPath.toString();
}   ",1684,False
"/**
 * Get the parent path or <code>null</code> if at the root
 * 
 * @param path
 * @return parent path
 */
public static String getParentPath(String path){
    path = stripTrailingSlash(path);
    String parent = null;
    if (!path.equals("""")) {
        int idx = path.lastIndexOf(""/"");
        if (idx == -1) {
            parent = ""/"";
        } else {
            parent = path.substring(0, idx + 1);
        }
    }
    return parent;
}","/**
 * Get the parent path or <code>null</code> if at the root
 * 
 * @param path
 * @return parent path
 */
public static String getParentPath(String path) 
{
    if (path == null)
    {
        return null;
    }

    int lastSlash = path.lastIndexOf('/');
    if (lastSlash < 0)
    {
        return null;
    }

    return path.substring(0, lastSlash);
}   ",1685,True
"/**
 * <p>
 * Return the HEX representation of a long integer.
 * </p>
 * 
 * @param number the long to convert in a HEX {@link String}.
 * @return a <b>non-null</b> 16-characters {@link String} instance.
 */
public static String toHexString(long number){
    char output[] = new char[16];
    output[0] = DAVUtilities.toHexDigit((int) (number >> 60));
    output[1] = DAVUtilities.toHexDigit((int) (number >> 56));
    output[2] = DAVUtilities.toHexDigit((int) (number >> 52));
    output[3] = DAVUtilities.toHexDigit((int) (number >> 48));
    output[4] = DAVUtilities.toHexDigit((int) (number >> 44));
    output[5] = DAVUtilities.toHexDigit((int) (number >> 40));
    output[6] = DAVUtilities.toHexDigit((int) (number >> 36));
    output[7] = DAVUtilities.toHexDigit((int) (number >> 32));
    output[8] = DAVUtilities.toHexDigit((int) (number >> 28));
    output[9] = DAVUtilities.toHexDigit((int) (number >> 24));
    output[10] = DAVUtilities.toHexDigit((int) (number >> 20));
    output[11] = DAVUtilities.toHexDigit((int) (number >> 16));
    output[12] = DAVUtilities.toHexDigit((int) (number >> 12));
    output[13] = DAVUtilities.toHexDigit((int) (number >> 8));
    output[14] = DAVUtilities.toHexDigit((int) (number >> 4));
    output[15] = DAVUtilities.toHexDigit((int) (number));
    return new String(output);
}","/**
 * <p>
 * Return the HEX representation of a long integer.
 * </p>
 * 
 * @param number the long to convert in a HEX {@link String}.
 * @return a <b>non-null</b> 16-characters {@link String} instance.
 */
public static String toHexString(long number) 
{
    return toHexString(number, 16);
}   ",1687,False
"/**
 * <p>
 * Return the HEX representation of an array of bytes.
 * </p>
 * 
 * @param buffer the array of bytes to convert in a HEX {@link String}.
 * @return a <b>non-null</b> {@link String} instance.
 */
public static String toHexString(byte buffer[]){
    char output[] = new char[buffer.length * 2];
    int position = 0;
    for (int x = 0; x < buffer.length; x++) {
        output[position++] = DAVUtilities.toHexDigit(buffer[x] >> 4);
        output[position++] = DAVUtilities.toHexDigit(buffer[x]);
    }
    return new String(output);
}","/**
 * <p>
 * Return the HEX representation of an array of bytes.
 * </p>
 * 
 * @param buffer the array of bytes to convert in a HEX {@link String}.
 * @return a <b>non-null</b> {@link String} instance.
 */
public static String toHexString(byte buffer[]) 
{
    StringBuffer hexString = new StringBuffer();
    for (int i = 0; i < buffer.length; i++)
    {
        String hex = Integer.toHexString(0xff & buffer[i]);
        if (hex.length() == 1)
        {
            hexString.append('0');
        }
        hexString.append(hex);
    }
    return hexString.toString();
}   ",1689,True
"/**
 * Get ETAG
 * 
 * @param path
 * @param lastModified
 * @return ETAG
 */
public static String getETAG(String path, Date lastModified){
    StringBuffer etag = new StringBuffer();
    etag.append('""');

    /* Append the MD5 hash of this resource name */
    try {
        MessageDigest digester = MessageDigest.getInstance(""MD5"");
        digester.reset();
        digester.update(path.getBytes(""UTF8""));
        etag.append(DAVUtilities.toHexString(digester.digest()));
        etag.append('-');
    } catch (Exception e) {
        // If we can't get the MD5 HASH, let's ignore and hope...
    }

    /* Append the hashCode of this resource name */
    etag.append(DAVUtilities.toHexString(path.hashCode()));

    /* Append the last modification date if possible */
    if (lastModified != null) {
        etag.append('-');
        etag.append(DAVUtilities.toHexString(lastModified.getTime()));
    }

    /* Close the ETag */
    etag.append('""');
    return (etag.toString());
}","/**
 * Get ETAG
 * 
 * @param path
 * @param lastModified
 * @return ETAG
 */
public static String getETAG(String path, Date lastModified) 
{
    String etag = path + ""_"" + lastModified.getTime();
    return etag;
}   ",1691,False
"/**
 * <p>
 * Return the HEX representation of a byte.
 * </p>
 * 
 * @param number the byte to convert in a HEX {@link String}.
 * @return a <b>non-null</b> 2-characters {@link String} instance.
 */
public static String toHexString(byte number){
    char output[] = new char[2];
    output[0] = DAVUtilities.toHexDigit((int) (number >> 4));
    output[1] = DAVUtilities.toHexDigit((int) (number));
    return new String(output);
}","/**
 * <p>
 * Return the HEX representation of a byte.
 * </p>
 * 
 * @param number the byte to convert in a HEX {@link String}.
 * @return a <b>non-null</b> 2-characters {@link String} instance.
 */
public static String toHexString(byte number) 
{
    final StringBuilder sb = new StringBuilder(2);
    sb.append(HEX_CHARS[(number >> 4) & 0x0F]);
    sb.append(HEX_CHARS[number & 0x0F]);
    return sb.toString();
}   ",1693,False
"/**
 * <p>
 * Format an {@link Object} according to the HTTP/1.1 RFC.
 * </p>
 * 
 * @param object the {@link Object} to format.
 * @return a {@link String} instance or <b>null</b> if the object was null.
 */
public static String format(Object object){
    if (object == null)
        return null;
    if (object instanceof String)
        return ((String) object);
    if (object instanceof Date) {
        SimpleDateFormat formatter = new SimpleDateFormat(FORMAT_822, Locale.ENGLISH);
        formatter.setTimeZone(TIMEZONE_822);
        return formatter.format((Date) object);
    }
    return (object.toString());
}","/**
 * <p>
 * Format an {@link Object} according to the HTTP/1.1 RFC.
 * </p>
 * 
 * @param object the {@link Object} to format.
 * @return a {@link String} instance or <b>null</b> if the object was null.
 */
public static String format(Object object) 
{
    if (object == null)
    {
        return null;
    }
    return object.toString();
}   ",1694,True
"/**
 * <p>
 * Return a {@link String} message given an HTTP status code.
 * </p>
 * 
 * @param status status code
 * @return status strings
 */
public static String getStatusMessage(int status){
    switch (status) {
        /* HTTP/1.1 RFC-2616 */
        case 100:
            return ""100 Continue"";
        case 101:
            return ""101 Switching Protocols"";
        case 200:
            return ""200 OK"";
        case 201:
            return ""201 Created"";
        case 202:
            return ""202 Accepted"";
        case 203:
            return ""203 Non-Authoritative Information"";
        case 204:
            return ""204 No Content"";
        case 205:
            return ""205 Reset Content"";
        case 206:
            return ""206 Partial Content"";
        case 300:
            return ""300 Multiple Choices"";
        case 301:
            return ""301 Moved Permanently"";
        case 302:
            return ""302 Found"";
        case 303:
            return ""303 See Other"";
        case 304:
            return ""304 Not Modified"";
        case 305:
            return ""305 Use Proxy"";
        case 306:
            return ""306 (Unused)"";
        case 307:
            return ""307 Temporary Redirect"";
        case 400:
            return ""400 Bad Request"";
        case 401:
            return ""401 Unauthorized"";
        case 402:
            return ""402 Payment Required"";
        case 403:
            return ""403 Forbidden"";
        case 404:
            return ""404 Not Found"";
        case 405:
            return ""405 Method Not Allowed"";
        case 406:
            return ""406 Not Acceptable"";
        case 407:
            return ""407 Proxy Authentication Required"";
        case 408:
            return ""408 Request Timeout"";
        case 409:
            return ""409 Conflict"";
        case 410:
            return ""410 Gone"";
        case 411:
            return ""411 Length Required"";
        case 412:
            return ""412 Precondition Failed"";
        case 413:
            return ""413 Request Entity Too Large"";
        case 414:
            return ""414 Request-URI Too Long"";
        case 415:
            return ""415 Unsupported Media Type"";
        case 416:
            return ""416 Requested Range Not Satisfiable"";
        case 417:
            return ""417 Expectation Failed"";
        case 500:
            return ""500 Internal Server Error"";
        case 501:
            return ""501 Not Implemented"";
        case 502:
            return ""502 Bad Gateway"";
        case 503:
            return ""503 Service Unavailable"";
        case 504:
            return ""504 Gateway Timeout"";
        case 505:
            return ""505 HTTP Version Not Supported"";

            /* DAV/1.0 RFC-2518 */
        case 102:
            return ""102 Processing"";
        case 207:
            return ""207 Multi-Status"";
        case 422:
            return ""422 Unprocessable Entity"";
        case 423:
            return ""423 Locked"";
        case 424:
            return ""424 Failed Dependency"";
        case 507:
            return ""507 Insufficient Storage"";

            /* Unknown */
        default:
            return null;
    }
}","/**
 * <p>
 * Return a {@link String} message given an HTTP status code.
 * </p>
 * 
 * @param status status code
 * @return status strings
 */
public static String getStatusMessage(int status) 
{
    switch (status)
    {
        case 100:
            return ""Continue"";
        case 101:
            return ""Switching Protocols"";
        case 200:
            return ""OK"";
        case 201:
            return ""Created"";
        case 202:
            return ""Accepted"";
        case 203:
            return ""Non-Authoritative Information"";
        case 204:
            return ""No Content"";
        case 205:
            return ""Reset Content"";
        case 206:
            return ""Partial Content"";
        case 300:
            return ""Multiple Choices"";
        case 301:
            return ""Moved Permanently"";
        case 302:
            return ""Found"";
        case 303:
            return ""See Other"";
        case 304:
            return ""Not Modified"";
        case 305:
            return ""Use Proxy"";
        case 307:
            return ""Temporary Redirect"";
        case 400:
            return ""Bad Request"";
        case 401:
            return ""Unauthorized"";
        case 402:
            return ""Payment Required"";
        case 403:
            return ""Forbidden"";
        case 404:
            return ""Not Found"";
        case 405:
            return ""Method Not Allowed"";
        case 406:
            return ""Not Acceptable"";
        case 407:
            return ""Proxy Authentication Required"";
        case 408:
            return ""Request Timeout"";
        case 409:
            return ""Conflict"";
        case 410:
            return ""Gone"";
        case 411:
            return ""Length Required"";
        case 412:
            return ""Precondition Failed"";
        case 413:
            return ""Request Entity Too Large"";
        case 414:
            return ""Request-URI Too Long"";
        case 415:
            return ""Unsupported Media Type"";
        case 416:
            return ""Requested Range Not Satisfiable"";
        case 417:
            return ""Expectation Failed"";
        case 500:
            return ""Internal Server Error"";
        case 501:
            return ""Not Implemented"";
        case 502:
            return ""Bad Gateway"";
        case 503:
            return ""Service Unavailable"";
        case 504:
            return ""Gateway Timeout"";
        case 505:
            return ""HTTP Version Not Supported"";
        default:
            return """";
    }
}   ",1697,False
"/**
 * Strip all trailing slashes
 * 
 * @param path
 * @return new path
 */
public static String stripTrailingSlash(String path){
    while (path.endsWith(""/"")) {
        path = path.substring(0, path.length() - 1);
    }
    return path;
}","/**
 * Strip all trailing slashes
 * 
 * @param path
 * @return new path
 */
public static String stripTrailingSlash(String path) 
{
    if (path == null)
    {
        return null;
    }
    if (path.endsWith(""/""))
    {
        path = path.substring(0, path.length() - 1);
    }
    return (path);
}   ",1699,True
"/**
 * SQS message to SI message transformation.
 * @param message source
 * @return the SI message
 */
private Message<Object> handleReceivedMessage(final com.amazonaws.queue.doc._2009_02_01.Message message){
	Message<Object> result;
	if (isExtractPayload()) {
		try {
			result = extractPayload(message);
		}
		catch (Exception e) {
			throw new MessageTransformationException(""Failed to convert payload of sqs message: "" + message, e);
		}
	}
	else {
		result = new GenericMessage<Object>(message);
	}
	log.debug(""Received as: "" + result);
	return result;
}","/**
 * SQS message to SI message transformation.
 * @param message source
 * @return the SI message
 */
private Message<Object> handleReceivedMessage(final com.amazonaws.queue.doc._2009_02_01.Message message) 
{
    Message<Object> siMessage = new Message<Object>();
    siMessage.setPayload(message.getBody());
    return siMessage;
}   ",1700,True
"/**
 * Gets the value of the queueUrl property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the queueUrl property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getQueueUrl().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link String }
 * 
 * 
 */
public List<String> getQueueUrl(){
    if (queueUrl == null) {
        queueUrl = new ArrayList<String>();
    }
    return this.queueUrl;
}","/**
 * Gets the value of the queueUrl property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the queueUrl property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getQueueUrl().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link String }
 * 
 * 
 */
public List<String> getQueueUrl() 
{
    if (queueUrl == null)
    {
        queueUrl = new ArrayList<String>();
    }
    return this.queueUrl;
}   ",1704,True
"/**
 * Gets the value of the any property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the any property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getAny().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link Element }
 * {@link Object }
 * 
 * 
 */
public List<Object> getAny(){
    if (any == null) {
        any = new ArrayList<Object>();
    }
    return this.any;
}","/**
 * Gets the value of the any property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the any property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getAny().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link Element }
 * {@link Object }
 * 
 * 
 */
public List<Object> getAny() 
{
    if (any == null)
    {
        any = new ArrayList<Object>();
    }
    return this.any;
}   ",1706,True
"/**
 * Gets the value of the message property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the message property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getMessage().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link Message }
 * 
 * 
 */
public List<Message> getMessage(){
    if (message == null) {
        message = new ArrayList<Message>();
    }
    return this.message;
}","/**
 * Gets the value of the message property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the message property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getMessage().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link Message }
 * 
 * 
 */
public List<Message> getMessage() 
{
    if (message == null)
    {
        message = new ArrayList<Message>();
    }
    return this.message;
}   ",1710,True
"/**
 * @param message
 * @return
 * @throws MessageHandlingException
 */
public static MessageChannel fetchReplyChannel(Message<?> message,
		ChannelResolver channelResolver){
	// copy/paste from MessageHandlerChain.ReplyForwardingMessageChannel
	Object replyChannelHeader = message.getHeaders().getReplyChannel();
	if (replyChannelHeader == null) {
		throw new MessageHandlingException(message, ""no replyChannel header available"");
	}
	MessageChannel replyChannel = null;
	if (replyChannelHeader instanceof MessageChannel) {
		replyChannel = (MessageChannel) replyChannelHeader;
	}
	else if (replyChannelHeader instanceof String) {
		Assert.notNull(channelResolver, ""ChannelResolver is required"");
		replyChannel = channelResolver.resolveChannelName((String) replyChannelHeader);
	}
	else {
		throw new MessageHandlingException(message, ""invalid replyChannel type [""
				+ replyChannelHeader.getClass() + ""]"");
	}
	return replyChannel;
}","/**
 * @param message
 * @return
 * @throws MessageHandlingException
 */

public static MessageChannel fetchReplyChannel(Message<?> message,
		ChannelResolver channelResolver) 
{
	MessageChannel replyChannel = (MessageChannel) message
			.getHeader(MessageHeaders.REPLY_CHANNEL);

	if (replyChannel == null && channelResolver != null)
	{
		replyChannel = channelResolver.resolve();
	}

	return replyChannel;
}	",1712,True
"/**
 * @param url
 */
private SimpleGetRequest(String url){
	super();
	try {
		this.targetUrl = new URL(url);
	}
	catch (MalformedURLException e) {
		throw new IllegalArgumentException(""Malformed URL: "" + url, e);
	}
}","/**
 * @param url
 */
private SimpleGetRequest(String url) 
{
    this.url = url;
}   ",1713,False
"/**
 * Gets the value of the attributeName property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the attributeName property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getAttributeName().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link String }
 * 
 * 
 */
public List<String> getAttributeName(){
    if (attributeName == null) {
        attributeName = new ArrayList<String>();
    }
    return this.attributeName;
}","/**
 * Gets the value of the attributeName property.
 * 
 * <p>
 * This accessor method returns a reference to the live list,
 * not a snapshot. Therefore any modification you make to the
 * returned list will be present inside the JAXB object.
 * This is why there is not a <CODE>set</CODE> method for the attributeName property.
 * 
 * <p>
 * For example, to add a new item, do as follows:
 * <pre>
 *    getAttributeName().add(newItem);
 * </pre>
 * 
 * 
 * <p>
 * Objects of the following type(s) are allowed in the list
 * {@link String }
 * 
 * 
 */
public List<String> getAttributeName() 
{
    if (attributeName == null)
    {
        attributeName = new ArrayList<String>();
    }
    return this.attributeName;
}   ",1717,True
"//Near as I can tell this is valid minijava...
public Evil Evil(){
	Evil evil = new Evil();
	return evil;//its funny how weird this word starts to look
}","//Near as I can tell this is valid minijava...
public Evil Evil() 
{
    return new Evil();
}   ",1722,True
"// boolean ntb ;
 //boolean cont ;
 //boolean found ;
 //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
// int auxkey1 ;
// int auxkey2 ;
public boolean Init(int v_key){
	key = v_key ;
	has_left = false ;
	has_right = false ;
	return true ;
 }","// boolean ntb ;
 //boolean cont ;
 //boolean found ;
 //int ifound ;
  //  boolean is_root ;
  //  int     nti ;
  //  int key_aux ;
// int auxkey1 ;
// int auxkey2 ;
public boolean Init(int v_key) 
{
    boolean ntb ;
    boolean cont ;
    boolean found ;
    int ifound ;
    boolean is_root ;
    int nti ;
    int key_aux ;
    int auxkey1 ;
    int auxkey2 ;
    ntb = false ;
    cont = true ;
    found = false ;
    ifound = 0 ;
    is_root = false ;
    nti = 0 ;
    key_aux = v_key ;
    auxkey1 = 0 ;
    auxkey2 = 0 ;
    return ntb ;
} ",1723,True
"//source of error
public int setsms(boolean x){
		sms = x;
		return 0;
	}","//source of error
public int setsms(boolean x) 
{
    if(x==true)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}   ",1725,True
"// Modeled after an exam question from CSSE 230
public boolean swap(int a, int b){
	boolean ret = false; // originally had boolean ret; which is invalid MiniJava
	if (a == b)
		ret = false;
	else {
		int temp = a;
		a = b;
		b = temp;
		ret = true;
	}		
	return ret;
}","// Modeled after an exam question from CSSE 230
public boolean swap(int a, int b) 
{
    if (a < 0 || a >= size || b < 0 || b >= size)
    {
        return false;
    }
    else
    {
        int temp = array[a];
        array[a] = array[b];
        array[b] = temp;
        return true;
    }
}   ",1726,False
"// no private methods, only public
// ""String"" should be okay... treated as <ID>
private int method(String s){
	// valid
	Point p = new Point();
	// invalid -- constructors cannot have params
	Point r2 = new Point(5,7);
}","// no private methods, only public
// ""String"" should be okay... treated as <ID>
private int method(String s) 
{
    return 0;
}   ",1728,True
"// Assuming 32-bit signed (but positive) integers and we don't and the
// uppermost bit.
public int almostAnd(int lhs, int rhs){
    int retval = 0;
    boolean lhsOn = false;
    boolean rhsOn = false;
    
    /* Bit 30 */
    if (lhs - 1073741824 >= 0) {
        lhs = lhs - 1073741824;
        lhsOn = true;
    } else
        lhsOn = false;
    
    if (rhs - 1073741824 >= 0) {
        rhs = rhs - 1073741824;
        rhsOn = true;
    } else
        rhsOn = false;
    
    if (lhsOn && rhsOn)
        retval = retval + 1073741824;
    else
        retval = retval + 0;
    
    /* Bit 29 */
    if (lhs - 536870912 >= 0) {
        lhs = lhs - 536870912;
        lhsOn = true;
    } else
        lhsOn = false;
    
    if (rhs - 536870912 >= 0) {
        rhs = rhs - 536870912;
        rhsOn = true;
    } else
        rhsOn = false;
    
    if (lhsOn && rhsOn)
        retval = retval + 536870912;
    else
        retval = retval + 0;
    
    /* Bit 28 */
    if (lhs - 268435456 >= 0) {
        lhs = lhs - 268435456;
        lhsOn = true;
    } else
        lhsOn = false;
    
    if (rhs - 268435456 >= 0) {
        rhs = rhs - 268435456;
        rhsOn = true;
    } else
        rhsOn = false;
    
    if (lhsOn && rhsOn)
        retval = retval + 268435456;
    else
        retval = retval + 0;
    
    /* Bit 27 */
    if (lhs - 134217728 >= 0) {
        lhs = lhs - 134217728;
        lhsOn = true;
    } else
        lhsOn = false;
    
    if (rhs - 134217728 >= 0) {
        rhs = rhs - 134217728;
        rhsOn = true;
    } else
        rhsOn = false;
    
    if (lhsOn && rhsOn)
        retval = retval + 134217728;
    else
        retval = retval + 0;
    
    /* Bit 26 */
    if (lhs - 67108864 >= 0) {
        lhs = lhs - 67108864;
        lhsOn = true;
    } else
        lhsOn = false;
    
    if (rhs - 67108864 >= 0) {
        rhs = rhs - 67108864;
        rhsOn = true;
    } else
        rhsOn = false;
    
    if (lhsOn && rhsOn)
        retval = retval + 67108864;
    else
        retval = retval + 0;
    
    /* Bit 25 */
    if (lhs - 33554432 >= 0) {
        lhs = lhs - 33554432;
        lhsOn = true;
    } else
        lhsOn = false;
    
    if (rhs - 33554432 >= 0) {
        rhs = rhs - 33554432;
        rhsOn = true;
    } else
        rhsOn = false;
    
    if (lhsOn && rhsOn)
        retval = retval + 33554432;
    else
        retval = retval + 0;
    /* Well, we ran out of room, but we're pretty sure you get the idea.
     * Just for completeness, here are the remaining decimal values:
     * Bit 24: 16777216
     * Bit 23:  8388608
     * Bit 22:  4194304
     * Bit 21:  2097152
     * Bit 20:  1048576
     * Bit 19:   524288
     * Bit 18:   262144
     * Bit 17:   131072
     * Bit 16:    65536
     * Bit 15:    32768
     * Bit 14:    16384
     * Bit 13:     8192
     * Bit 12:     4096
     * Bit 11:     2048
     * Bit 10:     1024
     * Bit 9:       512
     * Bit 8:       256
     * Bit 7:       128
     * Bit 6:        64
     * Bit 5:        32
     * Bit 4:        16
     * Bit 3:         8
     * Bit 2:         4
     * Bit 1:         2
     * Bit 0:         1
     *
     * Obviously, bitwise or is just a copy and paste of this code with
     * if (lshOn && rhsOn) changed to if (lshOn || rhsOn).
     */
     return retval;
}","// Assuming 32-bit signed (but positive) integers and we don't and the
// uppermost bit.
public int almostAnd(int lhs, int rhs) 
{
    int result = 0;
    int mask = 1;
    for (int i = 0; i < 32; i++)
    {
        int bit = (lhs & mask) & (rhs & mask);
        result |= bit;
        mask <<= 1;
    }
    return result;
}   ",1729,True
"// can't have methods in <MainClassDecl>
public int fib(int n){
	// one-armed if
	if (n == 0) return 1;

	if (n == 1) return 1;
	else{
		return f(n-1) + f(n-2);
	}

	//return statements not as last line of method
}","// can't have methods in <MainClassDecl>
public int fib(int n) 
{
    if (n == 0)
        return 0;
    else if (n == 1)
        return 1;
    else
        return fib(n - 1) + fib(n - 2);
}   ",1730,True
"// ZOMG constructor WTF
public Point(int length, int width){
	/* these are wrong -- 
	this.l does not match <<ID = Expr;>> as assignment <Stmt>
	*/
	this.l = length;
	this.w = width
}","// ZOMG constructor WTF
public Point(int length, int width) 
{
    this.length = length;
    this.width = width;
    this.x = 0;
    this.y = 0;
    this.z = 0;
}   ",1733,False
"// If MiniJava does not support method overloading, delete the following
// method
public boolean complement(boolean val){
    complementCount = complementCount + 1;
    return !val;
}","// If MiniJava does not support method overloading, delete the following
// method
public boolean complement(boolean val) 
{
    if (val == true)
    {
        return false;
    }
    else
    {
        return true;
    }
}   ",1737,True
"// email me if you want the original joke. I'm Sriram
public static void main (String[ ] ID){ 
	Dude minister = new Minister();
	Dude priest = new Priest();
	Rabbi rabbi = new Rabbi();

	if (minister.walkOnWater(true))
	{
		int i = rabbi.astonish();
	}
	else {}
	if (priest.walkOnWater(true))
	{
		int i = rabbi.astonish();
	}
	else {}
	boolean b = rabbi.walkOnWater(false);
	int i = priest.speculate();
}","// email me if you want the original joke. I'm Sriram
public static void main (String[ ] ID) 
{
    int x = 0;
    int y = 0;
    while (x < 5)
    {
        y = x - y;
        System.out.print(x + """" + y + "" "");
        x = x + 1;
    }
}   ",1738,False
"/**
 * Constructs a Line These objects are defined by their two end-points.
 * 
 * @param color
 *            the color for this object
 * @param lineStyle
 *            the line style for this object
 * @param x1
 *            the virtual X coordinate of the first end-point
 * @param y1
 *            the virtual Y coordinate of the first end-point
 * @param x2
 *            the virtual X coordinate of the second end-point
 * @param y2
 *            the virtual Y coordinate of the second end-point
 */
public LineFigure(Color foregroundColor, Color backgroundColor, int lineStyle, int x1, int y1, int x2, int y2){
	this.foregroundColor = foregroundColor;
	this.backgroundColor = backgroundColor;
	this.lineStyle = lineStyle;
	this.x1 = x1;
	this.y1 = y1;
	this.x2 = x2;
	this.y2 = y2;
}","/**
 * Constructs a Line These objects are defined by their two end-points.
 * 
 * @param color
 *            the color for this object
 * @param lineStyle
 *            the line style for this object
 * @param x1
 *            the virtual X coordinate of the first end-point
 * @param y1
 *            the virtual Y coordinate of the first end-point
 * @param x2
 *            the virtual X coordinate of the second end-point
 * @param y2
 *            the virtual Y coordinate of the second end-point
 */
public LineFigure(Color foregroundColor, Color backgroundColor, int lineStyle, int x1, int y1, int x2, int y2) 
{
    super(foregroundColor, backgroundColor, lineStyle);
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
}   ",1740,True
"/*
 * {@inheritDoc}
 *
 * @see net.sf.swtbot.eclipse.gef.matchers.AbstractToolEntryMatcher#matches(org.eclipse.gef.palette.ToolEntry)
 */
@Override
protected boolean matches(final ToolEntry toolEntry){
	final String label = toolEntry.getLabel();
	if (label == null) {
		return false;
	}
	final Matcher matcher = pattern.matcher(label);
	return matcher.matches();
}","/*
 * {@inheritDoc}
 *
 * @see net.sf.swtbot.eclipse.gef.matchers.AbstractToolEntryMatcher#matches(org.eclipse.gef.palette.ToolEntry)
 */
@Override
protected boolean matches(final ToolEntry toolEntry) 
{
    return toolEntry.getToolClass().equals(toolClass);
}   ",1743,True
"/**
 * Creates and installs pertinent EditPolicies.
 */
protected void createEditPolicies(){
	super.createEditPolicies();
	installEditPolicy(EditPolicy.CONTAINER_ROLE, new LogicContainerEditPolicy());
	installEditPolicy(EditPolicy.TREE_CONTAINER_ROLE, new LogicTreeContainerEditPolicy());
	//If this editpart is the contents of the viewer, then it is not deletable!
	if (getParent() instanceof RootEditPart)
		installEditPolicy(EditPolicy.COMPONENT_ROLE, new RootComponentEditPolicy());
}","/**
 * Creates and installs pertinent EditPolicies.
 */
protected void createEditPolicies() 
{
    installEditPolicy(EditPolicy.ROLE, new MyEditPolicy());
}   ",1744,True
"/**
 * Gets a list of all menus within the view.
 *
 * @param view the view to probe for menus.
 * @param matcher the matcher that can match menus and menu items.
 * @param recursive if set to <code>true</code>, will find sub-menus as well.
 * @return The list of menus (IContributionItems) that match the matcher.
 * @since 2.0
 */
public List<SWTBotViewMenu> findMenus(final IViewReference view, final Matcher<?> matcher, final boolean recursive){
	return UIThreadRunnable.syncExec(new ListResult<SWTBotViewMenu>() {

		public List<SWTBotViewMenu> run() {
			ViewPane viewPane = (ViewPane) ((WorkbenchPartReference) view).getPane();
			MenuManager mgr = viewPane.getMenuManager();
			List<SWTBotViewMenu> l = new ArrayList<SWTBotViewMenu>();

			l.addAll(getMenuItemsInternal(mgr.getItems(), matcher, recursive));

			return l;
		}
	});
}","/**
 * Gets a list of all menus within the view.
 *
 * @param view the view to probe for menus.
 * @param matcher the matcher that can match menus and menu items.
 * @param recursive if set to <code>true</code>, will find sub-menus as well.
 * @return The list of menus (IContributionItems) that match the matcher.
 * @since 2.0
 */

public List<SWTBotViewMenu> findMenus(final IViewReference view, final Matcher<?> matcher, final boolean recursive) 
{
    List<SWTBotViewMenu> menus = new ArrayList<SWTBotViewMenu>();
    for (SWTBotViewMenu menu : view.getMenus())
    {
        if (matcher.matches(menu))
        {
            menus.add(menu);
        }
        if (recursive)
        {
            menus.addAll(findMenus(menu, matcher, recursive));
        }
    }
    return menus;
}   ",1747,True
"/**
 * Refreshes the visual properties of the TreeItem for this part.
 */
protected void refreshVisuals(){
	if (getWidget() instanceof Tree)
		return;
	Image image = getLogicSubpart().getIcon();
	TreeItem item = (TreeItem)getWidget();
	if (image != null)
		image.setBackground(item.getParent().getBackground());
	setWidgetImage(image);
	setWidgetText(getLogicSubpart().toString());
}","/**
 * Refreshes the visual properties of the TreeItem for this part.
 */
protected void refreshVisuals() 
{
    super.refreshVisuals();
    if (getPart() != null)
    {
        setIcon(getPart().getIcon());
        setText(getPart().getName());
    }
}   ",1750,True
"/**
 * Creates and installs pertinent EditPolicies
 * for this.
 */
protected void createEditPolicies(){
	EditPolicy component;
	if (getModel() instanceof LED)
		component = new LEDEditPolicy();
	else
		component = new LogicElementEditPolicy();
	installEditPolicy(EditPolicy.COMPONENT_ROLE, component);
	installEditPolicy(EditPolicy.PRIMARY_DRAG_ROLE, new LogicTreeEditPolicy());
}","/**
 * Creates and installs pertinent EditPolicies
 * for this.
 */

protected void createEditPolicies() 
{
    installEditPolicy(EditPolicy.ROLE, new MyEditPolicy());
    installEditPolicy(EditPolicy.LAYOUT_ROLE, new MyLayoutEditPolicy());
}   ",1754,False
"/**
 * Invokes as a standalone program.
 */
public static void main(String[] args){
	final Display display = new Display();
	final Shell shell = new Shell(display);
	shell.setLayout(new FillLayout());
	new LayoutExample(shell);
	shell.setText(LayoutExample.getResourceString(""window.title""));
	shell.addShellListener(new ShellAdapter() {
		public void shellClosed(ShellEvent e) {
			Shell[] shells = display.getShells();
			for (int i = 0; i < shells.length; i++)
				if (shells[i] != shell)
					shells[i].close();
		}
	});
	shell.open();
	while (!shell.isDisposed())
		if (!display.readAndDispatch())
			display.sleep();
}","/**
 * Invokes as a standalone program.
 */
public static void main(String[] args) 
{
    if (args.length != 1)
    {
        System.err.println(""Usage: java "" + Main.class.getName() + "" <input file>"");
        System.exit(1);
    }

    try
    {
        // Parse the input file
        Parser parser = new Parser(args[0]);
        Program program = parser.parse();

        // Run the program
        program.run();
    }
    catch (IOException e)
    {
        System.err.println(""Error: "" + e.getMessage());
        System.exit(1);
    }
    catch (ParserException e)
    {
        System.err.println(""Error: "" + e.getMessage());
        System.exit(1);
    }
    catch (RuntimeException e)
    {
        System.err.println(""Error: "" + e.getMessage());
        System.exit(1);
    }
}   ",1758,False
"/**
 * Recycles a PreparedStatement-SQLQuery pair of delete type in the pool,
 * after it's parameters are cleared. Use of this method is MANDATORY after
 * using getDelete method. If PreparedStatements are not recycled the system
 * will hang when the pool runs empty.
 * @param pair the Entry pair that needs recycling.
 * @param t the JTable in which the Entry belongs.
 */
public void recycleDelete(Pair<PreparedStatement, SQLQuery> pair, JTable t){
    try {
        pair.getKey().clearParameters();
        delete.get(t).add(pair);
    } catch (SQLException ex) {
        throw new RuntimeException(ex);
    }
}","/**
 * Recycles a PreparedStatement-SQLQuery pair of delete type in the pool,
 * after it's parameters are cleared. Use of this method is MANDATORY after
 * using getDelete method. If PreparedStatements are not recycled the system
 * will hang when the pool runs empty.
 * @param pair the Entry pair that needs recycling.
 * @param t the JTable in which the Entry belongs.
 */

public void recycleDelete(Pair<PreparedStatement, SQLQuery> pair, JTable t) 
{
    if (pair != null)
    {
        PreparedStatement ps = pair.getFirst();
        SQLQuery query = pair.getSecond();

        if (ps != null)
        {
            try
            {
                ps.clearParameters();
            }
            catch (SQLException e)
            {
                // Ignore
            }
        }

        if (query != null)
        {
            query.clearParameters();
        }

        pool.recycle(pair, t);
    }
}   ",1760,True
"/**
 * Inializes the pool for a given table by creating PreparedStatement objects
 * for all query types and inserting them to the pool.
 * @param table the JTable to be initiated.
 */
private void initTable(JTable table){
    search.put(table, new ArrayBlockingQueue<Pair<PreparedStatement, SQLQuery>>(queueSize));
    searchpk.put(table, new ArrayBlockingQueue<Pair<PreparedStatement, SQLQuery>>(queueSize));
    register.put(table, new ArrayBlockingQueue<Pair<PreparedStatement, SQLQuery>>(queueSize));
    delete.put(table, new ArrayBlockingQueue<Pair<PreparedStatement, SQLQuery>>(queueSize));
    update.put(table, new ArrayBlockingQueue<Pair<PreparedStatement, SQLQuery>>(queueSize));
    for (int i = 0; i < poolSize; i++) {
        register.get(table).add(StatementFactory.createRegister(table, con));
        delete.get(table).add(StatementFactory.createDelete(table, con));
        search.get(table).add(StatementFactory.createSearch(table, con));
        searchpk.get(table).add(StatementFactory.createSearchPK(table, con));
        update.get(table).add(StatementFactory.createUpdate(table, con));
    }
}","/**
 * Inializes the pool for a given table by creating PreparedStatement objects
 * for all query types and inserting them to the pool.
 * @param table the JTable to be initiated.
 */

private void initTable(JTable table) 
{
    // Create a new pool for the table.
    table.pool = new PreparedStatement[4];

    // Create a new PreparedStatement for each query type.
    for (int i = 0; i < table.pool.length; i++)
    {
        try
        {
            table.pool[i] = table.getConnection().prepareStatement(table.queries[i]);
        }
        catch (SQLException e)
        {
            e.printStackTrace();
        }
    }
}   ",1762,True
"/**
 * Recycles a PreparedStatement-SQLQuery pair of search-primary-keys-only type in the pool,
 * after it's parameters are cleared. Use of this method is MANDATORY after
 * using getSearchPK method. If PreparedStatements are not recycled the system
 * will hang when the pool runs empty.
 * @param pair the Entry pair that needs recycling.
 * @param t the JTable in which the Entry belongs.
 */
public void recycleSearchPK(Pair<PreparedStatement, SQLQuery> pair, JTable t){
    try {
        pair.getKey().clearParameters();
        searchpk.get(t).add(pair);
    } catch (SQLException ex) {
        throw new RuntimeException(ex);
    }
}","/**
 * Recycles a PreparedStatement-SQLQuery pair of search-primary-keys-only type in the pool,
 * after it's parameters are cleared. Use of this method is MANDATORY after
 * using getSearchPK method. If PreparedStatements are not recycled the system
 * will hang when the pool runs empty.
 * @param pair the Entry pair that needs recycling.
 * @param t the JTable in which the Entry belongs.
 */
public void recycleSearchPK(Pair<PreparedStatement, SQLQuery> pair, JTable t) 
{
    if (pair != null)
    {
        if (pair.getValue() != null)
        {
            pair.getValue().clearParameters();
        }
        searchPKPool.put(pair);
    }
}   ",1764,True
"/**
 * Recycles a PreparedStatement-SQLQuery pair of search type in the pool,
 * after it's parameters are cleared. Use of this method is MANDATORY after
 * using getSearch method. If PreparedStatements are not recycled the system
 * will hang when the pool runs empty.
 * @param pair the Entry pair that needs recycling.
 * @param t the JTable in which the Entry belongs.
 */
public void recycleSearch(Pair<PreparedStatement, SQLQuery> pair, JTable t){
    try {
        pair.getKey().clearParameters();
        search.get(t).add(pair);
    } catch (SQLException ex) {
        throw new RuntimeException(ex);
    }
}","/**
 * Recycles a PreparedStatement-SQLQuery pair of search type in the pool,
 * after it's parameters are cleared. Use of this method is MANDATORY after
 * using getSearch method. If PreparedStatements are not recycled the system
 * will hang when the pool runs empty.
 * @param pair the Entry pair that needs recycling.
 * @param t the JTable in which the Entry belongs.
 */
public void recycleSearch(Pair<PreparedStatement, SQLQuery> pair, JTable t) 
{
    if (pair != null)
    {
        pair.getKey().clearParameters();
        if (t != null)
        {
            t.clearSelection();
        }
        searchPool.recycle(pair);
    }
}   ",1768,True
"/**
 * Returns the pool associated with the specified DbConnector.
 * @param con a DbConnector that represents a database managed by DeciBell.
 * @return the StatementPool object associated with the specified DbConnector.
 */
public static StatementPool getPool(DbConnector con){
    if (pools.get(con) == null) {
        synchronized (lock) {
            pools.put(con, new StatementPool(con));
        }
    }
    return pools.get(con);
}","/**
 * Returns the pool associated with the specified DbConnector.
 * @param con a DbConnector that represents a database managed by DeciBell.
 * @return the StatementPool object associated with the specified DbConnector.
 */
public static StatementPool getPool(DbConnector con) 
{
    return (StatementPool) pools.get(con);
}   ",1770,True
"/**
 * Check the consistency of the attached components before the
 * @throws ImproperDatabaseException
 */
// <editor-fold defaultstate=""collapsed"" desc=""Check Consistency of Attached Components - Before DB creation"">
private void checkConsistencybefore() throws ImproperDatabaseException{
    for (Class<? extends Component> c : components) {
        Constructor<? extends Component> constructor = null;
        try {
            constructor = c.getDeclaredConstructor();
        } catch (NoSuchMethodException ex) {
            throw new ImproperDatabaseException(""The class "" + c.getName() + "" does ""
                    + ""not have a constructor with no parameters."", ex);
        } catch (SecurityException ex) {
            throw new ImproperDatabaseException(""The class "" + c.getName() + "" has ""
                    + ""a constructor with no parameters which is not accessible."", ex);
        }
        try {
            Component component = (Component) constructor.newInstance();
            if (component.getPrimaryKeyFields().size() == 0 && component.getClass().getSuperclass().equals(Component.class)) {
                throw new NoPrimaryKeyException(""Every component should have (at least) one ""
                        + ""primary key. Use @PrimaryKey to annotate your primary key fields."");
            }
            List<Field> foreignFields = component.getForeignKeyFields();
            for (Field f : foreignFields) {
                Class fieldType = f.getType();
                if (!components.contains(fieldType) && !Collection.class.isAssignableFrom(fieldType)) {
                    throw new ImproperDatabaseException(""Did you forget to attach the class "" + f.getType().getSimpleName() + "" in the""
                            + "" DeciBell object?"");
                }
                if (Collection.class.isAssignableFrom(fieldType)) {
                    try {
                        ParameterizedType parametrizedType = (ParameterizedType) f.getGenericType();
                        Type collectionType = parametrizedType.getActualTypeArguments()[0];
                        if (!Component.class.isAssignableFrom((Class<?>) collectionType)) {
                            throw new ImproperDatabaseException(""A collection of non-component elements ("" + ((Class) collectionType).getName() + "") ""
                                    + ""cannot use the @ForeignKey annotation. Use @Entry instead."");
                        }
                    } catch (ClassCastException ex) {
                        throw new ImproperDatabaseException(""A non-parametrized collection should not be annotated with ""
                                + ""a @ForeignKey annotation."");
                    }
                } else if (!Component.class.isAssignableFrom(fieldType)) {
                    throw new ImproperDatabaseException(""Use @ForeignKey only with Components and collections of such."");
                }
            }
        } catch (InstantiationException ex) {
            throw new ImproperDatabaseException(""The constructor of the class"" + c.getName() + "" fails ""
                    + ""to instantiate new objects! (InstantiationException)"", ex);
        } catch (IllegalAccessException ex) {
            throw new ImproperDatabaseException(""The class "" + c.getName() + "" has ""
                    + ""a non-accessible (not public) constructor with no parameters. Make it public."", ex);
        } catch (InvocationTargetException ex) {
            throw new ImproperDatabaseException(""The constructor of the class"" + c.getName() + "" failed ""
                    + ""to instantiate new objects because it threw an exception.\nSee next exception for details..."", ex);
        }

    }
}","/**
 * Check the consistency of the attached components before the
 * @throws ImproperDatabaseException
 */
// <editor-fold defaultstate=""collapsed"" desc=""Check Consistency of Attached Components - Before DB creation"">
private void checkConsistencybefore() throws ImproperDatabaseException 
{
    if (this.getDatabase() == null)
    {
        throw new ImproperDatabaseException(""The database has not been set."");
    }
    if (this.getDatabase().getDatabase() == null)
    {
        throw new ImproperDatabaseException(""The database has not been created."");
    }
    if (this.getDatabase().getDatabase().isClosed())
    {
        throw new ImproperDatabaseException(""The database has been closed."");
    }
    if (this.getDatabase().getDatabase().isReadOnly())
    {
        throw new ImproperDatabaseException(""The database is in read-only mode."");
    }
    if (this.getDatabase().getDatabase().isInTransaction())
    {
        throw new ImproperDatabaseException(""The database is in a transaction."");
    }
}   ",1771,False
"/**
 * <p  align=""justify"" style=""width:60%"">
 * Removes a register operation type PreparedStatement-SQLQuery pair from the pool
 * for a given JTable. This pair holds both the PreparedStatement and the
 * Query specifics to assist in feeding the prepared statement with values.
 * This method will block when the pool is empty of prepared statements for
 * the specific type.
 * </p>
 * @param t the JTable for which a register type prepared statement is needed.
 * @return a PreparedStatement-SQLQuer pair of type Register for the given JTable.
 */
public Pair<PreparedStatement, SQLQuery> getRegister(JTable t){
    try {
        return register.get(t).take();
    } catch (InterruptedException ex) {
        return getRegister(t);
    }
}","/**
 * <p  align=""justify"" style=""width:60%"">
 * Removes a register operation type PreparedStatement-SQLQuery pair from the pool
 * for a given JTable. This pair holds both the PreparedStatement and the
 * Query specifics to assist in feeding the prepared statement with values.
 * This method will block when the pool is empty of prepared statements for
 * the specific type.
 * </p>
 * @param t the JTable for which a register type prepared statement is needed.
 * @return a PreparedStatement-SQLQuer pair of type Register for the given JTable.
 */
public Pair<PreparedStatement, SQLQuery> getRegister(JTable t) 
{
    Pair<PreparedStatement, SQLQuery> pair = null;
    try
    {
        pair = registerPool.get(t);
    }
    catch (InterruptedException e)
    {
        e.printStackTrace();
    }
    return pair;
}   ",1772,True
"/**
 * Removes an update operation type PreparedStatement-SQLQuery pair from the pool
 * for a given JTable. This pair holds both the PreparedStatement and the
 * Query specifics to assist in feeding the prepared statement with values.
 * This method will block when the pool is empty of prepared statements for
 * the specific type.
 * @param t the JTable for which an update type prepared statement is needed.
 * @return a PreparedStatement-SQLQuer pair of type Update for the given JTable.
 */
public Pair<PreparedStatement, SQLQuery> getUpdate(JTable t){
    try {
        return update.get(t).take();
    } catch (InterruptedException ex) {
        return getUpdate(t);
    }
}","/**
 * Removes an update operation type PreparedStatement-SQLQuery pair from the pool
 * for a given JTable. This pair holds both the PreparedStatement and the
 * Query specifics to assist in feeding the prepared statement with values.
 * This method will block when the pool is empty of prepared statements for
 * the specific type.
 * @param t the JTable for which an update type prepared statement is needed.
 * @return a PreparedStatement-SQLQuer pair of type Update for the given JTable.
 */
public Pair<PreparedStatement, SQLQuery> getUpdate(JTable t) 
{
    Pair<PreparedStatement, SQLQuery> pair = null;
    try
    {
        pair = updatePool.take();
    }
    catch (InterruptedException e)
    {
        e.printStackTrace();
    }
    return pair;
}   ",1776,True
"/**
 * Recycles a PreparedStatement-SQLQuery pair of register type in the pool,
 * after it's parameters are cleared. Use of this method is MANDATORY after
 * using getRegister method. If PreparedStatements are not recycled the system
 * will hang when the pool runs empty.
 * @param pair the Entry pair that needs recycling.
 * @param t the JTable in which the Entry belongs.
 */
public void recycleRegister(Pair<PreparedStatement, SQLQuery> pair, JTable t){
    try {
        pair.getKey().clearParameters();
        register.get(t).add(pair);
    } catch (SQLException ex) {
        throw new RuntimeException(ex);
    }
}","/**
 * Recycles a PreparedStatement-SQLQuery pair of register type in the pool,
 * after it's parameters are cleared. Use of this method is MANDATORY after
 * using getRegister method. If PreparedStatements are not recycled the system
 * will hang when the pool runs empty.
 * @param pair the Entry pair that needs recycling.
 * @param t the JTable in which the Entry belongs.
 */

public void recycleRegister(Pair<PreparedStatement, SQLQuery> pair, JTable t) 
{
    if (pair != null)
    {
        PreparedStatement ps = pair.getFirst();
        SQLQuery query = pair.getSecond();
        if (ps != null)
        {
            try
            {
                ps.clearParameters();
                ps.close();
            }
            catch (SQLException e)
            {
                e.printStackTrace();
            }
        }
        if (query != null)
        {
            query.close();
        }
    }
}   ",1777,True
"/**
 * Removes a search-primary-keys-only operation type PreparedStatement-SQLQuery pair from the pool
 * for a given JTable. This pair holds both the PreparedStatement and the
 * Query specifics to assist in feeding the prepared statement with values.
 * This method will block when the pool is empty of prepared statements for
 * the specific type.
 * @param t the JTable for which a search-primary-keys-only type prepared statement is needed.
 * @return a PreparedStatement-SQLQuer pair of type Search-primary-keys-only for the given JTable.
 */
public Pair<PreparedStatement, SQLQuery> getSearchPK(JTable t){
    try {
        return searchpk.get(t).take();
    } catch (InterruptedException ex) {
        return getSearchPK(t);
    }
}","/**
 * Removes a search-primary-keys-only operation type PreparedStatement-SQLQuery pair from the pool
 * for a given JTable. This pair holds both the PreparedStatement and the
 * Query specifics to assist in feeding the prepared statement with values.
 * This method will block when the pool is empty of prepared statements for
 * the specific type.
 * @param t the JTable for which a search-primary-keys-only type prepared statement is needed.
 * @return a PreparedStatement-SQLQuer pair of type Search-primary-keys-only for the given JTable.
 */
public Pair<PreparedStatement, SQLQuery> getSearchPK(JTable t) 
{
    Pair<PreparedStatement, SQLQuery> p = null;
    try
    {
        p = searchPKPool.take();
    }
    catch (InterruptedException e)
    {
        e.printStackTrace();
    }
    return p;
}   ",1778,True
"/**
 * <p  align=""justify"" style=""width:60%"">
 * Stops the connection and kills the Database server.
 * </p>
 */
public void stop(){
    connector.disconnect();
    connector.killServer();
    try {
        while (connector.isConnected() || connector.isServerRunning()) {
            Thread.sleep(100);
        }
        Thread.sleep(1000); // <== wait a little bit more
    } catch (InterruptedException ex) {
        throw new RuntimeException(""Interrupted while stopping..."", ex);
    }
}","/**
 * <p  align=""justify"" style=""width:60%"">
 * Stops the connection and kills the Database server.
 * </p>
 */
public void stop() 
{
    try
    {
        if (connection != null)
        {
            connection.close();
        }
    }
    catch (SQLException e)
    {
        e.printStackTrace();
    }
}   ",1779,False
"/**
 * Test what happens if we abandon the attempt to acquire a lock that ends
 * in a timeout, and then try again after the conflicting transaction
 * completes.  Note that we don't currently provide an API for doing this
 * in Darkstar.
 */
@Test
public void testLockAfterTimeout() throws Exception{
	init(1L, numKeyMaps);
	assertGranted(acquireLock(locker, ""o1"", true));
	Locker<String> locker2 = createLocker(lockManager);
	AcquireLock acquire2 = new AcquireLock(locker2, ""o1"", true);
	acquire2.assertBlocked();
	Thread.sleep(2);
	assertTimeout(acquire2.getResult(), locker);
	lockManager.releaseLock(locker, ""o1"");
	assertGranted(acquireLock(locker2, ""o1"", true));
}","/**
 * Test what happens if we abandon the attempt to acquire a lock that ends
 * in a timeout, and then try again after the conflicting transaction
 * completes.  Note that we don't currently provide an API for doing this
 * in Darkstar.
 */

@Test
public void testLockAfterTimeout() throws Exception 
{
    // Get a transaction manager
    TransactionManager mgr = Darkstar.getTransactionManager();

    // Create a new transaction
    Transaction tx = mgr.beginTransaction();

    // Create a lock
    Lock lock = tx.createLock(""test"");

    // Try to acquire the lock, which should time out
    try
    {
        lock.acquire(100);
        fail(""Lock should have timed out"");
    }
    catch (LockTimeoutException ex)
    {
        // Expected
    }

    // Create a new transaction
    Transaction tx2 = mgr.beginTransaction();

    // Commit the second transaction, which should release the lock
    tx2.commit();

    // Try to acquire the lock again, which should succeed
    lock.acquire(100);

    // Commit the first transaction
    tx.commit();
}   ",1780,True
"/**
 * Test read/write conflict
 *
 * locker2: read o1		=> granted
 * locker:  write o1	=> blocked
 * locker2: commit
 * locker:			=> granted
 */
@Test
public void testReadWriteConflict() throws Exception{
	Locker<String> locker2 = createLocker(lockManager);
	assertGranted(acquireLock(locker2, ""o1"", false));
	AcquireLock acquire = new AcquireLock(locker, ""o1"", true);
	acquire.assertBlocked();
	lockManager.releaseLock(locker2, ""o1"");
	assertGranted(acquire.getResult());
}","/**
 * Test read/write conflict
 *
 * locker2: read o1		=> granted
 * locker:  write o1	=> blocked
 * locker2: commit
 * locker:			=> granted
 */
@Test
public void testReadWriteConflict() throws Exception 
{
    final String LOCKER = ""locker"";
    final String LOCKER2 = ""locker2"";

    JdbcTestBase.prepareDatabase();

    final String o1 = ""o1"";

    Session s1 = JdbcTestBase.openSession(LOCKER);
    s1.getTransaction().begin();
    s1.persist(o1);
    s1.getTransaction().commit();
    s1.close();

    Session s2 = JdbcTestBase.openSession(LOCKER2);
    s2.getTransaction().begin();
    s2.find( Object.class, o1 );
    s2.getTransaction().commit();
    s2.close();

    Session s3 = JdbcTestBase.openSession(LOCKER);
    s3.getTransaction().begin();
    s3.find( Object.class, o1 );
    s3.getTransaction().commit();
    s3.close();
}   ",1783,True
"/**
 * {@inheritDoc} <p>
 *
 * This implementation does logging and calls {@link
 * #getLocalNodeIdInternal} to perform the actual operation.
 */
public long getLocalNodeId(){
	logger.log(FINEST, ""getLocalNodeId"");
	try {
	    long result = getLocalNodeIdInternal();
	    if (logger.isLoggable(FINEST)) {
		logger.log(
		    FINEST, ""getLocalNodeId returns nodeId:{0}"", result);
	    }
	    return result;
	} catch (RuntimeException e) {
	    throw handleException(null, FINEST, e, ""getLocalNodeId"");
	}
}","/**
 * {@inheritDoc} <p>
 *
 * This implementation does logging and calls {@link
 * #getLocalNodeIdInternal} to perform the actual operation.
 */
public long getLocalNodeId() 
{
    if (logger.isDebugEnabled())
    {
        logger.debug(""getLocalNodeId()"");
    }
    return getLocalNodeIdInternal();
}   ",1785,True
"/**
 * Reports access to what should be the next name after a given name.
 * Confirms that the next name is correct after obtaining access, repeating
 * the operation if the name has changed, and returning actual next name.
 * Note that the next name may change if the one obtained prior to checking
 * access was created by a transaction that aborts.
 *
 * @param	txn the transaction under which the operation should take place
 * @param	name the name, which may be {@code null}
 * @param	next the next name after {@code name}, which may be
 *		{@code null}
 * @param	accessType the type of access to the next name to report
 * @return	the actual next name, which may be {@code null}
 */
private String reportNextNameAccess(Transaction txn,
					String name,
					String next,
					AccessType accessType){
	while (true) {
	    reportNameAccess(txn, next, accessType);
	    String check = nextBoundNameInternal(txn, name);
	    if (check == null ? next == null : check.equals(next)) {
		return next;
	    }
	    next = check;
	}
}","/**
 * Reports access to what should be the next name after a given name.
 * Confirms that the next name is correct after obtaining access, repeating
 * the operation if the name has changed, and returning actual next name.
 * Note that the next name may change if the one obtained prior to checking
 * access was created by a transaction that aborts.
 *
 * @param	txn the transaction under which the operation should take place
 * @param	name the name, which may be {@code null}
 * @param	next the next name after {@code name}, which may be
 *		{@code null}
 * @param	accessType the type of access to the next name to report
 * @return	the actual next name, which may be {@code null}
 */
private String reportNextNameAccess(Transaction txn,
					String name,
					String next,
					AccessType accessType) 
{
	String actualNext = null;
	boolean done = false;
	while (!done) {
		try {
			actualNext = reportNextNameAccessInternal(txn, name, next, accessType);
			done = true;
		} catch (RetryException e) {
			// retry
		}
	}
	return actualNext;
}	",1786,True
"/**
 * {@inheritDoc} <p>
 *
 * This implementation does logging and calls {@link #shutdownInternal
 * shutdownInternal} to perform the actual operation.
 */
public void shutdown(){
	logger.log(FINER, ""shutdown"");
	try {
	    shutdownInternal();
	    logger.log(FINER, ""shutdown complete"");
	} catch (RuntimeException e) {
	    throw handleException(null, FINER, e, ""shutdown"");
	}
}","/**
 * {@inheritDoc} <p>
 *
 * This implementation does logging and calls {@link #shutdownInternal
 * shutdownInternal} to perform the actual operation.
 */
public void shutdown() 
{
    if (isShutdown())
    {
        return;
    }

    log.info(""Shutting down..."");

    shutdownInternal();

    log.info(""Shutdown complete."");
}   ",1789,True
"/* -- Test constructor -- */
@Test
public void testConstructorIllegalLockTimeout(){
	long[] values = { 0, -37 };
	for (long value : values) {
	    try {
		createLockManager(value, 1);
		fail(""Expected IllegalArgumentException"");
	    } catch (IllegalArgumentException e) {
		System.err.println(e);
	    }
	}
}","/* -- Test constructor -- */

@Test
public void testConstructorIllegalLockTimeout() 
{
    try
    {
        new LockTimeoutException(""illegal lock timeout"");
        fail(""Expected LockTimeoutException"");
    }
    catch (LockTimeoutException e)
    {
        assertEquals(""illegal lock timeout"", e.getMessage());
    }
}   ",1792,False
"/**
 * {@inheritDoc} <p>
 *
 * This implementation does logging, checks that {@code name} is not {@code
 * null}, reports name accesses, and calls {@link #getBindingInternal
 * getBindingInternal} to perform the actual operation.
 */
public long getBinding(Transaction txn, String name){
	if (logger.isLoggable(FINEST)) {
	    logger.log(FINEST, ""getBinding txn:{0}, name:{1}"", txn, name);
	}
	try {
	    checkNull(""name"", name);
	    /*
	     * Read lock the name even though we don't know yet if it is bound.
	     * Doing this means that the value we obtain, if there is one, will
	     * be known to be correct.
	     */
	    reportNameAccess(txn, name, READ);
	    BindingValue result = getBindingInternal(txn, name);
	    if (!result.isNameBound()) {
		/*
		 * Read lock the next name if the requested name is not bound
		 * to prevent a concurrent transaction from observing a
		 * different next name than this transaction would.
		 */
		reportNextNameAccess(txn, name, result.getNextName(), READ);
		throw new NameNotBoundException(""Name not bound: "" + name);
	    }
	    if (logger.isLoggable(FINEST)) {
		logger.log(FINEST,
			   ""getBinding txn:{0}, name:{1} returns "" +
			   ""oid:{2,number,#}"",
			   txn, name, result.getObjectId());
	    }
	    return result.getObjectId();
	} catch (RuntimeException e) {
	    throw handleException(
		txn, FINEST, e, ""getBinding txn:"" + txn + "", name:"" + name);
	}
}","/**
 * {@inheritDoc} <p>
 *
 * This implementation does logging, checks that {@code name} is not {@code
 * null}, reports name accesses, and calls {@link #getBindingInternal
 * getBindingInternal} to perform the actual operation.
 */
public long getBinding(Transaction txn, String name) 
{
    if (logger.isLoggable(Level.FINER))
        logger.entering(CLASS_NAME, ""getBinding"", txn);

    if (name == null)
    {
        throw new NullPointerException(""name cannot be null"");
    }

    long result = getBindingInternal(txn, name);

    if (logger.isLoggable(Level.FINER))
        logger.exiting(CLASS_NAME, ""getBinding"", result);

    return result;
}   ",1794,True
"/**
 * Test upgrade conflict with waiter
 *
 * locker:  read o1		=> granted
 * locker2: read o1		=> granted
 * locker3: write o1	=> blocked
 * locker2: write o1	=> blocked
 * locker:  commit
 * locker2:			=> blocked
 * locker3:			=> blocked
 */
@Test
public void testUpgradeWaiterConflict(){
	assertGranted(acquireLock(locker, ""o1"", false));
	Locker<String> locker2 = createLocker(lockManager);
	assertGranted(acquireLock(locker2, ""o1"", false));
	Locker<String> locker3 = createLocker(lockManager);
	AcquireLock acquire3 = new AcquireLock(locker3, ""o1"", true);
	acquire3.assertBlocked();
	AcquireLock acquire2 = new AcquireLock(locker2, ""o1"", true);
	acquire2.assertBlocked();
	lockManager.releaseLock(locker, ""o1"");
	acquire2.assertBlocked();
	acquire3.assertBlocked();
}","/**
 * Test upgrade conflict with waiter
 *
 * locker:  read o1		=> granted
 * locker2: read o1		=> granted
 * locker3: write o1	=> blocked
 * locker2: write o1	=> blocked
 * locker:  commit
 * locker2:			=> blocked
 * locker3:			=> blocked
 */
@Test
public void testUpgradeWaiterConflict() 
{
    Locker locker = new Locker();
    Locker locker2 = new Locker();
    Locker locker3 = new Locker();

    Object o1 = new Object();

    // locker:  read o1		=> granted
    locker.lockRead(o1);

    // locker2: read o1		=> granted
    locker2.lockRead(o1);

    // locker3: write o1	=> blocked
    locker3.lockWrite(o1);

    // locker2: write o1	=> blocked
    locker2.lockWrite(o1);

    // locker:  commit
    locker.commit();

    // locker2:			=> blocked
    locker2.lockWrite(o1);

    // locker3:			=> blocked
    locker3.lockWrite(o1);
}   ",1796,True
"//GEN-LAST:event_cancelActionPerformed
private void browseActionPerformed(java.awt.event.ActionEvent evt){//GEN-FIRST:event_browseActionPerformed
        // TODO add your handling code here:
        int returnVal = fc.showOpenDialog(decryptFrame.this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            file = fc.getSelectedFile();
            filename = """" + file;
            selectfile.setText(filename);
            //This is where a real application would open the file.
            //log.append(""Opening: "" + file.getName() + ""."" + newline);

        }
        // log.setCaretPosition(log.getDocument().getLength());
}","//GEN-LAST:event_cancelActionPerformed

private void browseActionPerformed(java.awt.event.ActionEvent evt) 
{
    JFileChooser fc = new JFileChooser();
    int returnVal = fc.showOpenDialog(this);
    if (returnVal == JFileChooser.APPROVE_OPTION)
    {
        File file = fc.getSelectedFile();
        path.setText(file.getAbsolutePath());
    }
}   ",1802,True
"/*
 * Get the extension of a file.
 */
public static String getExtension(File f){
    String ext = null;
    String s = f.getName();
    int i = s.lastIndexOf('.');

    if (i > 0 &&  i < s.length() - 1) {
        ext = s.substring(i+1).toLowerCase();
    }
    return ext;
}","/*
 * Get the extension of a file.
 */
public static String getExtension(File f) 
{
    String ext = null;
    String s = f.getName();
    int i = s.lastIndexOf('.');

    if (i > 0 &&  i < s.length() - 1)
    {
        ext = s.substring(i+1).toLowerCase();
    }
    return ext;
}   ",1813,True
"//GEN-LAST:event_jMenuItem2ActionPerformed
private void jButton1ActionPerformed(java.awt.event.ActionEvent evt){//GEN-FIRST:event_jButton1ActionPerformed
        try  {
                new encryptFrame().setVisible(true);
            } catch (Exception ex) {
                Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
            }

    }","//GEN-LAST:event_jMenuItem2ActionPerformed
private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) 
{
    if (evt.getSource() == jButton1)
    {
        if (jCheckBox1.isSelected())
        {
            jCheckBox1.setSelected(false);
        }
        else
        {
            jCheckBox1.setSelected(true);
        }
    }
}   ",1815,True
"/**
 * Size in bytes (divisible by 4 so word aligned)
 */
public Memory(int size, int start){
	mem = new Integer[(size / 4)];
	for(int i = 0; i < mem.length; i++) {
		mem[i] = null;
	}
	this.size = (size / 4);
	this.start = start;
	current = start;
}","/**
 * Size in bytes (divisible by 4 so word aligned)
 */
public Memory(int size, int start) 
{
    this.size = size;
    this.start = start;
    this.data = new byte[size];
}   ",1821,True
"/**
 * Read a hexidecimal string
 * Can't use parseInt because it fails for 8 character values
 * @param s String to be parsed
 * @return int value from inputed hexadecimal string
 * @throws NumberFormatException throws exception if not a true hex string
 */
public static int loadHex(String s) throws NumberFormatException{
	int full = 0;
	for(int i = 0; i < s.length(); i++) {
		int t = Integer.parseInt(s.charAt(i) + """", 16);
		full = full << 4;
		full = full | t;
	}
	return full;
}","/**
 * Read a hexidecimal string
 * Can't use parseInt because it fails for 8 character values
 * @param s String to be parsed
 * @return int value from inputed hexadecimal string
 * @throws NumberFormatException throws exception if not a true hex string
 */
public static int loadHex(String s) throws NumberFormatException 
{
    int value = 0;
    for (int i = 0; i < s.length(); i++)
    {
        char c = s.charAt(i);
        int digit = Character.digit(c, 16);
        if (digit == -1)
        {
            throw new NumberFormatException(""Invalid hex string: "" + s);
        }
        value = 16 * value + digit;
    }
    return value;
}   ",1822,True
"/**
 * Set a byte of memory to given value
 * @param start Location in memory to set
 * @param offset Offset from the start location
 * @param val 8 bit value to be saved
 */
public void setMemoryByte(int start, int offset, int val){
	val = Memory.getBitsFromVal(val, 0, 7, false);
	int word = getFromMemory(start+offset, 0);
	int byteOffset= (start+offset) % 4;
	word = (Memory.getBitsFromVal(word, 31-8*byteOffset, 31, false) << (31-8*byteOffset)) | (Memory.getBitsFromVal(word, 0, 7*(3-byteOffset), false));
	//word = Memory.getBitsFromVal(word, 8, 31, false) << 8;
	int newVal = word | (val<<(8*(3-byteOffset)));
	this.setMemory(start+offset, 0, newVal);
}","/**
 * Set a byte of memory to given value
 * @param start Location in memory to set
 * @param offset Offset from the start location
 * @param val 8 bit value to be saved
 */
public void setMemoryByte(int start, int offset, int val) 
{
    if (start + offset < 0 || start + offset > 0xFFFF)
        throw new IllegalArgumentException(""Address out of range"");

    memory[start + offset] = (byte) (val & 0xFF);
}   ",1824,False
"/**
 * Display command help
 */
private void outputHelp(){
	out(""p [#/HI/LO/PC/all] - print registers either specific #, hi, lo, pc, or all registers"");
	out(""d [#/data/stack] - print memory at specific location, default takes a decimal int\n\t-h : take in hex\n\t-oh : output hex\n\t-ob : output binary"");
	out(""s # - execute next # instructions (# is decimal)"");
	out(""q - quit"");
}","/**
 * Display command help
 */
private void outputHelp() 
{
    System.out.println(""Usage: java -jar <jarfile> <command> [options]"");
    System.out.println(""Available commands:"");
    for (Command command : Command.values())
    {
        System.out.println(""  "" + command.getName() + "": "" + command.getDescription());
    }
    System.out.println(""Use \""java -jar <jarfile> <command> -h\"" for more information about a specific command."");
}   ",1825,False
"//Constructor - all executed during object instantiation
public MIPSEmulator(String s){
	reg = new Register();
	data = new DataSegment();
	instr = new TextSegment();
	stack = new StackSegment();
	
	clrscr();
	
	try {
		if(s.equals(""""))
			s = getUserInput(""Name of your file: "");
		loadFile(s);
	} catch (IOException e) {
		out(""failed loading file"");
		return;
	}
	
	//Initialize register values
	reg.pc = instr.getStart();
	reg.set(29, 0x7FFFEFFC); //initialize $sp
	reg.set(31, -1); // $ra so as to know when to end the program (on jr -1)
	reg.set(28, 0x10011000); // set $gp
	reg.set(30, 0x7FFFEFFC); // set $fp (not sure if right but never really used)
	
	
	String opt = getUserInput(""Single step (s) or run to complete (c): "");
	if(opt.toLowerCase().charAt(0) == 's') {
		singleStep();
	} else {
		runToCompletion();
	}
	
}","//Constructor - all executed during object instantiation
public MIPSEmulator(String s) 
{
    //Initialize the registers
    for(int i = 0; i < 32; i++)
    {
        registers[i] = 0;
    }

    //Initialize the memory
    for(int i = 0; i < 1024; i++)
    {
        memory[i] = 0;
    }

    //Initialize the PC
    PC = 0;

    //Load the program into memory
    loadProgram(s);
}   ",1826,False
"/**
 * Read 8 bits from memory
 * @param start Memory location
 * @param offset Optional offset from memory location
 * @param signed Take the byte as a signed or unsigned value
 * @return the value at the given location byte is returned as an int
 */
public int getMemoryByte(int start, int offset, boolean signed){
	int word = getFromMemory(start, offset);
	int byteOffset = (start+offset) % 4;
	int val = Memory.getBitsFromVal(word,24-8*byteOffset,31-8*byteOffset, signed);
	return val;
}","/**
 * Read 8 bits from memory
 * @param start Memory location
 * @param offset Optional offset from memory location
 * @param signed Take the byte as a signed or unsigned value
 * @return the value at the given location byte is returned as an int
 */
public int getMemoryByte(int start, int offset, boolean signed) 
{
    int value = 0;
    if (signed)
    {
        value = memory[start+offset];
    }
    else
    {
        value = memory[start+offset] & 0xFF;
    }
    return value;
}   ",1827,True
"/**
 * Add a value to the next available spot in memory
 * @param o value to add
 */
public void add(int o){
	for(int i = 0; i < mem.length; i++) {
		if(mem[i] != null) continue;
		else {
			mem[i] = o;
			return;
		}
	}
	throwOverflowError();
}","/**
 * Add a value to the next available spot in memory
 * @param o value to add
 */
public void add(int o) 
{
    if (next < memory.length)
    {
        memory[next] = o;
        next++;
    }
    else
    {
        System.out.println(""Memory is full"");
    }
}   ",1829,False
"/**
 * Gets the 4 bytes at given memory location
 * This assumes word aligned (4 bytes asked for can not span across two words)
 * @param loc Memory location
 * @return 32 bits (4 bytes) at that location
 */
public int get(Integer loc){
	if(mem[getRealLoc(loc)] == null)
		return 0;
	return mem[getRealLoc(loc)];
}","/**
 * Gets the 4 bytes at given memory location
 * This assumes word aligned (4 bytes asked for can not span across two words)
 * @param loc Memory location
 * @return 32 bits (4 bytes) at that location
 */
public int get(Integer loc) 
{
    int value = 0;
    for (int i = 0; i < 4; i++)
    {
        value = (value << 8) | (memory[loc + i] & 0xFF);
    }
    return value;
}   ",1830,True
"/**
 * Get specific bits from a memory location
 * @param loc Memory location to pull from
 * @param start starting bit value
 * @param end end bit value
 * @param signed Boolean for whether or not to sign extend
 * @return Requested bits in an int
 */
public int getBits(int loc, int start, int end, boolean signed){
	if(start > end) {
		int temp = end;
		end = start;
		start = temp;
	}
	int val = mem[getRealLoc(loc)];
	return getBitsFromVal(val, start, end, signed);
}","/**
 * Get specific bits from a memory location
 * @param loc Memory location to pull from
 * @param start starting bit value
 * @param end end bit value
 * @param signed Boolean for whether or not to sign extend
 * @return Requested bits in an int
 */
public int getBits(int loc, int start, int end, boolean signed) 
{
    int length = end - start + 1;
    int mask = (1 << length) - 1;
    int value = (memory[loc] >> start) & mask;
    if (signed && value >= (1 << (length - 1))) {
        value -= (1 << length);
    }
    return value;
}   ",1831,True
"/**
 * Parse instruction input if it is command involving memory
 * @param instruction input from user
 * @return boolean for if there was an error in the command
 */
private boolean dInstruction(String instruction){
	if(instruction.length() <= 2) return false;
	String[] parts = instruction.split(""\\s+"");
	if(parts.length < 2) return false;
	int location = 0;
	String address = parts[parts.length-1];
	boolean inputHex = false;
	int output = 0; //0 is decimal, 1 is binary, 2 is hex;
	for(int i = 1; i < parts.length-1; i++) {
		if(parts[i].equals(""-h""))
			inputHex = true;
		if(parts[i].equals(""-oh""))
			output = 2;
		if(parts[i].equals(""-ob""))
			output = 1;
	}
	if(address.equals(""stack"")) {
		this.stack.printAll();
		return true;
	}else if (address.equals(""data"")) {
		this.data.printAll();
		return true;
	} else if(inputHex) {
		try {
			if(address.startsWith(""0x""))
				address = address.substring(2);
			location = loadHex(address);
			address = ""0x""+address;
		} catch (NumberFormatException e) {
			return false;
		}
	} else {
		try{
			location = Integer.parseInt(address);
		} catch (NumberFormatException e) {
			return false;
		}
	}
	String out = """";
	if(output == 0)
		out = getFromMemory(location, 0) + """";
	else if (output == 1)
		out = Integer.toBinaryString(getFromMemory(location, 0));
	else if (output == 2)
		out = ""0x""+MIPSEmulator.formatHex(getFromMemory(location, 0));
	System.out.println(""MEM[ "" + address + "" ] = "" + out);
	return true;
}","/**
 * Parse instruction input if it is command involving memory
 * @param instruction input from user
 * @return boolean for if there was an error in the command
 */
private boolean dInstruction(String instruction) 
{
    String[] split = instruction.split("" "");
    if (split.length == 2)
    {
        String command = split[0];
        String value = split[1];
        if (command.equalsIgnoreCase(""d""))
        {
            return dCommand(value);
        }
    }
    return false;
}   ",1835,False
"/**
 * Static function to get specific bits from a given value
 * @param val Value to take bits from
 * @param start starting bit value
 * @param end ending bit value
 * @param signed boolean for whether or not to sign extend
 * @return requested bits as an int
 */
public static int getBitsFromVal(int val, int start, int end,  boolean signed){
	int max = 0xFFFFFFFF;
	int mask = (max >>> (31-end)) & (max << start);
	val = val & mask;
	if(signed) {
		val = val << (31 - end);
		return val >> (start + (31-end));
	}
	return val >>> start;
}","/**
 * Static function to get specific bits from a given value
 * @param val Value to take bits from
 * @param start starting bit value
 * @param end ending bit value
 * @param signed boolean for whether or not to sign extend
 * @return requested bits as an int
 */
public static int getBitsFromVal(int val, int start, int end,  boolean signed) 
{
    int length = end - start + 1;
    int mask = (1 << length) - 1;
    int result = (val >> start) & mask;
    if (signed && result > (1 << (length - 1)) - 1)
    {
        result -= 1 << length;
    }
    return result;
}   ",1837,True
"/**
 * Print all memory locations with a value that is not 0 or null.
 */
public void printAll(){
	for(int i = 0; i < mem.length; i++) {
		if(mem[i] != null && mem[i] != 0) {
			int loc = i*4 + start;
			System.out.println(""0x""+MIPSEmulator.formatHex(loc).toUpperCase()+"": 0x""+MIPSEmulator.formatHex(mem[i]).toUpperCase());
		}
	}
}","/**
 * Print all memory locations with a value that is not 0 or null.
 */
public void printAll() 
{
    for (int i = 0; i < memory.length; i++)
    {
        if (memory[i] != 0 && memory[i] != null)
        {
            System.out.println(""Memory location "" + i + "": "" + memory[i]);
        }
    }
}   ",1838,True
"/**
 * Command used to keep screen cleared except for current and last command.
 */
private void clrscr(){
	for(int i = 0; i < 100; i++) {
		out(""\n"");
	}
}","/**
 * Command used to keep screen cleared except for current and last command.
 */
private void clrscr() 
{
    try
    {
        if (System.getProperty(""os.name"").contains(""Windows""))
        {
            new ProcessBuilder(""cmd"", ""/c"", ""cls"").inheritIO().start().waitFor();
        }
        else
        {
            Runtime.getRuntime().exec(""clear"");
        }
    }
    catch (IOException | InterruptedException ex)
    {
    }
}   ",1839,True
"/**
 * Configures threshold and interval
 * And registers a listener and start listening
 * @param accelerometerListener
 * 			callback for accelerometer events
 * @param threshold
 * 			minimum acceleration variation for considering shaking
 * @param interval
 * 			minimum interval between to shake events
 */
public static void startListening(
		AccelerometerListener accelerometerListener, 
		int threshold, int interval){
	configure(threshold, interval);
	startListening(accelerometerListener);
}","/**
 * Configures threshold and interval
 * And registers a listener and start listening
 * @param accelerometerListener
 * 			callback for accelerometer events
 * @param threshold
 * 			minimum acceleration variation for considering shaking
 * @param interval
 * 			minimum interval between to shake events
 */
public static void startListening(
		AccelerometerListener accelerometerListener, 
		int threshold, int interval) 
{
	AccelerometerManager.startListening(
			accelerometerListener,
			threshold,
			interval);
}	",1840,True
"/**
 * Create the custom dialog
 */
public CustomDialog create(){
    LayoutInflater inflater = (LayoutInflater) context
            .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    // instantiate the dialog with the custom Theme
    final CustomDialog dialog = new CustomDialog(context, 
    		R.style.Dialog);
    View layout = inflater.inflate(R.layout.dialog, null);
    dialog.addContentView(layout, new LayoutParams(
            LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT));
    // set the dialog title
    ((TextView) layout.findViewById(R.id.title)).setText(title);
    // set the confirm button
    if (positiveButtonText != null) {
        ((Button) layout.findViewById(R.id.positiveButton))
                .setText(positiveButtonText);
        if (positiveButtonClickListener != null) {
            ((Button) layout.findViewById(R.id.positiveButton))
                    .setOnClickListener(new View.OnClickListener() {
                        public void onClick(View v) {
                            positiveButtonClickListener.onClick(
                            		dialog, 
                                    DialogInterface.BUTTON_POSITIVE);
                        }
                    });
        }
    } else {
        // if no confirm button just set the visibility to GONE
        layout.findViewById(R.id.positiveButton).setVisibility(
                View.GONE);
    }
    // set the cancel button
    if (negativeButtonText != null) {
        ((Button) layout.findViewById(R.id.negativeButton))
                .setText(negativeButtonText);
        if (negativeButtonClickListener != null) {
            ((Button) layout.findViewById(R.id.negativeButton))
                    .setOnClickListener(new View.OnClickListener() {
                        public void onClick(View v) {
                            positiveButtonClickListener.onClick(
                            		dialog, 
                                    DialogInterface.BUTTON_NEGATIVE);
                        }
                    });
        }
    } else {
        // if no confirm button just set the visibility to GONE
        layout.findViewById(R.id.negativeButton).setVisibility(
                View.GONE);
    }
    // set the content message
    if (message != null) {
        ((TextView) layout.findViewById(
        		R.id.message)).setText(message);
    } else if (contentView != null) {
        // if no message set
        // add the contentView to the dialog body
        ((LinearLayout) layout.findViewById(R.id.content))
                .removeAllViews();
        ((LinearLayout) layout.findViewById(R.id.content))
                .addView(contentView, 
                        new LayoutParams(
                                LayoutParams.WRAP_CONTENT, 
                                LayoutParams.WRAP_CONTENT));
    }
    dialog.setContentView(layout);
    return dialog;
}","/**
 * Create the custom dialog
 */
public CustomDialog create() 
{
    AlertDialog.Builder builder = new AlertDialog.Builder(activity);
    builder.setTitle(title);
    builder.setMessage(message);
    builder.setCancelable(false);
    builder.setPositiveButton(""OK"", new DialogInterface.OnClickListener() {
        @Override
        public void onClick(DialogInterface dialog, int which) {
            dialog.dismiss();
        }
    });
    return builder.create();
}   ",1841,False
"/**
 * Set the positive button resource and it's listener
 * @param positiveButtonText
 * @param listener
 * @return
 */
public Builder setPositiveButton(int positiveButtonText,
        DialogInterface.OnClickListener listener){
    this.positiveButtonText = (String) context
            .getText(positiveButtonText);
    this.positiveButtonClickListener = listener;
    return this;
}","/**
 * Set the positive button resource and it's listener
 * @param positiveButtonText
 * @param listener
 * @return
 */
public Builder setPositiveButton(int positiveButtonText,
        DialogInterface.OnClickListener listener) 
{
    mBuilder.setPositiveButton(positiveButtonText, listener);
    return this;
}       ",1842,True
"/**
 * Set the Dialog message from String
 * @param title
 * @return
 */
public Builder setMessage(String message){
    this.message = message;
    return this;
}","/**
 * Set the Dialog message from String
 * @param title
 * @return
 */
public Builder setMessage(String message) 
{
    if (message != null)
    {
        this.message = message;
    }
    return this;
}   ",1844,True
"/**
 * Set the Dialog title from resource
 * @param title
 * @return
 */
public Builder setTitle(int title){
    this.title = (String) context.getText(title);
    return this;
}","/**
 * Set the Dialog title from resource
 * @param title
 * @return
 */
public Builder setTitle(int title) 
{
    this.title = this.context.getResources().getString(title);
    return this;
}   ",1853,True
"/**
 * Unregisters listeners
 */
public static void stopListening(){
	running = false;
	try {
		if (sensorManager != null && sensorEventListener != null) {
			sensorManager.unregisterListener(sensorEventListener);
		}
	} catch (Exception e) {}
}","/**
 * Unregisters listeners
 */
public static void stopListening() 
{
    if (mSensorManager != null)
    {
        mSensorManager.unregisterListener(this);
        mSensorManager = null;
    }
}   ",1854,True
"/**
 * Set the negative button resource and it's listener
 * @param negativeButtonText
 * @param listener
 * @return
 */
public Builder setNegativeButton(int negativeButtonText,
        DialogInterface.OnClickListener listener){
    this.negativeButtonText = (String) context
            .getText(negativeButtonText);
    this.negativeButtonClickListener = listener;
    return this;
}","/**
 * Set the negative button resource and it's listener
 * @param negativeButtonText
 * @param listener
 * @return
 */
public Builder setNegativeButton(int negativeButtonText,
        DialogInterface.OnClickListener listener) 
{
    P.negativeButtonText = P.context.getText(negativeButtonText);
    P.negativeButtonListener = listener;
    return this;
}       ",1855,True
"/**
 * Set the negative button text and it's listener
 * @param negativeButtonText
 * @param listener
 * @return
 */
public Builder setNegativeButton(String negativeButtonText,
        DialogInterface.OnClickListener listener){
    this.negativeButtonText = negativeButtonText;
    this.negativeButtonClickListener = listener;
    return this;
}","/**
 * Set the negative button text and it's listener
 * @param negativeButtonText
 * @param listener
 * @return
 */
public Builder setNegativeButton(String negativeButtonText,
        DialogInterface.OnClickListener listener) 
{
    P.negativeButtonText = negativeButtonText;
    P.negativeButtonListener = listener;
    return this;
}       ",1856,True
"/**
 * Returns true if at least one Accelerometer sensor is available
 */
public static boolean isSupported(){
	if (supported == null) {
		if (Accelerometer.getContext() != null) {
			sensorManager = (SensorManager) Accelerometer.getContext().
					getSystemService(Context.SENSOR_SERVICE);
			List<Sensor> sensors = sensorManager.getSensorList(
					Sensor.TYPE_ACCELEROMETER);
			supported = new Boolean(sensors.size() > 0);
		} else {
			supported = Boolean.FALSE;
		}
	}
	return supported;
}","/**
 * Returns true if at least one Accelerometer sensor is available
 */

public static boolean isSupported() 
{
    return SensorManager.getSensorList(Sensor.TYPE_ACCELEROMETER).size() > 0;
}   ",1857,True
"/**
 * Set the Dialog message from resource
 * @param title
 * @return
 */
public Builder setMessage(int message){
    this.message = (String) context.getText(message);
    return this;
}","/**
 * Set the Dialog message from resource
 * @param title
 * @return
 */
public Builder setMessage(int message) 
{
    this.message = context.getResources().getString(message);
    return this;
}   ",1858,True
"/**
 * Configure the listener for shaking
 * @param threshold
 * 			minimum acceleration variation for considering shaking
 * @param interval
 * 			minimum interval between to shake events
 */
public static void configure(int threshold, int interval){
	AccelerometerManager.threshold = threshold;
	AccelerometerManager.interval = interval;
}","/**
 * Configure the listener for shaking
 * @param threshold
 * 			minimum acceleration variation for considering shaking
 * @param interval
 * 			minimum interval between to shake events
 */
public static void configure(int threshold, int interval) 
{
    ShakeListener.threshold = threshold;
    ShakeListener.interval = interval;
}   ",1859,True
"/** Jumps the camera to the specified position */
public void jump(float positionX, float positionY, float positionZ){



    // Move the camera

    this.cameraX = positionX;

    this.cameraY = positionY;

    this.cameraZ = positionZ;



    // Describe the new vector between the camera and the target

    dx = cameraX - targetX;

    dy = cameraY - targetY;

    dz = cameraZ - targetZ;



    // Describe the new azimuth and elevation for the camera

    shotLength = sqrt(dx * dx + dy * dy + dz * dz);

    azimuth    = atan2(dx, dz);

    elevation  = constrain(atan2(dy, sqrt(dz * dz + dx * dx)), TOL-HALF_PI, HALF_PI-TOL);

    

    // update the up vector

    updateUp();

}","/** Jumps the camera to the specified position */
public void jump(float positionX, float positionY, float positionZ) 
{
    camera.position.set(positionX, positionY, positionZ);
    camera.lookAt(0, 0, 0);
    camera.update();
}   ",1861,False
"// I mean it! Give me the controls already!
public OCDCamera(PApplet parent,

              float cameraX, float cameraY, float cameraZ,

              float targetX, float targetY, float targetZ,

              float upX,     float upY,     float upZ,

              float fov, float aspect, float nearClip, float farClip){

    this.parent = parent;

    this.cameraX = cameraX;

    this.cameraY = cameraY;

    this.cameraZ = cameraZ;

    this.targetX = targetX;

    this.targetY = targetY;

    this.targetZ = targetZ;

    this.upX = upX;

    this.upY = upY;

    this.upZ = upZ;

    this.fov = fov;

    this.aspect = aspect;

    this.nearClip = nearClip;

    this.farClip = farClip;

    

    dx = cameraX - targetX;

    dy = cameraY - targetY;

    dz = cameraZ - targetZ;

    

    shotLength = sqrt(dx * dx + dy * dy + dz * dz);

    azimuth    = atan2(dx, dz);

    elevation  = atan2(dy, sqrt(dz * dz + dx * dx));

    

    if (elevation > HALF_PI - TOL) {

      this.upY =  0;

      this.upZ = -1;

    }



    if (elevation < TOL - HALF_PI) {

      this.upY =  0;

      this.upZ =  1;

    }

}","// I mean it! Give me the controls already!
public OCDCamera(PApplet parent,

              float cameraX, float cameraY, float cameraZ,

              float targetX, float targetY, float targetZ,

              float upX,     float upY,     float upZ,

              float fov, float aspect, float nearClip, float farClip) 
{
    this.parent = parent;

    this.cameraX = cameraX;
    this.cameraY = cameraY;
    this.cameraZ = cameraZ;

    this.targetX = targetX;
    this.targetY = targetY;
    this.targetZ = targetZ;

    this.upX = upX;
    this.upY = upY;
    this.upZ = upZ;

    this.fov = fov;
    this.aspect = aspect;
    this.nearClip = nearClip;
    this.farClip = farClip;
}   ",1863,True
"// ================================================== 
// Super Fast Blur v1.1 
// by Mario Klingemann  
// <http://incubator.quasimondo.com> 
// ================================================== 
public void fastblur(PImage img,int radius){ 
 if (radius<1){ 
    return; 
  } 
  int w=img.width; 
  int h=img.height; 
  int wm=w-1; 
  int hm=h-1; 
  int wh=w*h; 
  int div=radius+radius+1; 
  int r[]=new int[wh]; 
  int g[]=new int[wh]; 
  int b[]=new int[wh]; 
  int rsum,gsum,bsum,x,y,i,p,p1,p2,yp,yi,yw; 
  int vmin[] = new int[max(w,h)]; 
  int vmax[] = new int[max(w,h)]; 
  int[] pix=img.pixels; 
  int dv[]=new int[256*div]; 
  for (i=0;i<256*div;i++){ 
    dv[i]=(i/div); 
  } 
 
  yw=yi=0; 
 
  for (y=0;y<h;y++){ 
    rsum=gsum=bsum=0; 
    for(i=-radius;i<=radius;i++){ 
      p=pix[yi+min(wm,max(i,0))]; 
      rsum+=(p & 0xff0000)>>16; 
      gsum+=(p & 0x00ff00)>>8; 
      bsum+= p & 0x0000ff; 
    } 
    for (x=0;x<w;x++){ 
 
      r[yi]=dv[rsum]; 
      g[yi]=dv[gsum]; 
      b[yi]=dv[bsum]; 
 
      if(y==0){ 
        vmin[x]=min(x+radius+1,wm); 
        vmax[x]=max(x-radius,0); 
      } 
      p1=pix[yw+vmin[x]]; 
      p2=pix[yw+vmax[x]]; 
 
      rsum+=((p1 & 0xff0000)-(p2 & 0xff0000))>>16; 
      gsum+=((p1 & 0x00ff00)-(p2 & 0x00ff00))>>8; 
      bsum+= (p1 & 0x0000ff)-(p2 & 0x0000ff); 
      yi++; 
    } 
    yw+=w; 
  } 
 
  for (x=0;x<w;x++){ 
    rsum=gsum=bsum=0; 
    yp=-radius*w; 
    for(i=-radius;i<=radius;i++){ 
      yi=max(0,yp)+x; 
      rsum+=r[yi]; 
      gsum+=g[yi]; 
      bsum+=b[yi]; 
      yp+=w; 
    } 
    yi=x; 
    for (y=0;y<h;y++){ 
      pix[yi]=0xff000000 | (dv[rsum]<<16) | (dv[gsum]<<8) | dv[bsum]; 
      if(x==0){ 
        vmin[y]=min(y+radius+1,hm)*w; 
        vmax[y]=max(y-radius,0)*w; 
      } 
      p1=x+vmin[y]; 
      p2=x+vmax[y]; 
 
      rsum+=r[p1]-r[p2]; 
      gsum+=g[p1]-g[p2]; 
      bsum+=b[p1]-b[p2]; 
 
      yi+=w; 
    } 
  } 
 
}","// ================================================== 
// Super Fast Blur v1.1 
// by Mario Klingemann  
// <http://incubator.quasimondo.com> 
// ================================================== 
public void fastblur(PImage img,int radius) 
{
  if (radius<1){
    return;
  }
  int w=img.width;
  int h=img.height;
  int wm=w-1;
  int hm=h-1;
  int[][] r=new int[h][w];
  int[][] g=new int[h][w];
  int[][] b=new int[h][w];
  int[][] a=new int[h][w];
  int ci, x, y, xi, yi, ri, gi, bi, ai;
  for (y=0;y<h;y++){
    for (x=0;x<w;x++){
      ci=img.pixels[x+y*w];
      a[y][x]=(ci>>24)&0xff;
      r[y][x]=(ci>>16)&0xff;
      g[y][x]=(ci>>8)&0xff;
      b[y][x]=ci&0xff;
    }
  }
  for (y=0;y<h;y++){
    for (x=0;x<w;x++){
      ri=gi=bi=ai=0;
      for (yi=y-radius;yi<=y+radius;yi++){
        for (xi=x-radius;xi<=x+radius;xi++){
          if (xi>=0&&xi<=wm&&yi>=0&&yi<=hm){
            ri+=r[yi][xi];
            gi+=g[yi][xi];
            bi+=b[yi][xi];
            ai+=a[yi][xi];
          }
        }
      }
      ci=(ai/(radius*radius+1))<<24|
        (ri/(radius*radius+1))<<16|
        (gi/(radius*radius+1))<<8|
        (bi/(radius*radius+1));
      img.pixels[x+y*w]=ci;
    }
  }
}   ",1864,True
"// ================================================== 
// captureEvent() 
// ================================================== 
public void captureEvent(Capture cam){ 
	cam.read(); 
        aboveThreshold = new ArrayList();
        clusters = new ArrayList();
              smartPixel[][] newPixels = new smartPixel[cam.width][cam.height];
              int redthresh=50;
              int bluethresh=100;
              int greenthresh=100;
              int pointx=0;
              int pointy=0;
              int numpoints=0;
              double z;
              double f0=12;
              double k=1/14.0f;
              for(int i=0;i<cam.width*cam.height;i++)
               {
                  if((red(cam.pixels[i])<redthresh)||(blue(cam.pixels[i])<bluethresh)||(green(cam.pixels[i])<greenthresh)){
                      cam.pixels[i]=color(0,0,0);
                      newPixels[i%cam.width][i/cam.width] = new smartPixel(null, color(0,0,0), i%cam.width, i/cam.width);
               }else{
                     int xpos = (i%cam.width);
                     int ypos = (i/cam.width);
                     pointx+=(i%cam.width);
                     pointy+=(i/cam.width);
                     numpoints++;
                     
                     smartPixel newp = new smartPixel(null, color(255,255,255), xpos, ypos);
                     
                     if (xpos > 0) {
                       smartPixel p1 = newPixels[xpos-1][ypos];
                     
                       if (p1.c == color(255,255,255)) {
                        
                           p1.clust.sm.add(newp);
                           newp.clust = p1.clust;
                           p1.clust.centerx = (p1.clust.centerx*p1.clust.sm.size()+newp.x)/(p1.clust.sm.size()+1);
                           p1.clust.centery = (p1.clust.centery*p1.clust.sm.size()+newp.y)/(p1.clust.sm.size()+1);
                         
                       }
                     }
                     if (ypos > 0 && xpos >0) {
                       smartPixel p2 = newPixels[xpos-1][ypos-1];
                       if (p2.c == color(255,255,255)) {
                         if(newp.clust != null) {
                           unionClusters(newp.clust, p2.clust);
                         } else {
                           p2.clust.sm.add(newp);
                           newp.clust = p2.clust;
                           p2.clust.centerx = (p2.clust.centerx*p2.clust.sm.size()+newp.x)/(p2.clust.sm.size()+1);
                           p2.clust.centery = (p2.clust.centery*p2.clust.sm.size()+newp.y)/(p2.clust.sm.size()+1);
                         }
                       }
                     }
                     if (ypos > 0) {
                       smartPixel p3 = newPixels[xpos][ypos-1];
                       if (p3.c == color(255,255,255)) {
                         if(newp.clust != null) {
                           unionClusters(newp.clust, p3.clust);
                         } else {
                           p3.clust.sm.add(newp);
                           newp.clust = p3.clust;
                           p3.clust.centerx = (p3.clust.centerx*p3.clust.sm.size()+newp.x)/(p3.clust.sm.size()+1);
                           p3.clust.centery = (p3.clust.centery*p3.clust.sm.size()+newp.y)/(p3.clust.sm.size()+1);
                         }
                       }
                     }
                     if(newp.clust == null) {
                       cluster newc = new cluster(newp);
                       clusters.add(newc);
                       newp.clust = newc;
                     }
                     newPixels[xpos][ypos] = newp;
                     aboveThreshold.add(newp);
                     
                     //cam.pixels[i]=color(255,255,255);
                     
                  }
               }
               /*
               if(numpoints!=0)
               {
               pointx=pointx/numpoints;
               pointy=pointy/numpoints;
               }
               
               cam.pixels[pointx+pointy*cam.width]=color(255,0,0);
               if(pointx<(cam.width/2))
                 z=f0-k*((cam.width/2)-(double)pointx);
              else
                z=f0+k*((double)pointx-(cam.width/2));
                println(""POINT: "" + pointx);
                println(z);
                */
                for(int q=0;q<clusters.size();++q) {
                  cluster cc  = (cluster) clusters.get(q);
                  cam.pixels[PApplet.parseInt(cc.centery)*cam.width+PApplet.parseInt(cc.centerx)] = color(255,0,0); 
                  println(cc.sm.size());
                }
	newFrame = true; 
}","// ================================================== 
// captureEvent() 
// ==================================================
public void captureEvent(Capture cam) 
{
    if (cam.isOpened())
    {
        cam.read(image);
        if (!image.empty())
        {
            cvFlip(image, image, 1);
            cvtColor(image, image, CV_BGR2RGB);
            ImageIcon imageIcon = new ImageIcon(image.getBufferedImage());
            label.setIcon(imageIcon);
        }
    }
}   ",1865,False
"// ================================================== 
// setup() 
// ================================================== 
public void setup(){ 
	// Size of applet 
	size(320, 240); 
	// Capture 
	cam = new Capture(this, 320, 240, 15); 
	// BlobDetection 
	// img which will be sent to detection (a smaller copy of the cam frame); 
	img = new PImage(320,240);  
	//theBlobDetection = new BlobDetection(img.width, img.height); 
	//theBlobDetection.setPosDiscrimination(true); 
	//theBlobDetection.setThreshold(0.2f); // will detect bright areas whose luminosity > 0.2f; 
      clusters = new ArrayList();
}","// ================================================== 
// setup() 
// ================================================== 
public void setup() 
{
    size(800, 600, P3D);
    frameRate(30);
    smooth();

    // init
    for (int i = 0; i < NUM; i++)
    {
        x[i] = random(-100, 100);
        y[i] = random(-100, 100);
        z[i] = random(-100, 100);
    }
}   ",1866,False
"/** Rotates the camera about its Z axis

 *  NOTE: rolls will NOT affect the azimuth, but WILL affect plans, trucks, and booms

 */
public void roll(float amount){

    // Change the roll amount

    roll += amount;

    

    // Update the up vector

    updateUp();

}","/** Rotates the camera about its Z axis

 *  NOTE: rolls will NOT affect the azimuth, but WILL affect plans, trucks, and booms

 */
public void roll(float amount) 
{
    if (amount == 0)
    {
        return;
    }
    float newRoll = this.roll + amount;
    if (newRoll > 360)
    {
        newRoll -= 360;
    }
    else if (newRoll < 0)
    {
        newRoll += 360;
    }
    this.roll = newRoll;
}   ",1868,True
"/** Arcs the camera over (under) a center of interest along a set azimuth*/
public void arc(float elevationOffset){



    // Calculate the new elevation for the camera

    elevation = constrain(elevation + elevationOffset, TOL-HALF_PI, HALF_PI-TOL);



    // Orbit to the new azimuth and elevation while maintaining the shot distance

    cameraX = targetX + ( shotLength * sin(HALF_PI + elevation) * sin(azimuth));

    cameraY = targetY + (-shotLength * cos(HALF_PI + elevation));

    cameraZ = targetZ + ( shotLength * sin(HALF_PI + elevation) * cos(azimuth));



    // update the up vector

    updateUp();

}","/** Arcs the camera over (under) a center of interest along a set azimuth*/
public void arc(float elevationOffset) 
{
    if (elevationOffset == 0)
    {
        return;
    }

    float[] center = getCenterOfInterest();

    if (center == null)
    {
        return;
    }

    float[] lookAt = new float[3];
    getLookAtPoint(lookAt);

    float[] up = new float[3];
    getUpVector(up);

    float[] eye = new float[3];
    getEyePoint(eye);

    float[] newEye = new float[3];
    float[] newLookAt = new float[3];
    float[] newUp = new float[3];

    computeNewObservationPoint(elevationOffset, eye, lookAt, up, newEye, newLookAt, newUp);

    setEyePoint(newEye);
    setLookAtPoint(newLookAt);
    setUpVector(newUp);
}   ",1873,True
"/** Moves the camera and target simultaneously along the camera's X axis */
public void truck(float amount){



    // Calculate the camera's ""X"" vector

    float cXx = dy * upZ - dz * upY;

    float cXy = dx * upZ - dz * upX;

    float cXz = dx * upY - dy * upX;



    // Normalize the ""X"" vector so that it can be scaled

    float magnitude = sqrt(cXx * cXx + cXy * cXy + cXz * cXz);

    magnitude = (magnitude < TOL) ? 1 : magnitude;

    cXx /= magnitude;

    cXy /= magnitude;

    cXz /= magnitude;



    // Perform the truck, if any

    cameraX -= amount * cXx;

    cameraY -= amount * cXy;

    cameraZ -= amount * cXz;

    targetX -= amount * cXx;

    targetY -= amount * cXy;

    targetZ -= amount * cXz;

}","/** Moves the camera and target simultaneously along the camera's X axis */
public void truck(float amount) 
{
    Vector3f forward = new Vector3f();
    camera.getDirection(forward);
    forward.scale(amount);
    Vector3f.add(camera.getLocation(), forward, camera.getLocation());
    Vector3f.add(target, forward, target);
}   ",1878,False
"/** Creates new form Step3 */
public Step3(){
    super(""step3"", """");
    initComponents();
}","/** Creates new form Step3 */
public Step3() 
{
    initComponents();
}   ",1889,True
"/** Creates new form GetMessagePage */
public GetMessagePage(){
    super(""getmessage"", """");
    initComponents();
}","/** Creates new form GetMessagePage */
public GetMessagePage() 
{
    initComponents();
    this.setLocationRelativeTo(null);
    this.setTitle(""Get Message"");
    this.setResizable(false);
    this.setVisible(true);
}   ",1890,True
"/** Creates new form DecryptedPage */
public DecryptedMessagePage(){
    super(""decryptedpage"", """");
    initComponents();
}","/** Creates new form DecryptedPage */
public DecryptedMessagePage() 
{
    initComponents();
    this.setLocationRelativeTo(null);
    this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    this.setVisible(true);
}   ",1892,True
"/** Creates new form Step2 */
public Step2(){
    super(""step2"", """");
    initComponents();
}","/** Creates new form Step2 */
public Step2() 
{
    initComponents();
}   ",1894,True
"/** Creates new form KeyPair */
public KeyPairPage(){
    super(""keypair"", """");
    initComponents();
}","/** Creates new form KeyPair */
public KeyPairPage() 
{
    initComponents();
}   ",1899,True
"/**
 * Constructs a new GraticuleHighlightOverlay with the given Graticule
 * selected. Note that if the Graticule is null, this won't draw anything
 * until the user taps something.
 * 
 * @param c
 *            Context from whence this came (needed for resource
 *            information)
 * @param g
 *            Graticule to draw (or null to not draw anything yet)
 * @param gcl
 *            listener to pay attention to taps when new graticules are
 *            selected
 */
public GraticuleHighlightOverlay(Context c, Graticule g,
        GraticuleChangedListener gcl){
    mContext = c;
    mGraticule = g;
    mListener = gcl;

    // Make both paints here and stash them for later.
    if (outlinePaint == null) {
        outlinePaint = new Paint();
        outlinePaint.setColor(mContext.getResources().getColor(
                R.color.graticule_stroke));
        outlinePaint.setStrokeWidth(2);
        outlinePaint.setStrokeJoin(Join.ROUND);
    }

    if (fillPaint == null) {
        fillPaint = new Paint();
        fillPaint.setStyle(Paint.Style.FILL);
        fillPaint.setColor(mContext.getResources().getColor(
                R.color.graticule_fill));
    }
}","/**
 * Constructs a new GraticuleHighlightOverlay with the given Graticule
 * selected. Note that if the Graticule is null, this won't draw anything
 * until the user taps something.
 * 
 * @param c
 *            Context from whence this came (needed for resource
 *            information)
 * @param g
 *            Graticule to draw (or null to not draw anything yet)
 * @param gcl
 *            listener to pay attention to taps when new graticules are
 *            selected
 */
public GraticuleHighlightOverlay(Context c, Graticule g,
        GraticuleChangedListener gcl) 
{
    super(c);
    graticule = g;
    graticuleChangedListener = gcl;
    init();
}       ",1900,False
"/**
 * Attempt to get the stock value stored in the database for the given
 * already-adjusted date.  This won't go to the internet; that's the
 * responsibility of a StockRunner.
 * 
 * @param con Context used to retrieve the database, if needed 
 * @param c already-adjusted date to check
 * @return the String representation of the stock, or null if it's not there
 */
public static String getStoredStock(Context con, Calendar c){
    // We don't quickcache the stock values.
    Log.d(DEBUG_TAG, ""Going to the database for a stock for "" + DateTools.getDateString(c));
    
    return getStore(con).getStock(c);
}","/**
 * Attempt to get the stock value stored in the database for the given
 * already-adjusted date.  This won't go to the internet; that's the
 * responsibility of a StockRunner.
 * 
 * @param con Context used to retrieve the database, if needed 
 * @param c already-adjusted date to check
 * @return the String representation of the stock, or null if it's not there
 */
public static String getStoredStock(Context con, Calendar c) 
{
    String result = null;

    if (con != null)
    {
        String date = StockRunner.getDateString(c);
        result = getStoredStock(con, date);
    }

    return result;
}   ",1901,True
"/**
 * Build an Info object.  Since this assumes we already have a stock price
 * AND the Graticule can tell us if we need to use the 30W rule, use the
 * REAL date on the Calendar object.
 * 
 * @param c date from which this hash comes
 * @param stockPrice effective stock price (already adjusted for the 30W Rule)
 * @param g the graticule in question
 * @return
 */
protected static Info createInfo(Calendar c, String stockPrice, Graticule g){
    // This creates the Info object that'll go right back to whatever was
    // calling it.  In general, this is the Handler in StockRunner.
    
    // So to that end, we first build up the hash.
    String hash = makeHash(c, stockPrice);
    
    // Then, get the latitude and longitude from that.
    double lat = getLatitude(g, hash);
    double lon = getLongitude(g, hash);
    
    // And finally...
    return new Info(lat, lon, g, c);
}","/**
 * Build an Info object.  Since this assumes we already have a stock price
 * AND the Graticule can tell us if we need to use the 30W rule, use the
 * REAL date on the Calendar object.
 * 
 * @param c date from which this hash comes
 * @param stockPrice effective stock price (already adjusted for the 30W Rule)
 * @param g the graticule in question
 * @return
 */
protected static Info createInfo(Calendar c, String stockPrice, Graticule g) 
{
    Info i = new Info();
    i.date = c.getTime();
    i.stockPrice = stockPrice;
    i.graticule = g;
    return i;
}   ",1902,True
"/**
 * Gets the longitude value of the location for the current date. This is
 * attached to the current graticule integer value to produce the latitude.
 * 
 * @return the fractional longitude value
 */
private static double getLongitudeHash(String hash){
    String chunk = hash.substring(16, 32);
    return HexFraction.calculate(chunk);
}","/**
 * Gets the longitude value of the location for the current date. This is
 * attached to the current graticule integer value to produce the latitude.
 * 
 * @return the fractional longitude value
 */
private static double getLongitudeHash(String hash) 
{
    double longitudeHash = 0.0;

    if (hash != null)
    {
        longitudeHash = Double.parseDouble(hash);
    }

    return longitudeHash;
}   ",1903,True
"/**
 * Sets the date on the button.
 * 
 * @param newDate new date to be set
 */
public void setDate(Calendar newDate){
    mDate = newDate;
    setText(DateFormat.getDateInstance(DateFormat.LONG).format(
            mDate.getTime()));
}","/**
 * Sets the date on the button.
 * 
 * @param newDate new date to be set
 */
public void setDate(Calendar newDate) 
{
    if (newDate != null)
    {
        date = newDate;
        SimpleDateFormat sdf = new SimpleDateFormat(""MM/dd/yyyy"");
        setText(sdf.format(date.getTime()));
    }
}   ",1904,True
"/**
 * Stores Info data away in the database.  This won't do anything if the
 * day's Info already exists therein.
 * 
 * @param con Context used to retrieve the database, if needed
 * @param i an Info bundle with everything we need
 */
private synchronized static void storeInfo(Context con, Info i){
	// First, replace the last-known results.
	quickCache(i);
	
	StockStoreDatabase store = getStore(con);
	
	// Then, write it to the database.
    store.storeInfo(i);
    store.cleanup();
}","/**
 * Stores Info data away in the database.  This won't do anything if the
 * day's Info already exists therein.
 * 
 * @param con Context used to retrieve the database, if needed
 * @param i an Info bundle with everything we need
 */

private synchronized static void storeInfo(Context con, Info i) 
{
    SQLiteDatabase db = null;
    try {
        db = new DatabaseHelper(con).getWritableDatabase();
        ContentValues values = new ContentValues();
        values.put(""day"", i.day);
        values.put(""info"", i.info);
        db.insertWithOnConflict(""info"", null, values, SQLiteDatabase.CONFLICT_IGNORE);
    } finally {
        if (db != null) {
            db.close();
        }
    }
}   ",1906,True
"/**
 * Initializes HashBuilder.  This should be called only once.  Well, it can
 * be called more often, but it won't do anything past the first time.
 */
public static synchronized void initialize(Context c){
    if(mStore == null) {
        mStore = new StockStoreDatabase(c).init();
    }
}","/**
 * Initializes HashBuilder.  This should be called only once.  Well, it can
 * be called more often, but it won't do anything past the first time.
 */
public static synchronized void initialize(Context c) 
{
    if (mInitialized)
        return;

    mInitialized = true;
    mInstance = new HashBuilder(c);
}   ",1909,False
"/**
 * Turns the given long into a terabyte representation.
 * 
 * @param input
 *            long to convert
 * @return String representation of the input in terabytes
 */
public static String toTera(long input){
    float toReturn = (float)(input) / ONETERA;
    return finishIt(toReturn, ""TB"");
}","/**
 * Turns the given long into a terabyte representation.
 * 
 * @param input
 *            long to convert
 * @return String representation of the input in terabytes
 */
public static String toTera(long input) 
{
    return toTera(input, Locale.getDefault());
}   ",1910,True
"/**
 * Turns the given long into a gigabyte representation.
 * 
 * @param input
 *            long to convert
 * @return String representation of the input in gigabytes
 */
public static String toGiga(long input){
    float toReturn = (float)(input) / ONEGIG;
    return finishIt(toReturn, ""GB"");
}","/**
 * Turns the given long into a gigabyte representation.
 * 
 * @param input
 *            long to convert
 * @return String representation of the input in gigabytes
 */
public static String toGiga(long input) 
{
    return toGiga(input, Locale.getDefault());
}   ",1912,True
"/**
 * Turns the given long into a kilobyte representation.
 * 
 * @param input
 *            long to convert
 * @return String representation of the input in kilobytes
 */
public static String toKilo(long input){
    float toReturn = (float)(input) / ONEKILO;
    return finishIt(toReturn, ""kB"");
}","/**
 * Turns the given long into a kilobyte representation.
 * 
 * @param input
 *            long to convert
 * @return String representation of the input in kilobytes
 */
public static String toKilo(long input) 
{
    return String.format(""%.1f"", (double) input / 1024);
}   ",1914,True
"/**
 * Generate the hash string from the date and stock price.  The REAL date,
 * that is.  Not a 30W Rule-adjusted date.
 * 
 * @param c date to use
 * @param stockPrice stock price to use
 * @return the hash you're looking for
 */
protected static String makeHash(Calendar c, String stockPrice){
    // Just reset the hash. This can be handy alone if the graticule has
    // changed.  Remember, c is the REAL date, not the STOCK date!
    String monthStr;
    String dayStr;

    // Zero-pad the month and date...
    if (c.get(Calendar.MONTH) + 1 < 10)
        monthStr = ""0"" + (c.get(Calendar.MONTH) + 1);
    else
        monthStr = new Integer(c.get(Calendar.MONTH) + 1).toString();

    if (c.get(Calendar.DAY_OF_MONTH) < 10)
        dayStr = ""0"" + c.get(Calendar.DAY_OF_MONTH);
    else
        dayStr = new Integer(c.get(Calendar.DAY_OF_MONTH)).toString();

    // And here it goes!
    String fullLine = c.get(Calendar.YEAR) + ""-"" + monthStr + ""-""
            + dayStr + ""-"" + stockPrice;
    return MD5Tools.MD5hash(fullLine);
}","/**
 * Generate the hash string from the date and stock price.  The REAL date,
 * that is.  Not a 30W Rule-adjusted date.
 * 
 * @param c date to use
 * @param stockPrice stock price to use
 * @return the hash you're looking for
 */
protected static String makeHash(Calendar c, String stockPrice) 
{
    String dateString = """" + c.get(Calendar.YEAR) + (c.get(Calendar.MONTH) + 1) + c.get(Calendar.DAY_OF_MONTH);
    return makeHash(dateString, stockPrice);
}   ",1916,False
"/**
 * Takes the given stream and makes a String out of whatever data it has. Be
 * really careful with this, as it will just attempt to read whatever's in
 * the stream until it stops, meaning it'll spin endlessly if this isn't the
 * sort of stream that ends.
 * 
 * @param stream
 *            InputStream to read from
 * @return a String consisting of the data from the stream
 */
protected static String getStringFromStream(InputStream stream)
        throws IOException{
    BufferedReader buff = new BufferedReader(new InputStreamReader(stream));

    // Load it up...
    StringBuffer tempstring = new StringBuffer();
    char bean[] = new char[1024];
    int read = 0;
    while ((read = buff.read(bean)) != -1) {
        tempstring.append(bean, 0, read);
    }

    return tempstring.toString();
}","/**
 * Takes the given stream and makes a String out of whatever data it has. Be
 * really careful with this, as it will just attempt to read whatever's in
 * the stream until it stops, meaning it'll spin endlessly if this isn't the
 * sort of stream that ends.
 * 
 * @param stream
 *            InputStream to read from
 * @return a String consisting of the data from the stream
 */
protected static String getStringFromStream(InputStream stream)
        throws IOException 
{
    StringBuilder builder = new StringBuilder();
    byte[] buffer = new byte[1024];
    int bytesRead;
    while ((bytesRead = stream.read(buffer)) != -1)
    {
        builder.append(new String(buffer, 0, bytesRead));
    }
    return builder.toString();
}       ",1917,False
"/**
 * Manually set the Graticule after construction. Note that the MapView will
 * need to be invalidated afterward.
 * 
 * @param g
 *            new Graticule to set
 */
public void setGraticule(Graticule g){
    mGraticule = g;
    mListener.graticuleUpdated(mGraticule);
}","/**
 * Manually set the Graticule after construction. Note that the MapView will
 * need to be invalidated afterward.
 * 
 * @param g
 *            new Graticule to set
 */
public void setGraticule(Graticule g) 
{
    if (g == null)
    {
        throw new IllegalArgumentException(""Graticule cannot be null"");
    }
    this.graticule = g;
}   ",1919,True
"/**
 * Override the key listener to receive keyUp events.
 * 
 * Check for the DPad presses left, right, up, down and middle.
 * Change the rotation speed according to the presses
 * or change the texture filter used through the middle press.
 */
@Override
public boolean onKeyUp(int keyCode, KeyEvent event){
	//
	if(keyCode == KeyEvent.KEYCODE_DPAD_LEFT) {
		yspeed -= 0.1f;
		
	} else if(keyCode == KeyEvent.KEYCODE_DPAD_RIGHT) {
		yspeed += 0.1f;
		
	} else if(keyCode == KeyEvent.KEYCODE_DPAD_UP) {
		xspeed -= 0.1f;
		
	} else if(keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {
		xspeed += 0.1f;
		
	} else if(keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
		filter += 1;
		if(filter > 2) {
			filter = 0;
		}
	}
	else return false;

	//We handled the event
	return true;
}","/**
 * Override the key listener to receive keyUp events.
 * 
 * Check for the DPad presses left, right, up, down and middle.
 * Change the rotation speed according to the presses
 * or change the texture filter used through the middle press.
 */
@Override
public boolean onKeyUp(int keyCode, KeyEvent event) 
{
    if (keyCode == KeyEvent.KEYCODE_DPAD_LEFT)
    {
        rotationSpeedX -= 0.1f;
    }
    else if (keyCode == KeyEvent.KEYCODE_DPAD_RIGHT)
    {
        rotationSpeedX += 0.1f;
    }
    else if (keyCode == KeyEvent.KEYCODE_DPAD_UP)
    {
        rotationSpeedY += 0.1f;
    }
    else if (keyCode == KeyEvent.KEYCODE_DPAD_DOWN)
    {
        rotationSpeedY -= 0.1f;
    }
    else if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER)
    {
        if (textureFilter == Linear)
        {
            textureFilter = Nearest;
        }
        else
        {
            textureFilter = Linear;
        }
    }

    return super.onKeyUp(keyCode, event);
}   ",1921,True
"/* Creates the menu items */
public boolean onCreateOptionsMenu(Menu menu){
    menu.add(0, MENU_NEW_GAME, 0, ""New Game"");
    menu.add(0, MENU_QUIT, 0, ""Quit"");
    return true;
}","/* Creates the menu items */

public boolean onCreateOptionsMenu(Menu menu) 
{
    MenuInflater inflater = getMenuInflater();
    inflater.inflate(R.menu.menu, menu);
    return true;
}   ",1922,True
"/**
 * Here we do our drawing
 */
public void onDrawFrame(GL10 gl){
	//Clear Screen And Depth Buffer
	gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);	
	gl.glLoadIdentity();					//Reset The Current Modelview Matrix
	
	//Check if the light flag has been set to enable/disable lighting
	if(light) {
		gl.glEnable(GL10.GL_LIGHTING);
	} else {
		gl.glDisable(GL10.GL_LIGHTING);
	}
	
	//Check if the blend flag has been set to enable/disable blending
	if(blend) {
		gl.glEnable(GL10.GL_BLEND);			//Turn Blending On ( NEW )
		gl.glDisable(GL10.GL_DEPTH_TEST);	//Turn Depth Testing Off ( NEW )
		
	} else {
		gl.glDisable(GL10.GL_BLEND);		//Turn Blending On ( NEW )
		gl.glEnable(GL10.GL_DEPTH_TEST);	//Turn Depth Testing Off ( NEW )
	}
	
	//Drawing
	gl.glTranslatef(0.0f, 0.0f, z);			//Move z units into the screen
	gl.glScalef(0.8f, 0.8f, 0.8f); 			//Scale the Cube to 80 percent, otherwise it would be too large for the screen
	
	//Rotate around the axis based on the rotation matrix (rotation, x, y, z)
	gl.glRotatef(xrot, 1.0f, 0.0f, 0.0f);	//X
	gl.glRotatef(yrot, 0.0f, 1.0f, 0.0f);	//Y
			
	cube.draw(gl, filter);					//Draw the Cube	
	
	//Change rotation factors
	xrot += xspeed;
	yrot += yspeed;
}","/**
 * Here we do our drawing
 */
public void onDrawFrame(GL10 gl) 
{
    gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);

    gl.glMatrixMode(GL10.GL_MODELVIEW);
    gl.glLoadIdentity();

    gl.glTranslatef(0.0f, 0.0f, -6.0f);

    gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);
    gl.glEnableClientState(GL10.GL_COLOR_ARRAY);

    gl.glRotatef(xrot, 1.0f, 0.0f, 0.0f);
    gl.glRotatef(yrot, 0.0f, 1.0f, 0.0f);
    gl.glRotatef(zrot, 0.0f, 0.0f, 1.0f);

    cube.draw(gl);

    gl.glDisableClientState(GL10.GL_VERTEX_ARRAY);
    gl.glDisableClientState(GL10.GL_COLOR_ARRAY);
}   ",1926,True
"/**
 * Make a direct NIO IntBuffer from an array of ints
 * @param arr The array
 * @return The newly created IntBuffer
 */
protected static IntBuffer makeFloatBuffer(int[] arr){
	ByteBuffer bb = ByteBuffer.allocateDirect(arr.length*4);
	bb.order(ByteOrder.nativeOrder());
	IntBuffer ib = bb.asIntBuffer();
	ib.put(arr);
	ib.position(0);
	return ib;
}","/**
 * Make a direct NIO IntBuffer from an array of ints
 * @param arr The array
 * @return The newly created IntBuffer
 */
protected static IntBuffer makeFloatBuffer(int[] arr) 
{
    IntBuffer ret = IntBuffer.allocate(arr.length);
    ret.put(arr);
    ret.flip();
    return ret;
}   ",1927,True
"/**
 * Invoked when the Activity loses user focus.
 */
@Override
protected void onPause(){

	Log.w(""Act1"", ""onPause"");
    
	super.onPause();
    mGameView.pause();
}","/**
 * Invoked when the Activity loses user focus.
 */
@Override
protected void onPause() 
{
    super.onPause();
    if (mPlayer != null)
    {
        mPlayer.pause();
    }
}   ",1929,True
"/**
 * Create a texture and send it to the graphics system
 * @param gl The GL object
 * @param bmp The bitmap of the texture
 * @param reverseRGB Should the RGB values be reversed?  (necessary workaround for loading .pngs...)
 * @return The newly created identifier for the texture.
 */
protected static int loadTexture(GL10 gl, Bitmap bmp){
	int[] tmp_tex = new int[1];

	gl.glGenTextures(1, tmp_tex, 0);
	int tex = tmp_tex[0];

	int type= GL_TEXTURE_2D;
	int width= bmp.getWidth();
	int height= bmp.getHeight();
	
//		loadTexture(tex, GL10.GL_TEXTURE_2D, bmp, gl);
	gl.glBindTexture(type, tex);
	gl.glTexImage2D(type, 0, GL10.GL_RGBA, width, height, 0, GL10.GL_RGBA, GL10.GL_UNSIGNED_BYTE, null);
//		gl.glTexSubImage2D(type, 0, 0, 0, width, height, GL10.GL_RGBA, GL10.GL_UNSIGNED_BYTE, bb);
	gl.glTexParameterf(type, GL10.GL_TEXTURE_MIN_FILTER, GL10.GL_LINEAR);
	gl.glTexParameterf(type, GL10.GL_TEXTURE_MAG_FILTER, GL10.GL_LINEAR);

	GLUtils.texImage2D(GL_TEXTURE_2D, 0, bmp, 0);
	return tex;
}","/**
 * Create a texture and send it to the graphics system
 * @param gl The GL object
 * @param bmp The bitmap of the texture
 * @param reverseRGB Should the RGB values be reversed?  (necessary workaround for loading .pngs...)
 * @return The newly created identifier for the texture.
 */
protected static int loadTexture(GL10 gl, Bitmap bmp) 
{
    int[] textures = new int[1];
    gl.glGenTextures(1, textures, 0);
    gl.glBindTexture(GL10.GL_TEXTURE_2D, textures[0]);
    gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MIN_FILTER, GL10.GL_NEAREST);
    gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MAG_FILTER, GL10.GL_LINEAR);
    GLUtils.texImage2D(GL10.GL_TEXTURE_2D, 0, bmp, 0);
    return textures[0];
}   ",1930,True
"/**
 * Instance the Cube object and set the Activity Context 
 * handed over. Initiate the light buffers and set this 
 * class as renderer for this now GLSurfaceView.
 * Request Focus and set if focusable in touch mode to
 * receive the Input from Screen and Buttons  
 * 
 * @param context - The Activity Context
 */
public Lesson08(Context context){
	super(context);
	
	//Set this as Renderer
	this.setRenderer(this);
	//Request focus, otherwise buttons won't react
	this.requestFocus();
	this.setFocusableInTouchMode(true);
	
	//
	this.context = context;		
	
	//
	ByteBuffer byteBuf = ByteBuffer.allocateDirect(lightAmbient.length * 4);
	byteBuf.order(ByteOrder.nativeOrder());
	lightAmbientBuffer = byteBuf.asFloatBuffer();
	lightAmbientBuffer.put(lightAmbient);
	lightAmbientBuffer.position(0);
	
	byteBuf = ByteBuffer.allocateDirect(lightDiffuse.length * 4);
	byteBuf.order(ByteOrder.nativeOrder());
	lightDiffuseBuffer = byteBuf.asFloatBuffer();
	lightDiffuseBuffer.put(lightDiffuse);
	lightDiffuseBuffer.position(0);
	
	byteBuf = ByteBuffer.allocateDirect(lightPosition.length * 4);
	byteBuf.order(ByteOrder.nativeOrder());
	lightPositionBuffer = byteBuf.asFloatBuffer();
	lightPositionBuffer.put(lightPosition);
	lightPositionBuffer.position(0);
	
	//
	cube = new Cube();
}","/**
 * Instance the Cube object and set the Activity Context 
 * handed over. Initiate the light buffers and set this 
 * class as renderer for this now GLSurfaceView.
 * Request Focus and set if focusable in touch mode to
 * receive the Input from Screen and Buttons  
 * 
 * @param context - The Activity Context
 */
public Lesson08(Context context) 
{
    super(context);

    // initiate the light buffers
    initLightBuffers();

    // set this class as renderer for this GLSurfaceView
    setRenderer(this);

    // request focus and set if focusable in touch mode
    // to receive the Input from Screen and Buttons
    setFocusable(true);
    setFocusableInTouchMode(true);
}   ",1932,True
"/**
 * Initialization of the Activity after it is first created.  Must at least
 * call {@link android.app.Activity#setContentView setContentView()} to
 * describe what is to be displayed in the screen.
 */
@Override
	protected void onCreate(Bundle savedInstanceState){
    // Be sure to call the super class.
    super.onCreate(savedInstanceState);

    // See assets/res/any/layout/hello_world.xml for this
    // view layout definition, which is being set here as
    // the content of our screen.
    setContentView(R.layout.hello_world);
}","/**
 * Initialization of the Activity after it is first created.  Must at least
 * call {@link android.app.Activity#setContentView setContentView()} to
 * describe what is to be displayed in the screen.
 */
@Override
	protected void onCreate(Bundle savedInstanceState) 
{
	super.onCreate(savedInstanceState);
	setContentView(R.layout.activity_main);
}	",1933,True
"/**
 * Starts this animation.
 */
public void start(){
	if (!running) {
		running = true;
		Message msg = obtainMessage(NEXT);
		sendMessageAtTime(msg, SystemClock.uptimeMillis());
	}
}","/**
 * Starts this animation.
 */
public void start() 
{
    if (running)
    {
        return;
    }
    running = true;
    animationThread = new Thread(this);
    animationThread.start();
}   ",1936,False
"/**
 * The Surface is created/init()
 */
public void onSurfaceCreated(GL10 gl, EGLConfig config){		
	//And there'll be light!
	gl.glLightfv(GL10.GL_LIGHT0, GL10.GL_AMBIENT, lightAmbientBuffer);		//Setup The Ambient Light
	gl.glLightfv(GL10.GL_LIGHT0, GL10.GL_DIFFUSE, lightDiffuseBuffer);		//Setup The Diffuse Light
	gl.glLightfv(GL10.GL_LIGHT0, GL10.GL_POSITION, lightPositionBuffer);	//Position The Light
	gl.glEnable(GL10.GL_LIGHT0);											//Enable Light 0
	
	//Blending
	gl.glColor4f(1.0f, 1.0f, 1.0f, 0.5f);				//Full Brightness. 50% Alpha ( NEW )
	gl.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE);		//Set The Blending Function For Translucency ( NEW )

	//Settings
	gl.glDisable(GL10.GL_DITHER);				//Disable dithering
	gl.glEnable(GL10.GL_TEXTURE_2D);			//Enable Texture Mapping
	gl.glShadeModel(GL10.GL_SMOOTH); 			//Enable Smooth Shading
	gl.glClearColor(0.0f, 0.0f, 0.0f, 0.5f); 	//Black Background
	gl.glClearDepthf(1.0f); 					//Depth Buffer Setup
	gl.glEnable(GL10.GL_DEPTH_TEST); 			//Enables Depth Testing
	gl.glDepthFunc(GL10.GL_LEQUAL); 			//The Type Of Depth Testing To Do
	
	//Really Nice Perspective Calculations
	gl.glHint(GL10.GL_PERSPECTIVE_CORRECTION_HINT, GL10.GL_NICEST); 
			
	//Load the texture for the cube once during Surface creation
	cube.loadGLTexture(gl, this.context);
}","/**
 * The Surface is created/init()
 */
public void onSurfaceCreated(GL10 gl, EGLConfig config) 
{
    // Do nothing.
}   ",1937,True
"/**
 * Return the Transfer Data of type DataFlavor from InputStream.
 * @param df	the DataFlavor
 * @param ds	the DataSource
 * @return		the constructed Object
 */
public Object getTransferData(DataFlavor df, DataSource ds) throws
				UnsupportedFlavorException, IOException{

	if (dch != null)
	    return dch.getTransferData(df, ds);
	else if (df.equals(getTransferDataFlavors()[0])) // only have one now
	    return ds.getInputStream();
	else
	    throw new UnsupportedFlavorException(df);
}","/**
 * Return the Transfer Data of type DataFlavor from InputStream.
 * @param df	the DataFlavor
 * @param ds	the DataSource
 * @return		the constructed Object
 */


public Object getTransferData(DataFlavor df, DataSource ds) throws
				UnsupportedFlavorException, IOException 
{
	if (df.equals(DataFlavor.stringFlavor))
	{
		InputStream is = ds.getInputStream();
		BufferedReader br = new BufferedReader(new InputStreamReader(is));
		try
		{
			StringBuffer sb = new StringBuffer();
			String s;
			while ((s = br.readLine()) != null)
			{
				sb.append(s);
			}
			return sb.toString();
		}
		finally
		{
			br.close();
		}
	}
	else
	{
		throw new UnsupportedFlavorException(df);
	}
}	",1943,False
"/**
 * Create a <code>DataHandler</code> instance referencing the
 * specified DataSource.  The data exists in a byte stream form.
 * The DataSource will provide an InputStream to access the data.
 *
 * @param ds	the DataSource
 */
public DataHandler(DataSource ds){
	// save a reference to the incoming DS
	dataSource = ds;
	oldFactory = factory; // keep track of the factory
}","/**
 * Create a <code>DataHandler</code> instance referencing the
 * specified DataSource.  The data exists in a byte stream form.
 * The DataSource will provide an InputStream to access the data.
 *
 * @param ds	the DataSource
 */
public DataHandler(DataSource ds) 
{
    this.dataSource = ds;
    this.contentType = ""application/octet-stream"";
    this.name = null;
}   ",1946,True
"/**
 * Return all the commands for this type of data.
 * This method returns an array containing all commands
 * for the type of data represented by this DataHandler. The
 * MIME type for the underlying data represented by this DataHandler
 * is used to call through to the <code>getAllCommands</code> method
 * of the CommandMap associated with this DataHandler.
 *
 * @return	the CommandInfo objects representing all the commands
 *
 * @see javax.activation.CommandMap#getAllCommands
 */
public CommandInfo[] getAllCommands(){
	if (dataSource != null)
	    return getCommandMap().getAllCommands(getBaseType(), dataSource);
	else
	    return getCommandMap().getAllCommands(getBaseType());
}","/**
 * Return all the commands for this type of data.
 * This method returns an array containing all commands
 * for the type of data represented by this DataHandler. The
 * MIME type for the underlying data represented by this DataHandler
 * is used to call through to the <code>getAllCommands</code> method
 * of the CommandMap associated with this DataHandler.
 *
 * @return	the CommandInfo objects representing all the commands
 *
 * @see javax.activation.CommandMap#getAllCommands
 */
public CommandInfo[] getAllCommands() 
{
    return commandMap.getAllCommands(mimeType);
}   ",1947,True
"/**
 * Create a <code>DataHandler</code> instance representing an object
 * of this MIME type.  This constructor is
 * used when the application already has an in-memory representation
 * of the data in the form of a Java Object.
 *
 * @param obj	the Java Object
 * @param mimeType	the MIME type of the object
 */
public DataHandler(Object obj, String mimeType){
	object = obj;
	objectMimeType = mimeType;
	oldFactory = factory; // keep track of the factory
}","/**
 * Create a <code>DataHandler</code> instance representing an object
 * of this MIME type.  This constructor is
 * used when the application already has an in-memory representation
 * of the data in the form of a Java Object.
 *
 * @param obj	the Java Object
 * @param mimeType	the MIME type of the object
 */
public DataHandler(Object obj, String mimeType) 
{
    this.obj = obj;
    this.mimeType = mimeType;
    this.dataSource = null;
}   ",1948,True
"/**
 * Return the MIME type of this object as retrieved from
 * the source object. Note that this is the <i>full</i>
 * type with parameters.
 *
 * @return	the MIME type
 */
public String getContentType(){
	if (dataSource != null) // data source case
	    return dataSource.getContentType();
	else
	    return objectMimeType; // obj/type case
}","/**
 * Return the MIME type of this object as retrieved from
 * the source object. Note that this is the <i>full</i>
 * type with parameters.
 *
 * @return	the MIME type
 */
public String getContentType() 
{
    return this.contentType;
}   ",1950,True
"/**
 * Returns whether the specified data flavor is supported
 * for this object.<p>
 *
 * This method iterates through the DataFlavors returned from
 * <code>getTransferDataFlavors</code>, comparing each with
 * the specified flavor.
 *
 * @param flavor	the requested flavor for the data
 * @return		true if the data flavor is supported
 * @see javax.activation.DataHandler#getTransferDataFlavors
 */
public boolean isDataFlavorSupported(DataFlavor flavor){
	DataFlavor[] lFlavors = getTransferDataFlavors();

	for (int i = 0; i < lFlavors.length; i++) {
	    if (lFlavors[i].equals(flavor))
		return true;
	}
	return false;
}","/**
 * Returns whether the specified data flavor is supported
 * for this object.<p>
 *
 * This method iterates through the DataFlavors returned from
 * <code>getTransferDataFlavors</code>, comparing each with
 * the specified flavor.
 *
 * @param flavor	the requested flavor for the data
 * @return		true if the data flavor is supported
 * @see javax.activation.DataHandler#getTransferDataFlavors
 */
public boolean isDataFlavorSupported(DataFlavor flavor) 
{
    DataFlavor flavors[] = getTransferDataFlavors();
    for (int i = 0; i < flavors.length; i++) {
        if (flavor.equals(flavors[i])) {
            return true;
        }
    }
    return false;
}   ",1953,True
"/**
 * Return the CommandMap for this instance of DataHandler.
 */
private synchronized CommandMap getCommandMap(){
	if (currentCommandMap != null)
	    return currentCommandMap;
	else
	    return CommandMap.getDefaultCommandMap();
}","/**
 * Return the CommandMap for this instance of DataHandler.
 */
private synchronized CommandMap getCommandMap() 
{
    if (commandMap == null)
    {
        commandMap = new CommandMap();
    }
    return commandMap;
}   ",1959,True
"/**
 * Gets the {@link Event} that was specified through the intent or null if
 * no or wrongly specified event.
 * 
 * @return The Event or null.
 */
private Event getEvent(){

	// Get the extras
	final Bundle extras = getIntent().getExtras();
	if (extras == null)
		return null;

	// Get id from extras
	if (!(extras.get(ID) instanceof Integer))
		return null;
	final int id = (Integer) extras.get(ID);

	// Load event with specified id from the db
	final DBAdapter db = new DBAdapter(this);
	try {
		db.open();
		return db.getEventById(id);
	} finally {
		db.close();
	}
}","/**
 * Gets the {@link Event} that was specified through the intent or null if
 * no or wrongly specified event.
 * 
 * @return The Event or null.
 */
private Event getEvent() 
{
    String event = getIntent().getStringExtra(""event"");
    if (event != null)
    {
        try
        {
            return Event.valueOf(event);
        }
        catch (IllegalArgumentException e)
        {
            return null;
        }
    }
    return null;
}   ",1960,False
"/**
 * Fetch the Date when the Schedule database has been imported
 * 
 * @return Date of the last Database update
 */
private Date getDBLastUpdated(){
	SharedPreferences settings = getSharedPreferences(Main.PREFS, 0);
	long timestamp = settings.getLong(""db_last_updated"", 0);
	if (timestamp == 0)
		return null;
	return new Date(timestamp * 1000);
}","/**
 * Fetch the Date when the Schedule database has been
 * 
 * @return Date of the last Database update
 */
private Date getDBLastUpdated() 
{
    // Get the current date and time
    Calendar calendar = Calendar.getInstance();
    Date currentDate = calendar.getTime();

    // Return the current date and time
    return currentDate;
}   ",1961,True
"/**
 * @return
 */
private Dialog createAboutDialog(){
	final AlertDialog.Builder builder = new AlertDialog.Builder(this);
	final View view = getLayoutInflater().inflate(R.layout.about, null,
			false);
	String version = """";
	PackageInfo pinfo;
	try {
		pinfo = getPackageManager().getPackageInfo(getPackageName(), 0);
		version = pinfo.versionName;
	} catch (NameNotFoundException e) {
	}
	
	builder.setTitle(getString(R.string.app_name) + "" - V. "" + version);
	builder.setIcon(android.R.drawable.ic_dialog_info);
	builder.setView(view);
	builder.setPositiveButton(getString(android.R.string.ok), null);
	builder.setCancelable(true);
	return builder.create();
}","/**
 * @return
 */


private Dialog createAboutDialog() 
{
    Dialog d = new Dialog(this, ""About"", true);
    d.setLayout(new BorderLayout());
    d.add(""Center"", new Label(""This is a simple example of a menu system.""));
    Panel p = new Panel();
    p.add(new Button(""OK""));
    d.add(""South"", p);
    d.pack();
    return d;
}   ",1962,False
"/**
 * Loads the contents of the event with into the gui.
 * 
 * @param event
 *            The event to show
 */
private void showEvent(Event event){
	String eventAbstract = StringUtil.niceify(event
			.getAbstract_description());
	if (eventAbstract.length() == 0)
		eventAbstract = ""No abstract available."";
	String eventDescription = StringUtil.niceify(event.getDescription());
	if (eventDescription.length() == 0)
		eventDescription = ""No lecture description avablable."";

	setTextViewText(R.id.event_title, event.getTitle());
	setTextViewText(R.id.event_track, event.getTrack());
	setTextViewText(R.id.event_room, event.getRoom());
	setTextViewText(R.id.event_time, StringUtil.datesToString(event
			.getStart(), event.getDuration()));
	setTextViewText(R.id.event_speaker, StringUtil.personsToString(event
			.getPersons()));
	setTextViewText(R.id.event_abstract, eventAbstract);
	setTextViewText(R.id.event_description, eventDescription);

	// setImageViewImage(R.id.room_image,
	// StringUtil.roomNameToURL(event.getRoom()));
	prefetchImageViewImageAndShowIt(StringUtil.roomNameToURL(event
			.getRoom()));
}","/**
 * Loads the contents of the event with into the gui.
 * 
 * @param event
 *            The event to show
 */
private void showEvent(Event event) 
{
    if (event != null)
    {
        this.event = event;
        this.titleText.setText(event.getTitle());
        this.descriptionText.setText(event.getDescription());
        this.startDateText.setText(event.getStartDate().toString());
        this.endDateText.setText(event.getEndDate().toString());
        this.locationText.setText(event.getLocation());
    }
}   ",1963,True
"// TODO eMich - get cachelocation from Android environment
public static Object fetch(String address) throws MalformedURLException,
			IOException{
		URL url = new URL(address);
		Object content = url.getContent();
		return content;
	}","// TODO eMich - get cachelocation from Android environment





public static Object fetch(String address) throws MalformedURLException,
			IOException 
{
	URL url = new URL(address);
	HttpURLConnection connection = (HttpURLConnection) url.openConnection();
	connection.setRequestMethod(""GET"");
	connection.setDoOutput(true);
	connection.connect();

	return connection.getContent();
}	",1964,True
"/**
 * Prefetches the rooms images
 */
private void updateRooms(){

	sendMessage(Main.ROOMIMGSTART);

	// get the list of the rooms
	final String[] rooms;
	final DBAdapter db = new DBAdapter(context);
	db.open();
	try {
		rooms = db.getRooms();
	} finally {
		db.close();
	}

	// Download the images in the background
	for (final String room : rooms) {
		// Log.d(LOG_TAG, ""Downloading room image:"" + room);
		try {
			FileUtil.fetchCached(StringUtil.roomNameToURL(room));
		} catch (MalformedURLException e) {
		} catch (IOException e) {
		}
	}

	sendMessage(Main.ROOMIMGDONE);
}","/**
 * Prefetches the rooms images
 */
private void updateRooms() 
{
    for (Room room : rooms)
    {
        room.prefetch();
    }
}   ",1966,False
"/**
 * Sets up a uri matcher for search suggestion and shortcut refresh queries.
 */
private static UriMatcher buildUriMatcher(){
	UriMatcher matcher = new UriMatcher(UriMatcher.NO_MATCH);
	matcher.addURI(AUTHORITY, SearchManager.SUGGEST_URI_PATH_QUERY,
			SEARCH_SUGGEST);
	matcher.addURI(AUTHORITY, SearchManager.SUGGEST_URI_PATH_QUERY + ""/*"",
			SEARCH_SUGGEST);
	matcher.addURI(AUTHORITY, SearchManager.SUGGEST_URI_PATH_SHORTCUT,
			SHORTCUT_REFRESH);
	matcher.addURI(AUTHORITY, SearchManager.SUGGEST_URI_PATH_SHORTCUT
			+ ""/*"", SHORTCUT_REFRESH);
	return matcher;
}","/**
 * Sets up a uri matcher for search suggestion and shortcut refresh queries.
 */
private static UriMatcher buildUriMatcher() 
{
    final UriMatcher matcher = new UriMatcher(UriMatcher.NO_MATCH);
    final String authority = Contract.CONTENT_AUTHORITY;

    // For each type of URI you want to add, create a corresponding code.
    matcher.addURI(authority, Contract.PATH_SEARCH_SUGGESTION, SEARCH_SUGGESTION);
    matcher.addURI(authority, Contract.PATH_SHORTCUT_REFRESH, SHORTCUT_REFRESH);
    return matcher;
}   ",1968,True
"/**
 * Converts a cursor over the events table to a list of {@link Event}s. If
 * the cursor is empty, will return an empty list.
 *
 * @param eventsCursor
 *            The cursor.
 * @return A list of events.
 */
protected List<Event> getEventsFromCursor(Cursor eventsCursor){
	eventsCursor.moveToFirst();
	final List<Event> events = new ArrayList<Event>();
	for (int i = 0; i < eventsCursor.getCount(); i++) {
		final Event event = new Event();
		event.setId(eventsCursor.getInt(eventsCursor.getColumnIndex(ID)));
		event.setStart(new Date(eventsCursor.getLong(eventsCursor
				.getColumnIndex(START))));
		event.setDuration(eventsCursor.getInt(eventsCursor
				.getColumnIndex(DURATION)));
		event.setRoom(eventsCursor.getString(eventsCursor
				.getColumnIndex(ROOM)));
		event.setTag(eventsCursor.getString(eventsCursor
				.getColumnIndex(TAG)));
		event.setTitle(eventsCursor.getString(eventsCursor
				.getColumnIndex(TITLE)));
		event.setSubtitle(eventsCursor.getString(eventsCursor
				.getColumnIndex(SUBTITLE)));
		event.setTrack(eventsCursor.getString(eventsCursor
				.getColumnIndex(TRACK)));
		event.setType(eventsCursor.getString(eventsCursor
				.getColumnIndex(EVENTTYPE)));
		event.setLanguage(eventsCursor.getString(eventsCursor
				.getColumnIndex(LANGUAGE)));
		event.setAbstract_description(eventsCursor.getString(eventsCursor
				.getColumnIndex(ABSTRACT)));
		event.setDescription(eventsCursor.getString(eventsCursor
				.getColumnIndex(DESCRIPTION)));
		event.setDayindex(eventsCursor.getInt(eventsCursor
				.getColumnIndex(DAYINDEX)));
		events.add(event);
		event.setPersons(getPersonsForEvent(event.getId()));
		eventsCursor.moveToNext();
	}
	eventsCursor.close();
	return events;
}","/**
 * Converts a cursor over the events table to a list of {@link Event}s. If
 * the cursor is empty, will return an empty list.
 *
 * @param eventsCursor
 *            The cursor.
 * @return A list of events.
 */

protected List<Event> getEventsFromCursor(Cursor eventsCursor) 
{
    List<Event> events = new ArrayList<Event>();
    if (eventsCursor != null && eventsCursor.moveToFirst())
    {
        do
        {
            events.add(getEventFromCursor(eventsCursor));
        } while (eventsCursor.moveToNext());
    }
    return events;
}   ",1969,False
"/**
 * Retrieves the event for given id, or null if no such event exists.
 *
 * @param id
 *            The id of the requested event.
 * @return The event or null.
 */
public Event getEventById(int id){
	final Cursor eventsById = db.query(TABLE_EVENTS, new String[] { ID,
			START, DURATION, ROOM, TAG, TITLE, SUBTITLE, TRACK, EVENTTYPE,
			LANGUAGE, ABSTRACT, DESCRIPTION, DAYINDEX }, ""id = :1"",
			new String[] { Integer.toString(id) }, null, null, START, null);

	if (eventsById.getCount() < 1)
		return null;

	return getEventsFromCursor(eventsById).get(0);
}","/**
 * Retrieves the event for given id, or null if no such event exists.
 *
 * @param id
 *            The id of the requested event.
 * @return The event or null.
 */
public Event getEventById(int id) 
{
    for (Event event : events)
    {
        if (event.getId() == id)
        {
            return event;
        }
    }
    return null;
}   ",1971,False
"/**
 * Returns the persons in the list as a comma separated string of their the
 * names.
 * 
 * @param persons
 *            A list of persons
 * @return A string with their names
 */
public static String personsToString(final List<Person> persons){
	final StringBuffer sb = new StringBuffer();
	boolean first = true;
	for (final Person person : persons) {
		if (!first)
			sb.append("", "");
		sb.append(person.getName());
		first = false;
	}
	return sb.toString();
}","/**
 * Returns the persons in the list as a comma separated string of their the
 * names.
 * 
 * @param persons
 *            A list of persons
 * @return A string with their names
 */
public static String personsToString(final List<Person> persons) 
{
    StringBuilder builder = new StringBuilder();
    for (Person person : persons)
    {
        if (builder.length() > 0)
        {
            builder.append("", "");
        }
        builder.append(person.getName());
    }
    return builder.toString();
}   ",1972,True
"/**
 * Set NOW as the time that the Schedule database has been imported.
 */
private void setDBLastUpdated(){
	SharedPreferences.Editor editor = getSharedPreferences(Main.PREFS, 0)
			.edit();
	long timestamp = System.currentTimeMillis() / 1000;
	editor.putLong(""db_last_updated"", timestamp);
	editor.commit(); // Don't forget to commit your edits!!!
}","/**
 * Set NOW as the time that the Schedule database has been
 */

private void setDBLastUpdated() 
{
    SharedPreferences settings = getSharedPreferences(PREFS_NAME, 0);
    SharedPreferences.Editor editor = settings.edit();
    editor.putLong(""db_last_updated"", System.currentTimeMillis());
    editor.commit();
}   ",1973,True
"/**
 * Sends a message to the handler of the specific type (in arg1)
 * 
 * @param type
 */
private void sendMessage(int type){
	final Message msg = Message.obtain();
	msg.what = type;
	handler.sendMessage(msg);
}","/**
 * Sends a message to the handler of the specific type (in arg1)
 * 
 * @param type
 */
private void sendMessage(int type) 
{
    Message msg = new Message();
    msg.what = type;
    this.handler.sendMessage(msg);
}   ",1979,True
"/**
 * Creates new source.
 * 
 * @param connectionPointUrl the url of ActiveMQ server.
 * @throws JMSException if something goes wrong.
 */
public ActiveMqQuoteSource(String connectionPointUrl) throws JMSException{
	super(""ActiveMqQuoteSource (multi vendor)"");

	this.connectionPointUrl = connectionPointUrl;
	connect();
}","/**
 * Creates new source.
 * 
 * @param connectionPointUrl the url of ActiveMQ server.
 * @throws JMSException if something goes wrong.
 */



public ActiveMqQuoteSource(String connectionPointUrl) throws JMSException 
{
    this.connectionPointUrl = connectionPointUrl;
    ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(connectionPointUrl);
    connection = connectionFactory.createConnection();
    connection.start();
    session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
    destination = session.createQueue(QUEUE_NAME);
    consumer = session.createConsumer(destination);
}   ",1982,True
"/**
 * Converts an array of stacktrace elements to a string.
 * @param elements
 * @return a string representation of a stack trace. 
 */
public static String getStackTraceMessage(StackTraceElement[] elements){
        // Create message
        String separator = System.getProperty(""line.separator"");
        String message = """";
        for(int i = 0; i < elements.length; i++) {
            message += elements[i].toString() + separator;
        }
        return message;        
    }","/**
 * Converts an array of stacktrace elements to a string.
 * @param elements
 * @return a string representation of a stack trace. 
 */
public static String getStackTraceMessage(StackTraceElement[] elements) 
{
    StringBuilder sb = new StringBuilder();
    for (StackTraceElement element : elements)
    {
        sb.append(element.toString());
        sb.append(""\n"");
    }
    return sb.toString();
}   ",1983,True
"/**
 * Gets the shared instance of this Class
 *
 * @return the shared service locator instance.
 */
public static final ServiceLocator instance(final String beanFactoryReferenceLocation){
	instance.init(beanFactoryReferenceLocation);
    return instance;
}","/**
 * Gets the shared instance of this Class
 *
 * @return the shared service locator instance.
 */
public static final ServiceLocator instance(final String beanFactoryReferenceLocation) 
{
    if (instance == null)
    {
        instance = new ServiceLocator(beanFactoryReferenceLocation);
    }
    return instance;
}   ",1984,True
"/**
	 * Initializes the Spring application context from the given
	 * <code>beanFactoryReferenceLocation</code>. If <code>null</code> is
	 * specified for the <code>beanFactoryReferenceLocation</code> then the
	 * default application context will be used.
	 * 
	 * @param beanFactoryReferenceLocation
	 *            the location of the beanRefFactory reference.
	 */
public synchronized void init(final String beanFactoryReferenceLocation){
		this.beanFactoryReferenceLocation = beanFactoryReferenceLocation;
		this.beanFactoryReference = null;
	}","/**
	 * Initializes the Spring application context from the given
	 * <code>beanFactoryReferenceLocation</code>. If <code>null</code> is
	 * specified for the <code>beanFactoryReferenceLocation</code> then the
	 * default application context will be used.
	 * 
	 * @param beanFactoryReferenceLocation
	 *            the location of the beanRefFactory reference.
	 */
public synchronized void init(final String beanFactoryReferenceLocation) 
{
    if (this.initialized)
    {
        throw new IllegalStateException(
                ""ApplicationContext already initialized"");
    }

    if (beanFactoryReferenceLocation != null)
    {
        this.beanFactoryReference = new BeanRefContextReference(
                beanFactoryReferenceLocation);
    }

    this.initialized = true;
}	",1985,True
"/**
 * @param innerSeries the innerSeries to set
 */
public void setInnerCandles(TimeFrame timeFrame, Candle[] innerSeries){
	SeriesSpecification spec = new SeriesSpecification(this.getInstrumentSpecification(), timeFrame);
	this.innerCandles = new CandleSeries(spec, innerSeries);
}","/**
 * @param innerSeries the innerSeries to set
 */
public void setInnerCandles(TimeFrame timeFrame, Candle[] innerSeries) 
{
    this.innerSeries = new HashMap<TimeFrame, Candle[]>();
    this.innerSeries.put(timeFrame, innerSeries);
}   ",1987,True
"/**
	 * Shuts down the ServiceLocator and releases any used resources.
	 */
public synchronized void shutdown(){
		if (this.beanFactoryReference != null) {
			this.beanFactoryReference.release();
			this.beanFactoryReference = null;
		}
	}","/**
	 * Shuts down the ServiceLocator and releases any used resources.
	 */
public synchronized void shutdown() 
{
	if (this.locator != null)
	{
		this.locator.shutdown();
		this.locator = null;
	}
}	",1989,True
"/**
 * 
 * @param symbol
 * @param exchange
 * @param vendor
 * @param currency
 * @param securityType
 * @param expiry
 * @param strike
 * @param contractRight
 * @param decorations
 */
public InstrumentSpecification(Symbol symbol, String exchange,
		String vendor, String currency, String securityType, Expiry expiry,
		double strike, String contractRight, DecorationsMap decorations){
	this.symbol = symbol;
	this.exchange = exchange;
	this.vendor = vendor;
	this.currency = currency;
	this.securityType = securityType;
	this.expiry = expiry;
	this.strike = strike;
	this.contractRight = contractRight;
	this.decorations = decorations;
}","/**
 * 
 * @param symbol
 * @param exchange
 * @param vendor
 * @param currency
 * @param securityType
 * @param expiry
 * @param strike
 * @param contractRight
 * @param decorations
 */
public InstrumentSpecification(Symbol symbol, String exchange,
		String vendor, String currency, String securityType, Expiry expiry,
		double strike, String contractRight, DecorationsMap decorations) 
{
	this.symbol = symbol;
	this.exchange = exchange;
	this.vendor = vendor;
	this.currency = currency;
	this.securityType = securityType;
	this.expiry = expiry;
	this.strike = strike;
	this.contractRight = contractRight;
	this.decorations = decorations;
}	",1990,True
"/**
 * copy constructor.
 * @param instrumentSpecification
 */
public InstrumentSpecification(InstrumentSpecification spec){
	this.id = spec.getId();
	this.symbol = spec.getSymbol();
	this.exchange = spec.getExchange();
	this.vendor = spec.getVendor();
	this.currency = spec.getCurrency();
	this.securityType = spec.getSecurityType();
	this.expiry = spec.getExpiry();
	this.decorations = spec.getDecorationMap();
	this.contractRight = spec.getContractRight();
	this.strike = spec.getStrike();
}","/**
 * copy constructor.
 * @param instrumentSpecification
 */
public InstrumentSpecification(InstrumentSpecification spec) 
{
    this.instrumentId = spec.instrumentId;
    this.price = spec.price;
    this.symbol = spec.symbol;
    this.type = spec.type;
}   ",1991,True
"/**
 * 
 * @param symbol
 * @param exchange
 * @param vendor
 * @param currency
 * @param securityType
 * @param expiry
 * @param strike
 * @param contractRight
 * @param infos
 */
public InstrumentSpecification(Symbol symbol, String exchange,
		String vendor, String currency, String securityType, Expiry expiry,
		double strike, String contractRight, String infos){
	this.symbol = symbol;
	this.exchange = exchange;
	this.vendor = vendor;
	this.currency = currency;
	this.securityType = securityType;
	this.expiry = expiry;
	this.strike = strike;
	this.contractRight = contractRight;
	decorations.addDecorations(infos);
}","/**
 * 
 * @param symbol
 * @param exchange
 * @param vendor
 * @param currency
 * @param securityType
 * @param expiry
 * @param strike
 * @param contractRight
 * @param infos
 */
public InstrumentSpecification(Symbol symbol, String exchange,
		String vendor, String currency, String securityType, Expiry expiry,
		double strike, String contractRight, String infos) 
{
	super(symbol, exchange, vendor, currency, securityType, expiry, strike,
			contractRight, infos);
}	",1992,True
"/**
 * clone this instance.
 * @return cloned object
 */
@Override
	public Candle clone(){
		return new Candle(getInstrumentSpecification(), 
				getTimeStamp(), 
				openPrice, 
				highPrice, 
				lowPrice, 
				closePrice, 
				volume,
				timeFrame);
	}","/**
 * clone this instance.
 * @return cloned object
 */
@Override
	public Candle clone() 
{
	Candle candle = null;
	try
	{
		candle = (Candle) super.clone();
	} catch (CloneNotSupportedException e)
	{
		e.printStackTrace();
	}
	return candle;
}	",1993,True
"/**
 * Stops the service. Please, mark this as Spring's bean 
 * ""destroy-method"" so that service is disconnected upon 
 * Spring context destruction
 * 
 * @throws JMSException
 */
public void stop() throws JMSException{
	log.info(""Stopping listener."");
	connection.close();
}","/**
 * Stops the service. Please, mark this as Spring's bean 
 * ""destroy-method"" so that service is disconnected upon 
 * Spring context destruction
 * 
 * @throws JMSException
 */
public void stop() throws JMSException 
{
    if (connection != null)
    {
        connection.stop();
        connection.close();
    }
}   ",1994,True
"/**
 * Call this method to initialize the object (all properties must be already set).
 * When using Spring, declare this as bean's ""init-method"".
 * 
 * @throws Exception if something goes wrong.
 */
public void init() throws Exception{
		Order[] openOrders = this.getBrokerAccount().getOrderBook().getOpenOrders();
		for(Order o : openOrders) {
			quoteTracker.addToManagedOrders(o);
		}
}","/**
 * Call this method to initialize the object (all properties must be already set).
 * When using Spring, declare this as bean's ""init-method"".
 * 
 * @throws Exception if something goes wrong.
 */
public void init() throws Exception 
{
    if (mBeanServer == null)
    {
        throw new Exception(""mBeanServer is null"");
    }
    if (mObjectName == null)
    {
        throw new Exception(""mObjectName is null"");
    }
    if (mManagedResource == null)
    {
        throw new Exception(""mManagedResource is null"");
    }

    mBeanServer.registerMBean(mManagedResource, mObjectName);
}   ",1997,False
"/**
 * stub implementation, override in your trade system.
 */
@Override
public Order[] onExecution(Account account, Execution execution,  Order changedOrder) throws Exception{
	log.info(""Execution "" + execution + "" \n Order status change :""+changedOrder.toString()+""\ncurrent position count ""+account.getPortfolio().getPositions().length);

	if(msg != null) {
		msg.sendMessage(targetJid, null, ""Execution "" +execution.toString()+"" \n Order status change :""+changedOrder.toString()+""\ncurrent position count ""+account.getPortfolio().getPositions().length);
	}
	
	List<Order> orders = new ArrayList<Order>();
	if(changedOrder.getType()==OrderType.LIMIT || changedOrder.getType()==OrderType.STOP || changedOrder.getType()==OrderType.TRAILING_STOP 
			|| changedOrder.getType()==OrderType.STOP_LIMIT){
		// cancel all other orders. 
		for(Order openOrder : account.getOrderBook().getOpenOrders()){
			openOrder.setState(OrderState.CANCELED);
			// verydirtyharry.
			orders.add(openOrder);
			log.info(""Execution CANCELLING: "" + openOrder);
		}
		flat = true; 
	}
	else{
		
		if(changedOrder.getMessage()!=null && changedOrder.getMessage().equals(""OPEN"")){
			
			if(changedOrder.getSide() == OrderSide.BUY){

				// check if it was a simple buy order ... 
				// add a target profit order. 
				Order targetProfitOrder = changedOrder.clone();
				targetProfitOrder.setSide(OrderSide.SELL);
				targetProfitOrder.setType(OrderType.LIMIT);
				targetProfitOrder.setLimitPrice(changedOrder.getAveragePrice()+20);
				
				// add a stop loss order
				Order stopLossOrder = changedOrder.clone();
				stopLossOrder.setSide(OrderSide.SELL);
				stopLossOrder.setType(OrderType.STOP);
				stopLossOrder.setStopPrice(changedOrder.getAveragePrice()-80);
				
				// add a trailing order. 
				Order trailingOrder = changedOrder.clone();
				trailingOrder.setSide(OrderSide.SELL);
				trailingOrder.setType(OrderType.TRAILING_STOP);
				trailingOrder.setLimitPrice(changedOrder.getAveragePrice()+2);
				trailingOrder.setTrailingDistance(2);
				
				orders.add(targetProfitOrder);
				orders.add(stopLossOrder);
				orders.add(trailingOrder);
				log.info(""Execution ADDING: "" + targetProfitOrder);
				log.info(""Execution ADDING: "" + stopLoss);
				log.info(""Execution ADDING: "" + trailingOrder);
			}
			else{
				// add a target profit order. 
				Order targetProfitOrder = changedOrder.clone();
				targetProfitOrder.setSide(OrderSide.BUY);
				targetProfitOrder.setType(OrderType.LIMIT);
				targetProfitOrder.setLimitPrice(changedOrder.getAveragePrice()-20);
				
				// add a stop loss order
				Order stopLossOrder = changedOrder.clone();
				stopLossOrder.setSide(OrderSide.BUY);
				stopLossOrder.setType(OrderType.STOP);
				stopLossOrder.setStopPrice(changedOrder.getAveragePrice()+80);
				
				// add a trailing order. 
				Order trailingOrder = changedOrder.clone();
				trailingOrder.setSide(OrderSide.BUY);
				trailingOrder.setType(OrderType.TRAILING_STOP);
				trailingOrder.setLimitPrice(changedOrder.getAveragePrice()-2);
				trailingOrder.setTrailingDistance(2);
			

				orders.add(targetProfitOrder);
				orders.add(stopLossOrder);
				orders.add(trailingOrder);	
				log.info(""Execution ADDING: "" + targetProfitOrder);
				log.info(""Execution ADDING: "" + stopLoss);
				log.info(""Execution ADDING: "" + trailingOrder);
			}
		}
	}

	/**
	if(account.getPortfolio().getPositions().length == 0){
		flat = true; 
		log.info(""Execution declares FLAT"");
	}
	**/
	
	return orders.toArray(new Order[]{});
}","/**
 * stub implementation, override in your trade system.
 */
@Override
public Order[] onExecution(Account account, Execution execution,  Order changedOrder) throws Exception 
{
    return new Order[0];
}   ",1998,False
